diff -urN vim-src/Contents vim-qt-src/Contents
--- vim-src/Contents	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/Contents	2016-06-08 06:39:27.442313005 +0200
@@ -0,0 +1,23 @@
+Vim		Vi IMproved.  A clone of the UNIX text editor Vi.  Very useful
+		for editing programs and other plain ASCII text.  Full Vi
+		compatibility and includes all Ex commands.  Extra features
+		above Vi: Multilevel undo, multiple windows, syntax
+		highlighting, command line history, folding, improved command
+		line editing, command typeahead display, command to display
+		yank buffers, possibility to edit binary files, file name
+		stack, support for Manx QuickFix and other compiler's error
+		messages, shows current file name in window title, on-line
+		help, rectangular cut/paste, etc., etc., etc...
+
+		Version 7.4.  Also runs under UNIX, MSDOS and other systems.
+		vim74rt.tgz  contains the documentation and syntax files.
+		vim74bin.tgz contains the binaries.
+		vim74src.tgz contains the sources.
+		Author: Bram Moolenaar et al.
+
+
+Xxd		Hex dumper and reader.  Can be used to view files as hex, edit
+		them and write them back.  Can also be used to patch files.
+
+		Version 1.8 (1997 May 22)
+		Author: Juergen Weigert
Binary files vim-src/Contents.info and vim-qt-src/Contents.info differ
Binary files vim-src/README.txt.info and vim-qt-src/README.txt.info differ
diff -urN vim-src/README_ami.txt vim-qt-src/README_ami.txt
--- vim-src/README_ami.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_ami.txt	2016-06-08 06:39:27.442313005 +0200
@@ -0,0 +1,32 @@
+README_ami.txt for version 7.4 of Vim: Vi IMproved.
+
+This file explains the installation of Vim on Amiga systems.
+See README.txt for general information about Vim.
+
+
+Unpack the distributed files in the place where you want to keep them.  It is
+wise to have a "vim" directory to keep your vimrc file and any other files you
+change.  The distributed files go into a subdirectory.  This way you can
+easily upgrade to a new version.  For example:
+
+  dh0:editors/vim		contains your vimrc and modified files
+  dh0:editors/vim/vim54		contains the Vim version 5.4 distributed files
+  dh0:editors/vim/vim55		contains the Vim version 5.5 distributed files
+
+You would then unpack the archives like this:
+
+  cd dh0:editors
+  tar xf t:vim60bin.tar
+  tar xf t:vim60rt.tar
+
+Set the $VIM environment variable to point to the top directory of your Vim
+files.  For the above example:
+
+  set VIM=dh0:editors/vim
+
+Vim version 5.4 will look for your vimrc file in $VIM, and for the runtime
+files in $VIM/vim54.  See ":help $VIM" for more information.
+
+Make sure the Vim executable is in your search path.  Either copy the Vim
+executable to a directory that is in your search path, or (preferred) modify
+the search path to include the directory where the Vim executable is.
Binary files vim-src/README_ami.txt.info and vim-qt-src/README_ami.txt.info differ
diff -urN vim-src/README_amibin.txt vim-qt-src/README_amibin.txt
--- vim-src/README_amibin.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_amibin.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,12 @@
+README_amibin.txt for version 7.4 of Vim: Vi IMproved.
+
+See "README.txt" for general information about Vim.
+See "README_ami.txt" for installation instructions for the Amiga.
+These files are in the runtime archive (vim60rt.tgz).
+
+
+The Amiga "bin" archive contains the Vim executable for the Amiga.  It was
+compiled with "big" features.
+
+Postscript printing is not included to avoid requiring floating point
+computations.
Binary files vim-src/README_amibin.txt.info and vim-qt-src/README_amibin.txt.info differ
diff -urN vim-src/README_amisrc.txt vim-qt-src/README_amisrc.txt
--- vim-src/README_amisrc.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_amisrc.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,11 @@
+README_amisrc.txt for version 7.4 of Vim: Vi IMproved.
+
+See "README.txt" for general information about Vim.
+See "README_ami.txt" for installation instructions for the Amiga.
+These files are in the runtime archive (vim60rt.tgz).
+
+
+The Amiga source archive contains the files needed to compile Vim on the
+Amiga.
+
+See "src/INSTALLami.txt" for instructions on how to compile Vim on the Amiga.
Binary files vim-src/README_amisrc.txt.info and vim-qt-src/README_amisrc.txt.info differ
diff -urN vim-src/README_bindos.txt vim-qt-src/README_bindos.txt
--- vim-src/README_bindos.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_bindos.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,16 @@
+README_bindos.txt for version 7.4 of Vim: Vi IMproved.
+
+See "README.txt" for general information about Vim.
+See "README_dos.txt" for installation instructions for MS-DOS and MS-Windows.
+These files are in the runtime archive (vim74rt.zip).
+
+
+There are several binary distributions of Vim for the PC.  You would normally
+pick only one of them, but it's also possible to install several.
+These ones are available (the version number may differ):
+	vim74w32.zip	Windows 95/98/NT/etc. console version
+	gvim74.zip	Windows 95/98/NT/etc. GUI version
+	gvim74ole.zip	Windows 95/98/NT/etc. GUI version with OLE
+
+You MUST also get the runtime archive (vim74rt.zip).
+The sources are also available (vim74src.zip).
diff -urN vim-src/README_dos.txt vim-qt-src/README_dos.txt
--- vim-src/README_dos.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_dos.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,154 @@
+README_dos.txt for version 7.4 of Vim: Vi IMproved.
+
+This file explains the installation of Vim on MS-DOS and MS-Windows systems.
+See "README.txt" for general information about Vim.
+
+There are two ways to install Vim:
+A. Use the self-installing .exe file.
+B. Unpack .zip files and run the install.exe program.
+
+
+A. Using the self-installing .exe
+---------------------------------
+
+This is mostly self-explaining.  Just follow the prompts and make the
+selections.  A few things to watch out for:
+
+- When an existing installation is detected, you are offered to first remove
+  this.  The uninstall program is then started while the install program waits
+  for it to complete.  Sometimes the windows overlap each other, which can be
+  confusing.  Be sure the complete the uninstalling before continuing the
+  installation.  Watch the taskbar for uninstall windows.
+
+- When selecting a directory to install Vim, use the same place where other
+  versions are located.  This makes it easier to find your _vimrc file.  For
+  example "C:\Program Files\vim" or "D:\vim".  A name ending in "vim" is
+  preferred.
+
+- After selecting the directory where to install Vim, clicking on "Next" will
+  start the installation.
+
+
+B. Using .zip files
+-------------------
+
+These are the normal steps to install Vim from the .zip archives:
+
+1. Go to the directory where you want to put the Vim files.  Examples:
+	cd C:\
+	cd D:\editors
+   If you already have a "vim" directory, go to the directory in which it is
+   located.  Check the $VIM setting to see where it points to:
+	set VIM
+   For example, if you have
+	C:\vim\vim54
+   do
+	cd C:\
+   Binary and runtime Vim archives are normally unpacked in the same location,
+   on top of each other.
+
+2. Unpack the zip archives.  This will create a new directory "vim\vim74",
+   in which all the distributed Vim files are placed.  Since the directory
+   name includes the version number, it is unlikely that you overwrite
+   existing files.
+   Examples:
+	pkunzip -d gvim74.zip
+	unzip vim74w32.zip
+
+   You need to unpack the runtime archive and at least one of the binary
+   archives.  When using more than one binary version, be careful not to
+   overwrite one version with the other, the names of the executables
+   "vim.exe" and "gvim.exe" are the same.
+
+   After you unpacked the files, you can still move the whole directory tree
+   to another location.  That is where they will stay, the install program
+   won't move or copy the runtime files.
+
+   Only for the 32 bit DOS version on MS-DOS without DPMI support (trying to
+   run install.exe will produce an error message): Unpack the CSDPMI4B.ZIP
+   archive and follow the instructions in the documentation.
+
+3. Change to the new directory:
+	cd vim\vim74
+   Run the "install.exe" program.  It will ask you a number of questions about
+   how you would like to have your Vim setup.  Among these are:
+   - You can tell it to write a "_vimrc" file with your preferences in the
+     parent directory.
+   - It can also install an "Edit with Vim" entry in the Windows Explorer
+     popup menu.
+   - You can have it create batch files, so that you can run Vim from the
+     console or in a shell.  You can select one of the directories in your
+     $PATH.  If you skip this, you can add Vim to the search path manually:
+     The simplest is to add a line to your autoexec.bat.  Examples:
+	set path=%path%;C:\vim\vim74
+	set path=%path%;D:\editors\vim\vim74
+   - Create entries for Vim on the desktop and in the Start menu.
+
+That's it!
+
+
+Remarks:
+
+- If Vim can't find the runtime files, ":help" won't work and the GUI version
+  won't show a menubar.  Then you need to set the $VIM environment variable to
+  point to the top directory of your Vim files.  Example:
+    set VIM=C:\editors\vim
+  Vim version 7.4 will look for your vimrc file in $VIM, and for the runtime
+  files in $VIM/vim74.  See ":help $VIM" for more information.
+
+- To avoid confusion between distributed files of different versions and your
+  own modified vim scripts, it is recommended to use this directory layout:
+  ("C:\vim" is used here as the root, replace it with the path you use)
+  Your own files:
+	C:\vim\_vimrc			Your personal vimrc.
+	C:\vim\_viminfo			Dynamic info for 'viminfo'.
+	C:\vim\vimfiles\ftplugin\*.vim	Filetype plugins
+	C:\vim\...			Other files you made.
+  Distributed files:
+	C:\vim\vim74\vim.exe		The Vim version 7.4 executable.
+	C:\vim\vim74\doc\*.txt		The version 7.4 documentation files.
+	C:\vim\vim74\bugreport.vim	A Vim version 7.4 script.
+	C:\vim\vim74\...		Other version 7.4 distributed files.
+  In this case the $VIM environment variable would be set like this:
+	set VIM=C:\vim
+  Then $VIMRUNTIME will automatically be set to "$VIM\vim74".  Don't add
+  "vim74" to $VIM, that won't work.
+
+- You can put your Vim executable anywhere else.  If the executable is not
+  with the other Vim files, you should set $VIM. The simplest is to add a line
+  to your autoexec.bat.  Examples:
+	set VIM=c:\vim
+	set VIM=d:\editors\vim
+
+- If you have told the "install.exe" program to add the "Edit with Vim" menu
+  entry, you can remove it by running the "uninstal.exe".  See
+  ":help win32-popup-menu".
+
+- In Windows 95/98/NT you can create a shortcut to Vim.  This works for all
+  DOS and Win32 console versions.  For the console version this gives you the
+  opportunity to set defaults for the Console where Vim runs in.
+
+  1. On the desktop, click right to get a menu.  Select New/Shortcut.
+  2. In the dialog, enter Command line: "C:\command.com".  Click "Next".
+  3. Enter any name.  Click "Finish".
+     The new shortcut will appear on the desktop.
+  4. With the mouse pointer on the new shortcut, click right to get a menu.
+     Select Properties.
+  5. In the Program tab, change the "Cmdline" to add "/c" and the name of the
+     Vim executable.  Examples:
+	C:\command.com /c C:\vim\vim74\vim.exe
+	C:\command.com /c D:\editors\vim\vim74\vim.exe
+  6. Select the font, window size, etc. that you like.  If this isn't
+     possible, select "Advanced" in the Program tab, and deselect "MS-DOS
+     mode".
+  7. Click OK.
+
+  For gvim, you can use a normal shortcut on the desktop, and set the size of
+  the Window in your $VIM/_gvimrc:
+	set lines=30 columns=90
+
+
+For further information, type one of these inside Vim:
+	:help dos
+	:help msdos
+	:help win32
diff -urN vim-src/README_extra.txt vim-qt-src/README_extra.txt
--- vim-src/README_extra.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_extra.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,51 @@
+README_extra.txt for version 7.4 of Vim: Vi IMproved.
+
+These extra files of Vim are for special purposes.  This README explains what
+the files are for.  For general information about Vim, see the "README.txt"
+file.
+
+
+farsi/*			Files for the Farsi (persian) language.  If you don't
+			know what Farsi is, this is not for you.
+
+src/if_sniff.*		Interface to SNiFF.  If you don't know what SNiFF is,
+			this is not for you.
+
+src/os_amiga.*		Files for the Amiga port.
+
+src/gui_beos.*
+src/os_beos.*		Files for the BeOS port.
+
+src/os_msdos.*
+src/os_dos.*		Files for the MS-DOS port.
+
+src/gui_mac.*
+src/os_mac.*		Files for the Mac port.
+
+src/os_mint.8		Files for the Atari Mint port.
+
+src/os_os2*		Files for the OS/2 port.
+src/tee/*		Extra program for OS/2.
+
+src/os_vms*		Files for the VMS port.
+
+src/os_w32*
+src/os_win32.*		Files for the Win32 port.
+
+src/gui_w32.*		Files for the Win32 GUI.
+src/gui_w48.*		Files for the Win32 and Win16 GUI.
+src/Make_mvc.mak	MS Visual C++ makefile for the Win32 GUI.
+runtime/rgb.txt		File with color definitions for the Win32 GUI.
+
+src/if_ole.*		OLE automation interface, for MS Windows 95 and NT.
+
+src/VisVim/*		Integration of Win32 GUI with MS Visual Developer
+			Studio.
+
+src/GvimExt/*		DLL for the "Edit with Vim" context menu entry
+
+nsis/*			NSIS script to build the self-installing MS-Windows exe
+
+runtime/doc/*.man	Preprocessed manual pages.
+
+runtime/macros/file_select.vim	Vim script to browse directories (Unix only).
diff -urN vim-src/README_mac.txt vim-qt-src/README_mac.txt
--- vim-src/README_mac.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_mac.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,8 @@
+README_mac.txt for version 7.4 of Vim: Vi IMproved.
+
+This file explains the installation of Vim on Macintosh systems.
+See "README.txt" for general information about Vim.
+
+
+Sorry, this text still needs to be written!
+
diff -urN vim-src/README_ole.txt vim-qt-src/README_ole.txt
--- vim-src/README_ole.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_ole.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,20 @@
+README_ole.txt for version 7.4 of Vim: Vi IMproved.
+
+This archive contains gvim.exe with OLE interface and VisVim.
+This version of gvim.exe can also load a number of interface dynamically (you
+can optionally install the .dll files for each interface).
+It is only for MS-Windows 95/98/ME/NT/2000/XP.
+
+Also see the README_bindos.txt, README_dos.txt and README.txt files.
+
+Be careful not to overwrite the OLE gvim.exe with the non-OLE gvim.exe when
+unpacking another binary archive!  Check the output of ":version":
+	Win32s - "MS-Windows 16/32 bit GUI version"
+	 Win32 - "MS-Windows 32 bit GUI version"
+Win32 with OLE - "MS-Windows 32 bit GUI version with OLE support"
+
+For further information, type this inside Vim:
+	:help if_ole
+
+Furthermore, this archive contains VISVIM.DLL.  It can be used to integrate
+the OLE gvim with Microsoft Visual Developer Studio.  See VisVim/README.txt.
diff -urN vim-src/README_os2.txt vim-qt-src/README_os2.txt
--- vim-src/README_os2.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_os2.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,5 @@
+README_os2.txt for version 7.4 of Vim: Vi IMproved.
+
+This file used to explain the installation of Vim on OS/2 systems.
+However, support for OS/2 has been removed in patch 7.4.1008.
+See "README.txt" for general information about Vim.
diff -urN vim-src/README_os390.txt vim-qt-src/README_os390.txt
--- vim-src/README_os390.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_os390.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,117 @@
+README_zOS.txt for version 7.4 of Vim: Vi IMproved.
+
+This readme explains how to build Vim on z/OS.  Formerly called OS/390.
+See "README.txt" for general information about Vim.
+
+Most likely there are not many users out there using Vim on z/OS. So chances
+are good, that some bugs are still undiscovered.
+
+Getting the source to z/OS:
+==========================
+
+First get the source code in one big tar file and ftp it a binary to z/OS. If
+the tar file is initially compressed with gzip (tar.gz) or bzip2 (tar.bz2)
+uncompress it on your PC, as this tools are (most likely) not available on the
+mainframe.
+
+To reduce the size of the tar file you might compress it into a zip file. On
+z/OS Unix you might have the command "jar" from java to uncompress a zip. Use:
+        jar xvf <zip file name>
+
+Unpack the tar file on z/OS with 
+        pax -o from=ISO8859-1,to=IBM-1047 -rf vim.tar
+
+Note: The Vim source contains a few bitmaps etc which will be destroyed by
+this command, but these files are not needed on zOS (at least not for the
+console version).
+
+
+Compiling:
+==========
+
+Vim can be compiled with or without GUI support. For 7.4 only the compilation
+without GUI was tested. Below is a section about compiling with X11 but this
+is from an earlier version of Vim.
+
+Console only:
+-------------
+
+If you build VIM without X11 support, compiling and building is nearly
+straightforward. 
+
+Change to the vim directory and do:
+
+    # Don't use c89!
+    # Allow intermixing of compiler options and files.
+
+    $ export CC=cc
+    $ export _CC_CCMODE=1
+    $./configure --with-features=big --without-x --enable-gui=no
+    $ cd src
+    $ make
+
+      There may be warnings:
+        - include files not found (libc, sys/param.h, ...)
+        - Redeclaration of ... differs from ...
+        -- just ignore them.
+
+    $ make test
+
+      This will produce lots of garbage on your screen (including error
+      messages). Don't worry.
+
+      If the test stops at one point in vim (might happen in test 11), just
+      press :q!
+
+      Expected test failures:
+        11: If you don't have gzip installed
+        24: test of backslash sequences in regexp are ASCII dependent
+        42: Multibyte is not supported on z/OS
+        55: ASCII<->EBCDIC sorting
+        57: ASCII<->EBCDIC sorting
+        58: Spell checking is not supported with EBCDIC
+        71: Blowfish encryption doesn't work
+
+    $ make install
+
+
+With X11:
+---------
+
+WARNING: This instruction was not tested with Vim 7.4.
+
+There are two ways for building VIM with X11 support. The first way is simple
+and results in a big executable (~13 Mb), the second needs a few additional
+steps and results in a much smaller executable (~4.5 Mb). This examples assume
+you want Motif.
+
+  The easy way:
+    $ export CC=cc
+    $ export _CC_CCMODE=1
+    $ ./configure --enable-max-features --enable-gui=motif
+    $ cd src
+    $ make
+
+    With this VIM is linked statically with the X11 libraries.
+
+  The smarter way:
+    Make VIM as described above. Then create a file named 'link.sed' with the
+    following content (see src/link.390):
+
+	s/-lXext  *//g
+	s/-lXmu  *//g
+	s/-lXm	*/\/usr\/lib\/Xm.x /g
+	s/-lX11  */\/usr\/lib\/X11.x /g
+	s/-lXt	*//g
+	s/-lSM	*/\/usr\/lib\/SM.x /g
+	s/-lICE  */\/usr\/lib\/ICE.x /g
+
+    Then do:
+    $ rm vim
+    $ make
+
+    Now Vim is linked with the X11-DLLs.
+
+    See the Makefile and the file link.sh on how link.sed is used.
+
+
diff -urN vim-src/README_qt.txt vim-qt-src/README_qt.txt
--- vim-src/README_qt.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_qt.txt	2016-06-08 06:40:09.502636369 +0200
@@ -0,0 +1,136 @@
+`README.md` for version 7.4 of Vim: Vi IMproved.
+[![Build Status](https://travis-ci.org/vim/vim.svg?branch=master)](https://travis-ci.org/vim/vim)
+[![Coverage Status](https://coveralls.io/repos/vim/vim/badge.svg?branch=master&service=github)](https://coveralls.io/github/vim/vim?branch=master)
+[![Appveyor Build status](https://ci.appveyor.com/api/projects/status/o2qht2kjm02sgghk?svg=true)](https://ci.appveyor.com/project/chrisbra/vim)
+[![Coverity Scan](https://scan.coverity.com/projects/241/badge.svg)](https://scan.coverity.com/projects/vim)
+
+
+## What is Vim? ##
+
+Vim is a greatly improved version of the good old UNIX editor Vi.  Many new
+features have been added: multi-level undo, syntax highlighting, command line
+history, on-line help, spell checking, filename completion, block operations,
+script language, etc.  There is also a Graphical User Interface (GUI)
+available.  Still, Vi compatibility is maintained, those who have Vi "in the
+fingers" will feel at home.  See `runtime/doc/vi_diff.txt` for differences with
+Vi.
+
+This editor is very useful for editing programs and other plain text files.
+All commands are given with normal keyboard characters, so those who can type
+with ten fingers can work very fast.  Additionally, function keys can be
+mapped to commands by the user, and the mouse can be used.
+
+Vim runs under MS-Windows (NT, 2000, XP, Vista, 7, 8, 10), Macintosh, VMS and
+almost all flavours of UNIX.  Porting to other systems should not be very
+difficult.  Older versions of Vim run on MS-DOS, MS-Windows 95/98/Me, Amiga
+DOS, Atari MiNT, BeOS, RISC OS and OS/2.  These are no longer maintained.
+
+
+## Distribution ##
+
+You can often use your favorite package manager to install Vim.  On Mac and
+Linux a small version of Vim is pre-installed, you still need to install Vim
+if you want more features.
+
+There are separate distributions for Unix, PC, Amiga and some other systems.
+This `README.md` file comes with the runtime archive.  It includes the
+documentation, syntax files and other files that are used at runtime.  To run
+Vim you must get either one of the binary archives or a source archive.
+Which one you need depends on the system you want to run it on and whether you
+want or must compile it yourself.  Check http://www.vim.org/download.php for
+an overview of currently available distributions.
+
+Some popular places to get the latest Vim:
+* Check out the git repository from [github](https://github.com/vim/vim).
+* Get the source code as an [archive](https://github.com/vim/vim/releases).
+* Get a Windows executable from the
+[vim-win32-installer](https://github.com/vim/vim-win32-installer/releases) repository.
+
+
+
+## Compiling ##
+
+If you obtained a binary distribution you don't need to compile Vim.  If you
+obtained a source distribution, all the stuff for compiling Vim is in the
+`src` directory.  See `src/INSTALL` for instructions.
+
+
+## Installation ##
+
+See one of these files for system-specific instructions.  Either in the
+READMEdir directory (in the repository) or the top directory (if you unpack an
+archive):
+
+	README_ami.txt		Amiga
+	README_unix.txt		Unix
+	README_dos.txt		MS-DOS and MS-Windows
+	README_mac.txt		Macintosh
+	README_vms.txt		VMS
+
+There are other `README_*.txt` files, depending on the distribution you used.
+
+
+## Documentation ##
+
+The Vim tutor is a one hour training course for beginners.  Often it can be
+started as `vimtutor`.  See `:help tutor` for more information.
+
+The best is to use `:help` in Vim.  If you don't have an executable yet, read
+`runtime/doc/help.txt`.  It contains pointers to the other documentation
+files.  The User Manual reads like a book and is recommended to learn to use
+Vim.  See `:help user-manual`.
+
+
+## Copying ##
+
+Vim is Charityware.  You can use and copy it as much as you like, but you are
+encouraged to make a donation to help orphans in Uganda.  Please read the file
+`runtime/doc/uganda.txt` for details (do `:help uganda` inside Vim).
+
+Summary of the license: There are no restrictions on using or distributing an
+unmodified copy of Vim.  Parts of Vim may also be distributed, but the license
+text must always be included.  For modified versions a few restrictions apply.
+The license is GPL compatible, you may compile Vim with GPL libraries and
+distribute it.
+
+
+## Sponsoring ##
+
+Fixing bugs and adding new features takes a lot of time and effort.  To show
+your appreciation for the work and motivate Bram and others to continue
+working on Vim please send a donation.
+
+Since Bram is back to a paid job the money will now be used to help children
+in Uganda.  See `runtime/doc/uganda.txt`.  But at the same time donations
+increase Bram's motivation to keep working on Vim!
+
+For the most recent information about sponsoring look on the Vim web site:
+	http://www.vim.org/sponsor/
+
+
+## Contributing ##
+
+If you would like to help making Vim better, see the [CONTRIBUTING.md](https://github.com/vim/vim/blob/master/CONTRIBUTING.md) file.
+
+
+## Information ##
+
+The latest news about Vim can be found on the Vim home page:
+	http://www.vim.org/
+
+If you have problems, have a look at the Vim documentation or tips:
+	http://www.vim.org/docs.php
+	http://vim.wikia.com/wiki/Vim_Tips_Wiki
+
+If you still have problems or any other questions, use one of the mailing
+lists to discuss them with Vim users and developers:
+	http://www.vim.org/maillist.php
+
+If nothing else works, report bugs directly:
+	Bram Moolenaar <Bram@vim.org>
+
+
+## Main author ##
+
+Send any other comments, patches, flowers and suggestions to:
+	Bram Moolenaar <Bram@vim.org>
diff -urN vim-src/README_src.txt vim-qt-src/README_src.txt
--- vim-src/README_src.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_src.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,8 @@
+README_src.txt for version 7.4 of Vim: Vi IMproved.
+
+The source archive contains the files needed to compile Vim on Unix systems.
+It is packed for Unix systems (NL line separator).
+
+For more information, see the README.txt file that comes with the runtime
+archive (vim-7.4-rt.tar.gz).  To be able to run Vim you MUST get the runtime
+archive too!
diff -urN vim-src/README_srcdos.txt vim-qt-src/README_srcdos.txt
--- vim-src/README_srcdos.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_srcdos.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,12 @@
+README_srcdos.txt for version 7.4 of Vim: Vi IMproved.
+
+See "README.txt" for general information about Vim.
+See "README_dos.txt" for installation instructions for MS-DOS and MS-Windows.
+These files are in the runtime archive (vim74rt.zip).
+
+
+The DOS source archive contains the files needed to compile Vim on MS-DOS or
+MS-Windows.  It is packed for DOS systems, with CR-LF.  It also includes the
+VisVim sources.
+
+See "src/INSTALLpc.txt" for instructions on how to compile Vim on the PC.
diff -urN vim-src/README_unix.txt vim-qt-src/README_unix.txt
--- vim-src/README_unix.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_unix.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,10 @@
+README_unix.txt for version 7.4 of Vim: Vi IMproved.
+
+This file explains the installation of Vim on Unix systems.
+See "README.txt" for general information about Vim.
+
+
+When you use the source distribution, "make install" is used to install Vim.
+See the "INSTALL" file in the "src" directory.
+
+If you use a compiled package, follow the instructions for the package.
diff -urN vim-src/README_vms.txt vim-qt-src/README_vms.txt
--- vim-src/README_vms.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_vms.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,48 @@
+README_vms.txt for version 7.4 of Vim: Vi IMproved.
+
+This file explains the installation of Vim on VMS systems.
+See "README.txt" in the runtime archive for information about Vim.
+
+
+Most information can be found in the on-line documentation.  Use ":help vms"
+inside Vim.  Or get the runtime files and read runtime/doc/os_vms.txt to find
+out how to install and configure Vim with runtime files etc.
+
+To compile Vim yourself you need three archives:
+  vim-X.X-rt.tar.gz	runtime files
+  vim-X.X-src.tar.gz	source files
+  vim-X.X-extra.tar.gz	extra source files
+
+Compilation is recommended, in order to make sure that the correct
+libraries are used for your specific system.  Read about compiling in
+src/INSTALLvms.txt.
+
+To use the binary version, you need one of these archives:
+
+  vim-XX-exe-ia64-gui.zip       IA64 GUI/Motif executables
+  vim-XX-exe-ia64-gtk.zip       IA64 GUI/GTK executables
+  vim-XX-exe-ia64-term.zip      IA64 console executables
+  vim-XX-exe-axp-gui.zip	Alpha GUI/Motif executables
+  vim-XX-exe-axp-gtk.zip	Alpha GUI/GTK executables
+  vim-XX-exe-axp-term.zip       Alpha console executables
+  vim-XX-exe-vax-gui.zip	VAX GUI executables
+  vim-XX-exe-vax-term.zip       VAX console executables
+
+and of course
+  vim-XX-runtime.zip		runtime files
+
+The binary archives contain: vim.exe, ctags.exe, xxd.exe files,
+but there are also prepared "deploy ready" archives:
+
+vim-XX-ia64.zip			GUI and console executables with runtime and
+				help files for IA64 systems
+vim-XX-axp.zip			GUI and console executables with runtime and
+				help files for Alpha systems
+vim-XX-vax.zip			GUI and console executables with runtime and
+				help files for VAX systems
+
+GTK builds need LIBGTK library installed.
+
+These executables and up to date patches for OpenVMS system are downloadable
+from http://www.polarhome.com/vim/ or ftp://ftp.polarhome.com/pub/vim/
+
diff -urN vim-src/README_w32s.txt vim-qt-src/README_w32s.txt
--- vim-src/README_w32s.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_w32s.txt	2016-06-08 06:39:27.443313013 +0200
@@ -0,0 +1,15 @@
+README_w32s.txt for version 7.4 of Vim: Vi IMproved.
+
+This archive contains the gvim.exe that was specifically compiled for use in
+the Win32s subsystem in MS-Windows 3.1 and 3.11.
+
+Also see the README_bindos.txt, README_dos.txt and README.txt files.
+
+Be careful not to overwrite the Win32s gvim.exe with the another gvim.exe when
+unpacking another binary archive!  Check the output of ":version":
+	Win32s - "MS-Windows 16/32 bit GUI version"
+	 Win32 - "MS-Windows 32 bit GUI version"
+Win32 with OLE - "MS-Windows 32 bit GUI version with OLE support"
+
+For further information, type this inside Vim:
+	:help win32s
Binary files vim-src/Vim.info and vim-qt-src/Vim.info differ
Binary files vim-src/Xxd.info and vim-qt-src/Xxd.info differ
Binary files vim-src/csdpmi4b.zip and vim-qt-src/csdpmi4b.zip differ
Binary files vim-src/libs/arp.library and vim-qt-src/libs/arp.library differ
diff -urN vim-src/runtime/doc/gui_w16.txt vim-qt-src/runtime/doc/gui_w16.txt
--- vim-src/runtime/doc/gui_w16.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/runtime/doc/gui_w16.txt	2016-06-08 06:39:27.492313390 +0200
@@ -0,0 +1,186 @@
+*gui_w16.txt*   For Vim version 7.4.  Last change: 2005 Mar 29
+
+
+		  VIM REFERENCE MANUAL    by Bram Moolenaar
+
+
+Vim's Graphical User Interface				*gui-w16* *win16-gui*
+
+1. Starting the GUI		|win16-start|
+2. Vim as default editor	|win16-default-editor|
+3. Using the clipboard		|win16-clipboard|
+4. Shell Commands		|win16-shell|
+5. Special colors		|win16-colors|
+6. Windows dialogs & browsers	|win16-dialogs|
+7. Various			|win16-various|
+
+Other relevant documentation:
+|gui.txt|	For generic items of the GUI.
+|os_msdos.txt|	For items common to DOS and Windows.
+|gui_w32.txt|	Some items here are also applicable to the Win16 version.
+
+{Vi does not have a Windows GUI}
+
+The Win16 version of Vim will run on Windows 3.1 or later.  It has not been
+tested on 3.0, it probably won't work without being recompiled and
+modified.  (But you really should upgrade to 3.11 anyway. :)
+
+In most respects it behaves identically to the Win32 GUI version, including
+having a flat-style toolbar(!).  The chief differences:
+
+1) Bold/Italic text is not available, to speed up repaint/reduce resource
+   usage.  (You can re-instate this by undefining MSWIN16_FASTTEXT.)
+2) No tearoff menu emulation.
+3) No OLE interface.
+4) No long filename support (of course).
+5) No tooltips on toolbar buttons - instead they produce command-line tips
+   like menu items do.
+6) Line length limited to 32767 characters (like 16-bit DOS version).
+
+
+==============================================================================
+1. Starting the GUI					*win16-start*
+
+The Win16 GUI version of Vim will always start the GUI, no matter how you
+start it or what it's called.  There is no 'console' version as such, but you
+can use one of the DOS versions in a DOS box.
+
+The Win16 GUI has an extra menu item:  "Window/Select Font".  It brings up the
+standard Windows font selector.  Note that bold and italic fonts are not
+supported in an attempt to maximize GDI drawing speed.
+
+Setting the menu height doesn't work for the Win16 GUI.
+
+							*win16-maximized*
+If you want Vim to start with a maximized window, add this command to your
+vimrc or gvimrc file: >
+	au GUIEnter * simalt ~x
+<
+
+There is a specific version of gvim.exe that runs under the Win32s subsystem
+of Windows 3.1 or 3.11.  See |win32s|.
+
+==============================================================================
+2. Vim as default editor				*win16-default-editor*
+
+To set Vim as the default editor for a file type you can use File Manager's
+"Associate" feature.
+
+When you open a file in Vim by double clicking it, Vim changes to that
+file's directory.
+
+See also |notepad|.
+
+==============================================================================
+3. Using the clipboard					*win16-clipboard*
+
+Windows has a clipboard, where you can copy text to, and paste text from.  Vim
+supports this in several ways.
+The clipboard works in the same way as the Win32 version: see |gui-clipboard|.
+
+==============================================================================
+4. Shell Commands					*win16-shell*
+
+Vim spawns a DOS window for external commands, to make it possible to run any
+DOS command.  The window uses the _default.pif settings.
+
+							*win16-!start*
+Normally, Vim waits for a command to complete before continuing (this makes
+sense for most shell commands which produce output for Vim to use).  If you
+want Vim to start a program and return immediately, you can use the following
+syntax:
+	:!start {command}
+This may only work for a Windows program though.
+Don't forget that you must tell Windows 3.1x to keep executing a DOS command
+in the background while you switch back to Vim.
+
+==============================================================================
+5. Special colors					*win16-colors*
+
+On Win16, the normal DOS colors can be used.  See |dos-colors|.
+
+Additionally the system configured colors can also be used.  These are known
+by the names Sys_XXX, where XXX is the appropriate system color name, from the
+following list (see the Win32 documentation for full descriptions).  Case is
+ignored.
+
+Sys_BTNFace		Sys_BTNShadow			Sys_ActiveBorder
+Sys_ActiveCaption	Sys_AppWorkspace		Sys_Background
+Sys_BTNText		Sys_CaptionText			Sys_GrayText
+Sys_Highlight		Sys_HighlightText		Sys_InactiveBorder
+Sys_InactiveCaption	Sys_InactiveCaptionText		Sys_Menu
+Sys_MenuText		Sys_ScrollBar			Sys_Window
+Sys_WindowFrame		Sys_WindowText
+
+Probably the most useful values are
+	Sys_Window	    Normal window background
+	Sys_WindowText      Normal window text
+	Sys_Highlight       Highlighted background
+	Sys_HighlightText   Highlighted text
+
+These extra colors are also available:
+Gray, Grey, LightYellow, SeaGreen, Orange, Purple, SlateBlue, Violet,
+
+
+See also |rgb.txt|.
+
+==============================================================================
+						*win16-dialogs*
+6. Windows dialogs & browsers
+
+The Win16 GUI can use familiar Windows components for some operations, as well
+as the traditional interface shared with the console version.
+
+
+6.1 Dialogs
+
+The dialogs displayed by the "confirm" family (i.e. the 'confirm' option,
+|:confirm| command and |confirm()| function) are GUI-based rather than the
+console-based ones used by other versions.  There is no option to change this.
+
+
+6.2 File Browsers
+
+When prepending ":browse" before file editing commands, a file requester is
+used to allow you to select an existing file.  See |:browse|.
+
+
+==============================================================================
+7. Various						*win16-various*
+
+							*win16-printing*
+The "File/Print" menu uses Notepad to print the current buffer.  This is a bit
+clumsy, but it's portable.  If you want something else, you can define your
+own print command.  For example, you could look for the 16-bit version of
+PrintFile.  See $VIMRUNTIME/menu.vim for how it works by default.
+
+Using this should also work: >
+	:w >>prn
+
+Vim supports a number of standard MS Windows features.  Some of these are
+detailed elsewhere: see |'mouse'|, |win32-hidden-menus|.
+Also see |:simalt|
+
+							*win16-drag-n-drop*
+You can drag and drop one or more files into the vim window, where they will
+be opened as normal.  If you hold down Shift while doing this, Vim changes to
+the (first) dropped file's directory.  If you hold Ctrl, Vim will always split
+a new window for the file.  Otherwise it's only done if the current buffer has
+been changed.
+You can also drop a directory's icon, but rather than open all files in the
+directory (which wouldn't usually be what you want) Vim instead changes to
+that directory and begins a new file.
+If Vim happens to be editing a command line, the names of the dropped files
+and directories will be inserted at the cursor.  This allows you to use these
+names with any Ex command.
+
+							*win16-truetype*
+It is recommended that you use a raster font and not a TrueType
+fixed-pitch font.  E.g. use Courier, not Courier New.  This is not just
+to use less resources but because there are subtle bugs in the
+handling of fixed-pitch TrueType in Win3.1x.  In particular, when you move
+a block cursor over a pipe character '|', the cursor is drawn in the wrong
+size and bits get left behind.  This is a bug in the Win3.1x GDI, it doesn't
+happen if you run the exe under 95/NT.
+
+ vim:tw=78:sw=4:ts=8:ft=help:norl:
diff -urN vim-src/runtime/macros/dvorak vim-qt-src/runtime/macros/dvorak
--- vim-src/runtime/macros/dvorak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/runtime/macros/dvorak	2016-06-08 06:39:27.568313974 +0200
@@ -0,0 +1,164 @@
+When using a dvorak keyboard this file may be of help to you.
+These mappings have been made by Lawrence Kesteloot <kesteloo@cs.unc.edu>.
+What they do is that the most often used keys, like hjkl, are put in a more
+easy to use position.
+It may take some time to learn using this.
+
+Put these lines in your .vimrc:
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+" Key to go into dvorak mode:
+map ,d :source ~/.dvorak
+" Key to get out of dvorak mode:
+map ,q :source ~/.qwerty
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+
+write these lines into the file ~/.dvorak:
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+" Dvorak keyboard, only in insert mode and ex mode.
+" You may want to add a list of map's too.
+imap! a a
+imap! b x
+imap! c j
+imap! d e
+imap! e .
+imap! f u
+imap! g i
+imap! h d
+imap! i c
+imap! j h
+imap! k t
+imap! l n
+imap! m m
+imap! n b
+imap! o r
+imap! p l
+imap! q '
+imap! r p
+imap! s o
+imap! t y
+imap! u g
+imap! v k
+imap! w ,
+imap! x q
+imap! y f
+imap! z ;
+imap! ; s
+imap! ' -
+imap! " _
+imap! , w
+imap! . v
+imap! / z
+imap! A A
+imap! B X
+imap! C J
+imap! D E
+imap! E >
+imap! F U
+imap! G I
+imap! H D
+imap! I C
+imap! J H
+imap! K T
+imap! L N
+imap! M M
+imap! N B
+imap! O R
+imap! P L
+imap! Q "
+imap! R P
+imap! S O
+imap! T Y
+imap! U G
+imap! V K
+imap! W <
+imap! X Q
+imap! Y F
+imap! Z :
+imap! < W
+imap! > V
+imap! ? Z
+imap! : S
+imap! [ /
+imap! ] =
+imap! { ?
+imap! } +
+imap! - [
+imap! _ {
+imap! = ]
+imap! + }
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+
+write these lines into the file ~/.qwerty
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+" Qwerty keyboard
+unmap! a
+unmap! b
+unmap! c
+unmap! d
+unmap! e
+unmap! f
+unmap! g
+unmap! h
+unmap! i
+unmap! j
+unmap! k
+unmap! l
+unmap! m
+unmap! n
+unmap! o
+unmap! p
+unmap! q
+unmap! r
+unmap! s
+unmap! t
+unmap! u
+unmap! v
+unmap! w
+unmap! x
+unmap! y
+unmap! z
+unmap! ;
+unmap! '
+unmap! \"
+unmap! ,
+unmap! .
+unmap! /
+unmap! A
+unmap! B
+unmap! C
+unmap! D
+unmap! E
+unmap! F
+unmap! G
+unmap! H
+unmap! I
+unmap! J
+unmap! K
+unmap! L
+unmap! M
+unmap! N
+unmap! O
+unmap! P
+unmap! Q
+unmap! R
+unmap! S
+unmap! T
+unmap! U
+unmap! V
+unmap! W
+unmap! X
+unmap! Y
+unmap! Z
+unmap! <
+unmap! >
+unmap! ?
+unmap! :
+unmap! [
+unmap! ]
+unmap! {
+unmap! }
+unmap! -
+unmap! _
+unmap! =
+unmap! +
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
diff -urN vim-src/runtime/macros/matchit.txt vim-qt-src/runtime/macros/matchit.txt
--- vim-src/runtime/macros/matchit.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/runtime/macros/matchit.txt	2016-06-08 06:39:27.569313981 +0200
@@ -0,0 +1,406 @@
+*matchit.txt*   Extended "%" matching
+
+For instructions on installing this file, type
+	:help matchit-install
+inside Vim.
+
+For Vim version 6.3.  Last change:  2007 Aug 29
+
+
+		  VIM REFERENCE MANUAL    by Benji Fisher
+
+*matchit* *matchit.vim*
+
+1. Extended matching with "%"				|matchit-intro|
+2. Activation						|matchit-activate|
+3. Configuration					|matchit-configure|
+4. Supporting a New Language				|matchit-newlang|
+5. Known Bugs and Limitations				|matchit-bugs|
+
+The functionality mentioned here is a plugin, see |add-plugin|.
+This plugin is only available if 'compatible' is not set.
+You can avoid loading this plugin by setting the "loaded_matchit" variable
+in your |vimrc| file: >
+	:let loaded_matchit = 1
+
+{Vi does not have any of this}
+
+==============================================================================
+1. Extended matching with "%"				*matchit-intro*
+
+							*matchit-%*
+%	Cycle forward through matching groups, such as "if", "else", "endif",
+	as specified by |b:match_words|.
+
+							*g%* *v_g%* *o_g%*
+g%	Cycle backwards through matching groups, as specified by
+	|b:match_words|.  For example, go from "if" to "endif" to "else".
+
+							*[%* *v_[%* *o_[%*
+[%	Go to [count] previous unmatched group, as specified by
+	|b:match_words|.  Similar to |[{|.
+
+							*]%* *v_]%* *o_]%*
+]%	Go to [count] next unmatched group, as specified by
+	|b:match_words|.  Similar to |]}|.
+
+							*v_a%*
+a%	In Visual mode, select the matching group, as specified by
+	|b:match_words|, containing the cursor.  Similar to |v_a[|.
+	A [count] is ignored, and only the first character of the closing
+	pattern is selected.
+
+In Vim, as in plain vi, the percent key, |%|, jumps the cursor from a brace,
+bracket, or paren to its match.  This can be configured with the 'matchpairs'
+option.  The matchit plugin extends this in several ways:
+
+	    You can match whole words, such as "if" and "endif", not just
+	single characters.  You can also specify a |regular-expression|.
+	    You can define groups with more than two words, such as "if",
+	"else", "endif".  Banging on the "%" key will cycle from the "if" to
+	the first "else", the next "else", ..., the closing "endif", and back
+	to the opening "if".  Nested structures are skipped.  Using |g%| goes
+	in the reverse direction.
+	    By default, words inside comments and strings are ignored, unless
+	the cursor is inside a comment or string when you type "%".  If the
+	only thing you want to do is modify the behavior of "%" so that it
+	behaves this way, you do not have to define |b:match_words|, since the
+	script uses the 'matchpairs' option as well as this variable.
+
+See |matchit-details| for details on what the script does, and |b:match_words|
+for how to specify matching patterns.
+
+MODES:			*matchit-modes* *matchit-v_%* *matchit-o_%*
+
+Mostly, % and related motions (|g%| and |[%| and |]%|) work just like built-in
+|motion| commands in |Operator-pending| and |Visual| modes.  However, you
+cannot make these motions |linewise| or |characterwise|, since the |:omap|s
+that define them start with "v" in order to make the default behavior
+inclusive.  (See |o_v|.)  In other words, "dV%" will not work.  The
+work-around is to go through Visual mode:  "V%d" will work.
+
+LANGUAGES:					*matchit-languages*
+
+Currently, the following languages are supported:  Ada, ASP with VBS, Csh,
+DTD, Entity, Essbase, Fortran, HTML, JSP (same as HTML), LaTeX, Lua, Pascal,
+SGML, Shell, Tcsh, Vim, XML.  Other languages may already have support via
+the default |filetype-plugin|s in the standard vim distribution.
+
+To support a new language, see |matchit-newlang| below.
+
+DETAILS:				*matchit-details* *matchit-parse*
+
+Here is an outline of what matchit.vim does each time you hit the "%" key.  If
+there are |backref|s in |b:match_words| then the first step is to produce a
+version in which these back references have been eliminated; if there are no
+|backref|s then this step is skipped.  This step is called parsing.  For
+example, "\(foo\|bar\):end\1" is parsed to yield
+"\(foo\|bar\):end\(foo\|bar\)".  This can get tricky, especially if there are
+nested groups.  If debugging is turned on, the parsed version is saved as
+|b:match_pat|.
+
+							*matchit-choose*
+Next, the script looks for a word on the current line that matches the pattern
+just constructed.  It includes the patterns from the 'matchpairs' option.
+The goal is to do what you expect, which turns out to be a little complicated.
+The script follows these rules:
+
+	Insist on a match that ends on or after the cursor.
+	Prefer a match that includes the cursor position (that is, one that
+		starts on or before the cursor).
+	Prefer a match that starts as close to the cursor as possible.
+	If more than one pattern in |b:match_words| matches, choose the one
+		that is listed first.
+
+Examples:
+
+	Suppose you >
+		:let b:match_words = '<:>,<tag>:</tag>'
+<	and hit "%" with the cursor on or before the "<" in "a <tag> is born".
+	The pattern '<' comes first, so it is preferred over '<tag>', which
+	also matches.  If the cursor is on the "t", however, then '<tag>' is
+	preferred, because this matches a bit of text containing the cursor.
+	If the two groups of patterns were reversed then '<' would never be
+	preferred.
+
+	Suppose you >
+		:let b:match_words = 'if:end if'
+<	(Note the space!) and hit "%" with the cursor at the end of "end if".
+	Then "if" matches, which is probably not what you want, but if the
+	cursor starts on the "end " then "end if" is chosen.  (You can avoid
+	this problem by using a more complicated pattern.)
+
+If there is no match, the cursor does not move.  (Before version 1.13 of the
+script, it would fall back on the usual behavior of |%|).  If debugging is
+turned on, the matched bit of text is saved as |b:match_match| and the cursor
+column of the start of the match is saved as |b:match_col|.
+
+Next, the script looks through |b:match_words| (original and parsed versions)
+for the group and pattern that match.  If debugging is turned on, the group is
+saved as |b:match_ini| (the first pattern) and |b:match_tail| (the rest).  If
+there are |backref|s then, in addition, the matching pattern is saved as
+|b:match_word| and a table of translations is saved as |b:match_table|.  If
+there are |backref|s, these are determined from the matching pattern and
+|b:match_match| and substituted into each pattern in the matching group.
+
+The script decides whether to search forwards or backwards and chooses
+arguments for the |searchpair()| function.  Then, the cursor is moved to the
+start of the match, and |searchpair()| is called.  By default, matching
+structures inside strings and comments are ignored.  This can be changed by
+setting |b:match_skip|.
+
+==============================================================================
+2. Activation						*matchit-activate*
+
+You can use this script as a plugin, by copying it to your plugin directory.
+See |add-global-plugin| for instructions.  You can also add a line to your
+|vimrc| file, such as >
+	:source $VIMRUNTIME/macros/matchit.vim
+or >
+	:runtime macros/matchit.vim
+Either way, the script should start working the next time you start up Vim.
+
+(Earlier versions of the script did nothing unless a |buffer-variable| named
+|b:match_words| was defined.  Even earlier versions contained autocommands
+that set this variable for various file types.  Now, |b:match_words| is
+defined in many of the default |filetype-plugin|s instead.)
+
+For a new language, you can add autocommands to the script or to your vimrc
+file, but the recommended method is to add a line such as >
+	let b:match_words = '\<foo\>:\<bar\>'
+to the |filetype-plugin| for your language.  See |b:match_words| below for how
+this variable is interpreted.
+
+TROUBLESHOOTING					*matchit-troubleshoot*
+
+The script should work in most installations of Vim.  It may not work if Vim
+was compiled with a minimal feature set, for example if the |+syntax| option
+was not enabled.  If your Vim has support for syntax compiled in, but you do
+not have |syntax| highlighting turned on, matchit.vim should work, but it may
+fail to skip matching groups in comments and strings.  If the |filetype|
+mechanism is turned off, the |b:match_words| variable will probably not be
+defined automatically.
+
+==============================================================================
+3. Configuration					*matchit-configure*
+
+There are several variables that govern the behavior of matchit.vim.  Note
+that these are variables local to the buffer, not options, so use |:let| to
+define them, not |:set|.  Some of these variables have values that matter; for
+others, it only matters whether the variable has been defined.  All of these
+can be defined in the |filetype-plugin| or autocommand that defines
+|b:match_words| or "on the fly."
+
+The main variable is |b:match_words|.  It is described in the section below on
+supporting a new language.
+
+				*MatchError* *matchit-hl* *matchit-highlight*
+MatchError is the highlight group for error messages from the script.  By
+default, it is linked to WarningMsg.  If you do not want to be bothered by
+error messages, you can define this to be something invisible.  For example,
+if you use the GUI version of Vim and your command line is normally white, you
+can do >
+	:hi MatchError guifg=white guibg=white
+<
+						*b:match_ignorecase*
+If you >
+	:let b:match_ignorecase = 1
+then matchit.vim acts as if 'ignorecase' is set: for example, "end" and "END"
+are equivalent.  If you >
+	:let b:match_ignorecase = 0
+then matchit.vim treats "end" and "END" differently.  (There will be no
+b:match_infercase option unless someone requests it.)
+
+						*b:match_debug*
+Define b:match_debug if you want debugging information to be saved.  See
+|matchit-debug|, below.
+
+						*b:match_skip*
+If b:match_skip is defined, it is passed as the skip argument to
+|searchpair()|.  This controls when matching structures are skipped, or
+ignored.  By default, they are ignored inside comments and strings, as
+determined by the |syntax| mechanism.  (If syntax highlighting is turned off,
+nothing is skipped.)  You can set b:match_skip to a string, which evaluates to
+a non-zero, numerical value if the match is to be skipped or zero if the match
+should not be skipped.  In addition, the following special values are
+supported by matchit.vim:
+	s:foo becomes (current syntax item) =~ foo
+	S:foo becomes (current syntax item) !~ foo
+	r:foo becomes (line before cursor) =~ foo
+	R:foo becomes (line before cursor) !~ foo
+(The "s" is meant to suggest "syntax", and the "r" is meant to suggest
+"regular expression".)
+
+Examples:
+
+	You can get the default behavior with >
+		:let b:match_skip = 's:comment\|string'
+<
+	If you want to skip matching structures unless they are at the start
+	of the line (ignoring whitespace) then you can >
+		:let b:match_skip = 'R:^\s*'
+<	Do not do this if strings or comments can span several lines, since
+	the normal syntax checking will not be done if you set b:match_skip.
+
+	In LaTeX, since "%" is used as the comment character, you can >
+		:let b:match_skip = 'r:%'
+<	Unfortunately, this will skip anything after "\%", an escaped "%".  To
+	allow for this, and also "\\%" (an excaped backslash followed by the
+	comment character) you can >
+		:let b:match_skip = 'r:\(^\|[^\\]\)\(\\\\\)*%'
+<
+	See the $VIMRUNTIME/ftplugin/vim.vim for an example that uses both
+	syntax and a regular expression.
+
+==============================================================================
+4. Supporting a New Language				*matchit-newlang*
+							*b:match_words*
+In order for matchit.vim to support a new language, you must define a suitable
+pattern for |b:match_words|.  You may also want to set some of the
+|matchit-configure| variables, as described above.  If your language has a
+complicated syntax, or many keywords, you will need to know something about
+Vim's |regular-expression|s.
+
+The format for |b:match_words| is similar to that of the 'matchpairs' option:
+it is a comma (,)-separated list of groups; each group is a colon(:)-separated
+list of patterns (regular expressions).  Commas and backslashes that are part
+of a pattern should be escaped with backslashes ('\:' and '\,').  It is OK to
+have only one group; the effect is undefined if a group has only one pattern.
+A simple example is >
+	:let b:match_words = '\<if\>:\<endif\>,'
+		\ . '\<while\>:\<continue\>:\<break\>:\<endwhile\>'
+(In Vim regular expressions, |\<| and |\>| denote word boundaries.  Thus "if"
+matches the end of "endif" but "\<if\>" does not.)  Then banging on the "%"
+key will bounce the cursor between "if" and the matching "endif"; and from
+"while" to any matching "continue" or "break", then to the matching "endwhile"
+and back to the "while".  It is almost always easier to use |literal-string|s
+(single quotes) as above:  '\<if\>' rather than "\\<if\\>" and so on.
+
+Exception:  If the ":" character does not appear in b:match_words, then it is
+treated as an expression to be evaluated.  For example, >
+	:let b:match_words = 'GetMatchWords()'
+allows you to define a function.  This can return a different string depending
+on the current syntax, for example.
+
+Once you have defined the appropriate value of |b:match_words|, you will
+probably want to have this set automatically each time you edit the
+appropriate file type.  The recommended way to do this is by adding the
+definition to a |filetype-plugin| file.
+
+Tips: Be careful that your initial pattern does not match your final pattern.
+See the example above for the use of word-boundary expressions.  It is usually
+better to use ".\{-}" (as many as necessary) instead of ".*" (as many as
+possible).  See |\{-|.  For example, in the string "<tag>label</tag>", "<.*>"
+matches the whole string whereas "<.\{-}>" and "<[^>]*>" match "<tag>" and
+"</tag>".
+
+				*matchit-spaces* *matchit-s:notend*
+If "if" is to be paired with "end if" (Note the space!) then word boundaries
+are not enough.  Instead, define a regular expression s:notend that will match
+anything but "end" and use it as follows: >
+	:let s:notend = '\%(\<end\s\+\)\@<!'
+	:let b:match_words = s:notend . '\<if\>:\<end\s\+if\>'
+<							*matchit-s:sol*
+This is a simplified version of what is done for Ada.  The s:notend is a
+|script-variable|.  Similarly, you may want to define a start-of-line regular
+expression >
+	:let s:sol = '\%(^\|;\)\s*'
+if keywords are only recognized after the start of a line or after a
+semicolon (;), with optional white space.
+
+					*matchit-backref* *matchit-\1*
+In any group, the expressions |\1|, |\2|, ..., |\9| refer to parts of the
+INITIAL pattern enclosed in |\(|escaped parentheses|\)|.  These are referred
+to as back references, or backrefs.  For example, >
+	:let b:match_words = '\<b\(o\+\)\>:\(h\)\1\>'
+means that "bo" pairs with "ho" and "boo" pairs with "hoo" and so on.  Note
+that "\1" does not refer to the "\(h\)" in this example.  If you have
+"\(nested \(parentheses\)\) then "\d" refers to the d-th "\(" and everything
+up to and including the matching "\)":  in "\(nested\(parentheses\)\)", "\1"
+refers to everything and "\2" refers to "\(parentheses\)".  If you use a
+variable such as |s:notend| or |s:sol| in the previous paragraph then remember
+to count any "\(" patterns in this variable.  You do not have to count groups
+defined by |\%(\)|.
+
+It should be possible to resolve back references from any pattern in the
+group.  For example, >
+	:let b:match_words = '\(foo\)\(bar\):more\1:and\2:end\1\2'
+would not work because "\2" cannot be determined from "morefoo" and "\1"
+cannot be determined from "andbar".  On the other hand, >
+	:let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
+should work (and have the same effect as "foobar:barfoo:endfoobar"), although
+this has not been thoroughly tested.
+
+You can use |zero-width| patterns such as |\@<=| and |\zs|.  (The latter has
+not been thouroughly tested in matchit.vim.)  For example, if the keyword "if"
+must occur at the start of the line, with optional white space, you might use
+the pattern "\(^\s*\)\@<=if" so that the cursor will end on the "i" instead of
+at the start of the line.  For another example, if HTML had only one tag then
+one could >
+	:let b:match_words = '<:>,<\@<=tag>:<\@<=/tag>'
+so that "%" can bounce between matching "<" and ">" pairs or (starting on
+"tag" or "/tag") between matching tags.  Without the |\@<=|, the script would
+bounce from "tag" to the "<" in "</tag>", and another "%" would not take you
+back to where you started.
+
+DEBUGGING				*matchit-debug* *:MatchDebug*
+
+If you are having trouble figuring out the appropriate definition of
+|b:match_words| then you can take advantage of the same information I use when
+debugging the script.  This is especially true if you are not sure whether
+your patterns or my script are at fault!  To make this more convenient, I have
+made the command :MatchDebug, which defines the variable |b:match_debug| and
+creates a Matchit menu.  This menu makes it convenient to check the values of
+the variables described below.  You will probably also want to read
+|matchit-details| above.
+
+Defining the variable |b:match_debug| causes the script to set the following
+variables, each time you hit the "%" key.  Several of these are only defined
+if |b:match_words| includes |backref|s.
+
+							*b:match_pat*
+The b:match_pat variable is set to |b:match_words| with |backref|s parsed.
+							*b:match_match*
+The b:match_match variable is set to the bit of text that is recognized as a
+match.
+							*b:match_col*
+The b:match_col variable is set to the cursor column of the start of the
+matching text.
+							*b:match_wholeBR*
+The b:match_wholeBR variable is set to the comma-separated group of patterns
+that matches, with |backref|s unparsed.
+							*b:match_iniBR*
+The b:match_iniBR variable is set to the first pattern in |b:match_wholeBR|.
+							*b:match_ini*
+The b:match_ini variable is set to the first pattern in |b:match_wholeBR|,
+with |backref|s resolved from |b:match_match|.
+							*b:match_tail*
+The b:match_tail variable is set to the remaining patterns in
+|b:match_wholeBR|, with |backref|s resolved from |b:match_match|.
+							*b:match_word*
+The b:match_word variable is set to the pattern from |b:match_wholeBR| that
+matches |b:match_match|.
+							*b:match_table*
+The back reference '\'.d refers to the same thing as '\'.b:match_table[d] in
+|b:match_word|.
+
+==============================================================================
+5. Known Bugs and Limitations				*matchit-bugs*
+
+Just because I know about a bug does not mean that it is on my todo list.  I
+try to respond to reports of bugs that cause real problems.  If it does not
+cause serious problems, or if there is a work-around, a bug may sit there for
+a while.  Moral:  if a bug (known or not) bothers you, let me know.
+
+The various |:vmap|s defined in the script (%, |g%|, |[%|, |]%|, |a%|) may
+have undesired effects in Select mode |Select-mode-mapping|.  At least, if you
+want to replace the selection with any character in "ag%[]" there will be a
+pause of |'updatetime'| first.
+
+It would be nice if "\0" were recognized as the entire pattern.  That is, it
+would be nice if "foo:\end\0" had the same effect as "\(foo\):\end\1".  I may
+try to implement this in a future version.  (This is not so easy to arrange as
+you might think!)
+
+==============================================================================
+vim:tw=78:fo=tcq2:
diff -urN vim-src/runtime/menu.vim vim-qt-src/runtime/menu.vim
--- vim-src/runtime/menu.vim	2016-01-21 17:44:00.201173720 +0100
+++ vim-qt-src/runtime/menu.vim	2016-06-08 06:39:27.570313989 +0200
@@ -383,7 +383,7 @@
   endif
   unlet s:n
 endif
-if has("win32") || has("win16") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac")
+if has("win32") || has("win16") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac") || has("gui_qt")
   an 20.470 &Edit.Select\ Fo&nt\.\.\.	:set guifont=*<CR>
 endif
 
Binary files vim-src/runtime.info and vim-qt-src/runtime.info differ
diff -urN vim-src/src/CMakeLists.txt vim-qt-src/src/CMakeLists.txt
--- vim-src/src/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/CMakeLists.txt	2016-06-08 06:39:27.685314873 +0200
@@ -0,0 +1,123 @@
+cmake_minimum_required(VERSION 2.8)
+
+find_package(Qt4 REQUIRED)
+set( QT_USE_QTGUI TRUE )
+include(${QT_USE_FILE} )
+
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+include_directories(proto auto . qt)
+
+# pathdef
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/pathdef.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/auto/pathdef.c)
+
+#
+# Vim executable
+#
+
+set(VIM_SOURCES buffer.c 
+		blowfish.c 
+		charset.c 
+		diff.c 
+		digraph.c 
+		edit.c 
+		eval.c 
+		ex_cmds.c 
+		ex_cmds2.c 
+		ex_docmd.c 
+		ex_eval.c 
+		ex_getln.c 
+		fileio.c 
+		fold.c 
+		getchar.c 
+		hardcopy.c 
+		hashtab.c 
+		if_cscope.c 
+		if_xcmdsrv.c 
+		main.c 
+		mark.c 
+		memfile.c 
+		memline.c 
+		menu.c 
+		message.c 
+		misc1.c 
+		misc2.c 
+		move.c 
+		mbyte.c 
+		normal.c 
+		ops.c 
+		option.c 
+		popupmnu.c 
+		quickfix.c 
+		regexp.c 
+		screen.c 
+		search.c 
+		sha256.c 
+		spell.c 
+		syntax.c 
+		tag.c 
+		term.c 
+		ui.c 
+		undo.c 
+		window.c 
+		gui.c 
+		netbeans.c 
+		version.c 
+		auto/pathdef.c)
+
+set(GUI_SOURCES gui_qt.cpp )
+set(MOC_SOURCES qt/qvimshell.cpp 
+		qt/mainwindow.cpp 
+		qt/vimaction.cpp 
+		qt/tabbar.cpp 
+		qt/vimaction.cpp 
+		qt/vimscrollbar.cpp 
+		qt/vimwrapper.cpp 
+		qt/fontdialog.cpp
+		qt/colortable.cpp
+		qt/vimevents.cpp
+		qt/scrollarea.cpp)
+
+set(QVIM_RCS qt/icons.qrc)
+QT4_ADD_RESOURCES( QVIM_RC_SRCS ${QVIM_RCS} )
+
+qt4_automoc(${MOC_SOURCES})
+
+
+if(MSVC OR MINGW)
+
+	set(VIM_SOURCES ${VIM_SOURCES} 
+			os_win32.c 
+			winclip.c
+			os_mswin.c)
+
+	add_definitions(-DWIN32
+			-DNO_X11_INCLUDES
+			-DFEAT_GUI_QT
+			-UHAVE_X11
+			-DFEAT_HUGE
+			-DFEAT_MBYTE
+			-UFEAT_SIGN
+			-D__func__=__FUNCTION__
+			-D_CRT_SECURE_NO_WARNINGS)
+
+	if (MSVC)
+		add_definitions(-wd4099)
+	endif (MSVC)
+
+	set(SOURCES ${VIM_SOURCES} ${GUI_SOURCES} ${MOC_SOURCES} ${QVIM_RC_SRCS})
+
+	if ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+		message("Building Debug version")
+		add_executable(qvim ${SOURCES})
+	else ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+		add_executable(qvim WIN32 ${SOURCES})
+	endif ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+
+	target_link_libraries(qvim ${QT_QTMAIN_LIBRARY} # Link to qtmain.lib to avoid WinMain()
+				   ${QT_LIBRARIES} )	# Link to Qt
+else(MSVC OR MINGW)
+	message(FATAL_ERROR "Could not find Visual Studio or Mingw - are they on the path? This is Windows, right?")
+endif(MSVC OR MINGW)
+
+
diff -urN vim-src/src/GvimExt/Make_cyg.mak vim-qt-src/src/GvimExt/Make_cyg.mak
--- vim-src/src/GvimExt/Make_cyg.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/GvimExt/Make_cyg.mak	2016-06-08 06:39:27.685314873 +0200
@@ -0,0 +1,77 @@
+# Project: gvimext
+# Generates gvimext.dll with gcc.
+# To be used with Cygwin.
+#
+# Originally, the DLL base address was fixed: -Wl,--image-base=0x1C000000
+# Now it is allocated dymanically by the linker by evaluating all DLLs
+# already loaded in memory. The binary image contains as well information
+# for automatic pseudo-rebasing, if needed by the system. ALV 2004-02-29
+
+# If cross-compiling set this to yes, else set it to no
+CROSS = no
+#CROSS = yes
+# For the old MinGW 2.95 (the one you get e.g. with debian woody)
+# set the following variable to yes and check if the executables are
+# really named that way.
+# If you have a newer MinGW or you are using cygwin set it to no and
+# check also the executables
+MINGWOLD = no
+
+# Link against the shared versions of libgcc/libstdc++ by default.  Set
+# STATIC_STDCPLUS to "yes" to link against static versions instead.
+STATIC_STDCPLUS=no
+#STATIC_STDCPLUS=yes
+
+# Note: -static-libstdc++ is not available until gcc 4.5.x.
+LDFLAGS += -shared
+ifeq (yes, $(STATIC_STDCPLUS))
+LDFLAGS += -static-libgcc -static-libstdc++
+endif
+
+ifeq ($(CROSS),yes)
+DEL = rm
+ifeq ($(MINGWOLD),yes)
+CXXFLAGS := -O2 -fvtable-thunks
+else
+CXXFLAGS := -O2
+endif
+else
+CXXFLAGS := -O2
+ifneq (sh.exe, $(SHELL))
+DEL = rm
+else
+DEL = del
+endif
+endif
+CXX := $(CROSS_COMPILE)g++
+WINDRES := $(CROSS_COMPILE)windres
+WINDRES_CXX = $(CXX)
+WINDRES_FLAGS = --preprocessor="$(WINDRES_CXX) -E -xc" -DRC_INVOKED
+LIBS :=  -luuid
+RES  := gvimext.res
+DEFFILE = gvimext_ming.def
+OBJ  := gvimext.o
+
+DLL  := gvimext.dll
+
+.PHONY: all all-before all-after clean clean-custom
+
+all: all-before $(DLL) all-after
+
+$(DLL): $(OBJ) $(RES) $(DEFFILE)
+	$(CXX) $(LDFLAGS) $(CXXFLAGS) -s -o $@ \
+		-Wl,--enable-auto-image-base \
+		-Wl,--enable-auto-import \
+		-Wl,--whole-archive \
+			$^ \
+		-Wl,--no-whole-archive \
+			$(LIBS)
+
+gvimext.o: gvimext.cpp
+	$(CXX) $(CXXFLAGS) -DFEAT_GETTEXT -c $? -o $@
+
+$(RES): gvimext_ming.rc
+	$(WINDRES) $(WINDRES_FLAGS) --input-format=rc --output-format=coff -DMING $? -o $@
+
+clean: clean-custom
+	-$(DEL)  $(OBJ) $(RES) $(DLL)
diff -urN vim-src/src/Make_bc3.mak vim-qt-src/src/Make_bc3.mak
--- vim-src/src/Make_bc3.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/Make_bc3.mak	2016-06-08 06:39:27.687314888 +0200
@@ -0,0 +1,183 @@
+# Makefile for Borland C++ 3.1 or 4.0 to compile a 16 bit version of Vim.
+#
+# NOTE: THIS IS OLD AND PROBABLY NO LONGER WORKS.
+#
+# There are compilation options at the end of this file.
+#
+# Command line variables:
+# BOR		path to root of Borland C (E:\BORLANDC)
+# DEBUG		set to "yes" for debugging (no)
+# SPAWNO	path to the spawno library directory, empty if you do not have
+#		it; use 8.3 filenames! (C:\CC\SPAWN)
+
+.AUTODEPEND
+
+!ifndef BOR
+BOR = E:\BORLANDC
+!endif
+
+!if ("$(DEBUG)" == "yes")
+DEBUG_FLAG = -v
+!else
+DEBUG_FLAG =
+!endif
+
+CC = $(BOR)\bin\bcc.exe +VIM.CFG
+TLINK = $(BOR)\bin\tlink.exe
+
+!ifndef SPAWNO
+SPAWNO = C:\CC\SPAWN
+!endif
+
+!if ("$(SPAWNO)" == "")
+LIBPATH = $(BOR)\LIB
+INCLUDEPATH = $(BOR)\INCLUDE
+SPAWND =
+SPAWNL =
+!else
+LIBPATH = $(BOR)\LIB;$(SPAWNO)
+INCLUDEPATH = $(BOR)\INCLUDE;$(SPAWNO)
+SPAWND = ;SPAWNO
+SPAWNL = spawnl.lib
+!endif
+
+
+#		*Implicit Rules*
+#
+# use -v for debugging
+#
+.c.obj:
+	$(CC) -c $(DEBUG_FLAG) {$< }
+
+#		*List Macros*
+
+
+EXE_dependencies = \
+	blowfish.obj \
+	buffer.obj \
+	charset.obj \
+	crypt.obj \
+	crypt_zip.obj \
+	diff.obj \
+	digraph.obj \
+	edit.obj \
+	eval.obj \
+	ex_cmds.obj \
+	ex_cmds2.obj \
+	ex_docmd.obj \
+	ex_eval.obj \
+	ex_getln.obj \
+	fileio.obj \
+	fold.obj \
+	getchar.obj \
+	hardcopy.obj \
+	hashtab.obj \
+	main.obj \
+	mark.obj \
+	memfile.obj \
+	memline.obj \
+	menu.obj \
+	message.obj \
+	misc1.obj \
+	misc2.obj \
+	move.obj \
+	os_msdos.obj \
+	normal.obj \
+	ops.obj \
+	option.obj \
+	popupmnu.obj \
+	quickfix.obj \
+	regexp.obj \
+	screen.obj \
+	search.obj \
+	sha256.obj \
+	spell.obj \
+	syntax.obj \
+	tag.obj \
+	term.obj \
+	ui.obj \
+	undo.obj \
+	window.obj
+
+all: vim.exe install.exe uninstal.exe xxd/xxd.exe
+
+#		*Explicit Rules*
+
+vim.exe: vim.cfg $(EXE_dependencies) version.c
+	$(CC) $(DEBUG_FLAG) -c version.c
+	$(TLINK) /x/c/L$(LIBPATH) $(DEBUG_FLAG) @&&|
+c0l.obj $(EXE_dependencies) version.obj
+vim
+		# no map file
+$(SPAWNL) cl.lib
+|
+
+install.exe: dosinst.c
+	$(CC) -einstall $(DEBUG_FLAG) dosinst.c
+
+uninstal.exe: uninstal.c
+	$(CC) $(DEBUG_FLAG) uninstal.c
+
+# This may fail for older make versions, building xxd will fail anyway then.
+xxd/xxd.exe: xxd/xxd.c
+	cd xxd
+	$(MAKE) -f Make_bc3.mak BOR=$(BOR) DEBUG=$(DEBUG)
+	cd ..
+
+# cleaning up: Delete all generated files
+clean:
+	-del *.obj
+	-del vim.exe
+	-del vim.sym
+	-del install.exe
+	-del uninstal.exe
+	-del xxd\*.obj
+	-del xxd\xxd.exe
+	-del vim.cfg
+	-del testdir\*.out
+
+# Individual File Dependencies (incomplete)
+ex_docmd.obj: ex_docmd.c ex_cmds.h
+
+ex_eval.obj: ex_eval.c ex_cmds.h
+
+main.obj: main.c globals.h option.h
+
+term.obj: term.c term.h
+
+version.obj: version.c version.h
+
+
+# Compiler Configuration File
+#
+# The following compile options can be changed for better machines.
+#	replace -1- with -2 to produce code for a 80286 or higher
+#	replace -1- with -3 to produce code for a 80386 or higher
+#	add -v for source debugging
+vim.cfg: Make_bc3.mak
+	copy &&|
+-ml
+-1-
+-f-
+-C
+-N
+-O
+-Z
+-k-
+-d
+-h
+-vi-
+-H=VIM.SYM
+-w-par
+-weas
+-wpre
+-Iproto
+-I$(INCLUDEPATH)
+-L$(LIBPATH)
+-DMSDOS;FEAT_TINY$(SPAWND)
+| vim.cfg
+
+test:
+	cd testdir
+	$(MAKE) -f Make_dos.mak small
+	cd ..
diff -urN vim-src/src/Make_djg.mak vim-qt-src/src/Make_djg.mak
--- vim-src/src/Make_djg.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/Make_djg.mak	2016-06-08 06:39:27.687314888 +0200
@@ -0,0 +1,112 @@
+#
+# Makefile for VIM on MSDOS, using DJGPP 2.0
+#
+# NOTE: THIS IS OLD AND PROBABLY NO LONGER WORKS.
+#
+
+#>>>>> choose options:
+
+### See feature.h for a list of optionals.
+### Any other defines can be included here.
+
+DEFINES =
+
+#>>>>> name of the compiler and linker, name of lib directory
+CC = gcc
+
+#>>>>> end of choices
+###########################################################################
+
+INCL = vim.h globals.h option.h keymap.h macros.h ascii.h term.h os_msdos.h structs.h
+CFLAGS = -O2 -DMSDOS -Iproto $(DEFINES) -Wall -Dinterrupt= -Dfar= -DMAXMEM=512 -D_NAIVE_DOS_REGS
+
+OBJ = \
+	obj/blowfish.o \
+	obj/buffer.o \
+	obj/charset.o \
+	obj/crypt.o \
+	obj/crypt_zip.o \
+	obj/diff.o \
+	obj/digraph.o \
+	obj/edit.o \
+	obj/eval.o \
+	obj/ex_cmds.o \
+	obj/ex_cmds2.o \
+	obj/ex_docmd.o \
+	obj/ex_eval.o \
+	obj/ex_getln.o \
+	obj/fileio.o \
+	obj/fold.o \
+	obj/getchar.o \
+	obj/hardcopy.o \
+	obj/hashtab.o \
+	obj/main.o \
+	obj/mark.o \
+	obj/memfile.o \
+	obj/memline.o \
+	obj/menu.o \
+	obj/message.o \
+	obj/misc1.o \
+	obj/misc2.o \
+	obj/move.o \
+	obj/mbyte.o \
+	obj/normal.o \
+	obj/ops.o \
+	obj/option.o \
+	obj/os_msdos.o \
+	obj/popupmnu.o \
+	obj/quickfix.o \
+	obj/regexp.o \
+	obj/screen.o \
+	obj/search.o \
+	obj/sha256.o \
+	obj/spell.o \
+	obj/syntax.o \
+	obj/tag.o \
+	obj/term.o \
+	obj/ui.o \
+	obj/undo.o \
+	obj/window.o \
+	$(TERMLIB)
+
+all: vim.exe install.exe uninstal.exe xxd/xxd.exe
+
+# version.c is compiled each time, so that it sets the build time.
+vim.exe: obj $(OBJ) version.c version.h
+	$(CC) $(CFLAGS) -s -o vim.exe version.c $(OBJ) -lpc
+
+install.exe: dosinst.c
+	$(CC) $(CFLAGS) -s -o install.exe dosinst.c -lpc
+
+uninstal.exe: uninstal.c
+	$(CC) $(CFLAGS) -s -o uninstal.exe uninstal.c -lpc
+
+# This requires GNU make.
+xxd/xxd.exe: xxd/xxd.c
+	$(MAKE) --directory=xxd -f Make_djg.mak
+
+obj:
+	mkdir obj
+
+tags:
+	command /c ctags *.c $(INCL) ex_cmds.h
+
+clean:
+	-del obj\*.o
+	-rmdir obj
+	-del vim.exe
+	-del install.exe
+	-del xxd\xxd.exe
+	-del testdir\*.out
+
+# This requires GNU make.
+test:
+	$(MAKE) --directory=testdir -f Make_dos.mak
+
+###########################################################################
+
+obj/%.o: %.c obj $(INCL)
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+# Extra dependency (there are actually many more...)
+obj/ex_docmd.o:	ex_cmds.h
diff -urN vim-src/src/Make_w16.mak vim-qt-src/src/Make_w16.mak
--- vim-src/src/Make_w16.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/Make_w16.mak	2016-06-08 06:39:27.688314896 +0200
@@ -0,0 +1,204 @@
+#
+# Borland C++ 5.0[12] makefile for vim, 16-bit windows gui version
+# By Vince Negri
+#
+# NOTE: THIS IS OLD AND PROBABLY NO LONGER WORKS.
+#
+# *************************************************************
+# * WARNING!
+# * This was originally produced by the IDE, but has since been
+# * modified to make it work properly. Adjust with care!
+# * In particular, leave LinkerLocalOptsAtW16_gvim16dexe alone
+# * unless you are a guru.
+# *************************************************************
+#
+# Look for BOR below and either pass a different value or
+# adjust the path as required. For example
+#   make -fMake_w16.mak -DBOR=C:\PF\Borland\BC5.01 -B BccW16.cfg
+#   make -fMake_w16.mak
+# Note: $(BOR) is effectively ignored unless BccW16.cfg is rebuilt.
+#
+# Does not compile with Borland C++ 4.51 Walter Briscoe 2003-02-24
+# "out of memory" from compiler if gvim16 wildly wrong. WFB 2003-03-04
+#
+# vim16.def must be a DOS-formatted file. (\r\n line endings.)
+# It is a UNIX-formatted file (\n line endings) in vim-*-extra.tar.gz
+
+.AUTODEPEND
+
+#
+# Borland C++ tools
+#
+IMPLIB  = Implib
+BCC     = Bcc +BccW16.cfg
+TLINK   = TLink
+TLIB    = TLib
+BRC     = Brc
+TASM    = Tasm
+#
+# IDE macros
+#
+
+#
+# Options
+#
+!ifndef BOR
+BOR = D:\BC5
+!endif
+
+# !ifndef INTDIR is lethal considering CLEAN below. WFB 2003-03-13
+INTDIR=w16
+
+#  /Twe Make the target a Windows .EXE with explicit functions exportable +
+#  /x   Map file off
+#  /l   Include source line numbers in object map files`
+#  /c   case sensitive link
+#  /C   Case-sensitive exports and imports (16-bit only)
+#  /k   Produce "No Stack" warning.
+#  /Oa  Minimise segment alignment
+#  /Oc  Minimise Chain fixes
+#  /Oi  Minimise Iterated data
+#  /Or  Minimise resource alignment
+#  /P   -P=x  Code pack size
+#  /V   Windows version for application
+#  /L   Folder to search for library files
+LinkerLocalOptsAtW16_gvim16dexe =/Twe/x/l/c/C/k/Or/Oc/Oa/Oi/P=65535/V3.10
+
+CompInheritOptsAt_gvim16dexe = \
+   -I$(BOR)\INCLUDE;PROTO;. \
+   -DFEAT_GUI;FEAT_GUI_MSWIN;FEAT_GUI_W16;MSWIN;WIN16;MSWIN16_FASTTEXT \
+   -DFEAT_TOOLBAR;WIN16_3DLOOK
+
+#
+# Dependency List
+#
+Dep_Gvim16 = \
+   gvim16.exe
+
+ObjFiles = \
+   $(INTDIR)\buffer.obj\
+   $(INTDIR)\charset.obj\
+   $(INTDIR)\diff.obj\
+   $(INTDIR)\digraph.obj\
+   $(INTDIR)\edit.obj\
+   $(INTDIR)\eval.obj\
+   $(INTDIR)\ex_cmds.obj\
+   $(INTDIR)\ex_cmds2.obj\
+   $(INTDIR)\ex_docmd.obj\
+   $(INTDIR)\ex_eval.obj\
+   $(INTDIR)\ex_getln.obj\
+   $(INTDIR)\fileio.obj\
+   $(INTDIR)\fold.obj\
+   $(INTDIR)\getchar.obj\
+   $(INTDIR)\hardcopy.obj\
+   $(INTDIR)\hashtab.obj\
+   $(INTDIR)\gui.obj\
+   $(INTDIR)\gui_w16.obj\
+   $(INTDIR)\main.obj\
+   $(INTDIR)\mark.obj\
+   $(INTDIR)\mbyte.obj\
+   $(INTDIR)\memfile.obj\
+   $(INTDIR)\memline.obj\
+   $(INTDIR)\menu.obj\
+   $(INTDIR)\message.obj\
+   $(INTDIR)\misc1.obj\
+   $(INTDIR)\misc2.obj\
+   $(INTDIR)\move.obj\
+   $(INTDIR)\normal.obj\
+   $(INTDIR)\ops.obj\
+   $(INTDIR)\option.obj\
+   $(INTDIR)\os_win16.obj\
+   $(INTDIR)\os_msdos.obj\
+   $(INTDIR)\os_mswin.obj\
+   $(INTDIR)\winclip.obj\
+   $(INTDIR)\popupmnu.obj\
+   $(INTDIR)\quickfix.obj\
+   $(INTDIR)\regexp.obj\
+   $(INTDIR)\screen.obj\
+   $(INTDIR)\search.obj\
+   $(INTDIR)\spell.obj\
+   $(INTDIR)\syntax.obj\
+   $(INTDIR)\tag.obj\
+   $(INTDIR)\term.obj\
+   $(INTDIR)\ui.obj\
+   $(INTDIR)\undo.obj\
+   $(INTDIR)\version.obj\
+   $(INTDIR)\window.obj
+
+Dep_gvim16dexe = \
+   vimtbar.lib\
+   vim16.def\
+   $(INTDIR)\vim16.res\
+   $(ObjFiles)
+
+# Without the following, the implicit rule in BUILTINS.MAK is picked up
+# for a rule for .c.obj rather than the local implicit rule
+.SUFFIXES
+.SUFFIXES .c .obj
+.path.c = .
+
+# -P-	Force C++ compilation off
+# -c	Compilation only
+# -n    Place .OBJ files
+{.}.c{$(INTDIR)}.obj:
+  $(BCC) -P- -c -n$(INTDIR)\ {$< }
+
+Gvim16 : BccW16.cfg $(Dep_Gvim16)
+  echo MakeNode
+
+gvim16.exe : $(Dep_gvim16dexe)
+  $(TLINK)   $(LinkerLocalOptsAtW16_gvim16dexe) @&&|
+c0wl.obj $(ObjFiles)
+|,$*,,vimtbar ctl3dv2 import cwl, vim16.def,$(INTDIR)\vim16.res
+
+# Force objects to be built if $(BOR) changes
+$(ObjFiles) : Make_w16.mak BccW16.cfg
+
+$(INTDIR)\vim16.res : vim16.rc
+  $(BRC) -R @&&|
+  $(CompInheritOptsAt_gvim16dexe) -fo$*.res $?
+|
+
+
+# Compiler configuration file
+# There is no rule for $(INTDIR) as make always says it does not exist
+BccW16.cfg :
+	-@if not exist $(INTDIR)\$(NULL) mkdir $(INTDIR)
+	Copy &&|
+-3		; Generate 80386 protected-mode compatible instructions
+-a		; Byte alignment
+-dc		; Move string literals from data segment to code segment
+-ff		; Fast floating point
+-H		; Generate and use precompiled headers
+-H=$(INTDIR)\gvim16.csm	; gvim16.csm is the precompiled header filename
+-k-		; No standard stack frame
+-ml		; Large memory model
+-OW		; Suppress the inc bp/dec bp on windows far functions
+-O1		; Generate smallest possible code
+-O2		; Generate fastest possible code (overrides prior -O1 control)
+-pr		; Fastcall calling convention passing parameters in registers
+-R-		; Exclude browser information in generated .OBJ files
+-v-		; Turn off source debugging
+-vi		; Turn inline function expansion on
+-WE		; Only __far _export functions are exported
+-w		; Display warnings
+-w-par		; Suppress: Parameter 'parameter' is never used
+-w-pch		; Cannot create pre-compiled header: initialized data in header
+-w-sig		; identifier' declared but never used
+-w-ucp		; Mixing pointers to different 'char' types
+-wuse		; 'identifier' declared but never used
+ $(CompInheritOptsAt_gvim16dexe)
+| $@
+
+!IF "$(OS)" == "Windows_NT"
+NULL=
+DEL_TREE = rmdir /s /q
+!ELSE
+NULL=nul
+DEL_TREE = deltree /y
+!ENDIF
+
+CLEAN:
+	-@if exist $(INTDIR)\$(NULL) $(DEL_TREE) $(INTDIR)
+	-@if exist BccW16.cfg erase BccW16.cfg
+	-@if exist gvim16.exe erase gvim16.exe
diff -urN vim-src/src/Makefile vim-qt-src/src/Makefile
--- vim-src/src/Makefile	2016-06-08 06:34:09.766884589 +0200
+++ vim-qt-src/src/Makefile	2016-06-08 06:40:09.593637069 +0200
@@ -1298,6 +1298,39 @@
 NEXTAW_TESTTARGET = gui
 NEXTAW_BUNDLE	=
 
+### Qt
+# We use the following to build
+# - QT_MOC
+# - QT_LIBS
+# - QT_INCPATH
+MOC		= $(QT_MOC)
+QT_LIBS1	= $(QT_LIBS)
+QT_SRC	= gui.c gui_qt.cpp pty.c gui_beval.c \
+			qt/qvimshell.cpp qt/mainwindow.cpp qt/vimaction.cpp qt/scrollarea.cpp \
+			qt/fontdialog.cpp \
+			qt/colortable.cpp \
+			qt/vimwrapper.cpp qt/tabbar.cpp qt/vimscrollbar.cpp \
+			qt/vimevents.cpp
+QT_OBJ	= objects/gui.o objects/gui_qt.o \
+			objects/pty.o objects/gui_beval.o \
+			objects/mainwindow.o objects/qvimshell.o objects/vimaction.o objects/qtresources.o \
+			objects/colortable.o \
+			objects/scrollarea.o objects/fontdialog.o objects/vimwrapper.o \
+			objects/vimevents.o \
+			objects/tabbar.o objects/vimscrollbar.o
+
+QT_DEFS	= -DFEAT_GUI_QT $(NARROW_PROTO) -Iqt -I. $(QT_INCPATH)
+QT_IPATH	= $(GUI_INC_LOC)
+QT_LIBS_DIR = $(GUI_LIB_LOC)
+
+QT_INSTALL  = install_normal install_gui_extra
+
+# Qt needs to be linked using the c++ compiler
+ifdef QT_LIBS
+	CClink=$(CXX)
+endif
+
+
 ### (J)  Sun OpenWindows 3.2 (SunOS 4.1.x) or earlier that produce these ld
 #	 errors:  ld: Undefined symbol
 #		      _get_wmShellWidgetClass
@@ -1342,7 +1375,7 @@
 CARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)
 
 # All GUI files
-ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c pty.c
+ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c pty.c gui_qt_cpp qt/qvimshell.cpp qt/mainwindow.cpp qt/vimgui.cpp qt/fontdialog.cpp qt/colortable.cpp
 ALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w32.pro gui_photon.pro
 
 # }}}
@@ -1390,7 +1423,7 @@
 PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
 POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
 
-ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
+ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS) $(QT_CFLAGS)
 
 # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
 # with "-E".
@@ -1543,7 +1576,7 @@
 	$(WORKSHOP_SRC) \
 	$(WSDEBUG_SRC)
 
-TAGS_SRC = *.c *.cpp if_perl.xs
+TAGS_SRC = *.c *.cpp if_perl.xs qt/*.cpp
 
 EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
 	    if_python.c if_python3.c if_tcl.c if_ruby.c \
@@ -2809,6 +2842,56 @@
 objects/gui_athena.o: gui_athena.c
 	$(CCC) -o $@ gui_athena.c
 
+## Qt objects
+objects/gui_qt.o: gui_qt.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c gui_qt.cpp
+
+objects/mainwindow.o: qt/mainwindow.cpp
+	$(MOC) qt/mainwindow.h > mainwindow.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/mainwindow.cpp
+
+objects/qvimshell.o: qt/qvimshell.cpp
+	$(MOC) qt/qvimshell.h > qvimshell.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/qvimshell.cpp
+
+objects/colortable.o: qt/colortable.cpp
+	$(MOC) qt/colortable.h > colortable.moc
+	$(CXX) $(ALL_CFLAGS) -O0 -o $@ -c qt/colortable.cpp # -O0 is needed here
+
+objects/vimaction.o: qt/vimaction.cpp
+	$(MOC) qt/vimaction.h > vimaction.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimaction.cpp
+
+objects/qtresources.o: qt/icons.qrc
+	$(QT_RCC) -no-compress qt/icons.qrc -o qtresources.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qtresources.cpp
+
+objects/vimscrollbar.o: qt/vimscrollbar.cpp
+	$(MOC) qt/vimscrollbar.h > vimscrollbar.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimscrollbar.cpp
+
+objects/scrollarea.o: qt/scrollarea.cpp
+	$(MOC) qt/scrollarea.h > scrollarea.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/scrollarea.cpp
+
+objects/vimgui.o: qt/vimgui.cpp
+	$(MOC) qt/vimgui.h > vimgui.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimgui.cpp
+
+objects/fontdialog.o: qt/fontdialog.cpp
+	$(MOC) qt/fontdialog.h > fontdialog.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/fontdialog.cpp
+
+objects/vimwrapper.o: qt/vimwrapper.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimwrapper.cpp
+
+objects/vimevents.o: qt/vimevents.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimevents.cpp
+
+objects/tabbar.o: qt/tabbar.cpp
+	$(MOC) qt/tabbar.h > tabbar.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/tabbar.cpp
+
 objects/gui_beval.o: gui_beval.c
 	$(CCC) -o $@ gui_beval.c
 
diff -urN vim-src/src/Toolchain-mingw32.cmake vim-qt-src/src/Toolchain-mingw32.cmake
--- vim-src/src/Toolchain-mingw32.cmake	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/Toolchain-mingw32.cmake	2016-06-08 06:39:27.689314903 +0200
@@ -0,0 +1,18 @@
+
+SET(CMAKE_SYSTEM_NAME Windows)
+
+# specify the cross compiler
+SET(CMAKE_C_COMPILER   i686-w64-mingw32-gcc)
+SET(CMAKE_CXX_COMPILER i686-w64-mingw32-g++)
+SET(CMAKE_RC_COMPILER i686-w64-mingw32-windres)
+
+SET(CMAKE_FIND_ROOT_PATH /usr/i686-w64-mingw32/sys-root/mingw)
+
+SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+
+SET(QT_QMAKE_EXECUTABLE /usr/i686-w64-mingw32/bin/qmake CACHE INTERNAL "" FORCE)
+SET(QT_MOC_EXECUTABLE /usr/i686-w64-mingw32/bin/moc CACHE INTERNAL "" FORCE)
+SET(QT_RCC_EXECUTABLE /usr/i686-w64-mingw32/bin/rcc CACHE INTERNAL "" FORCE)
+SET(QT_UIC_EXECUTABLE /usr/i686-w64-mingw32/bin/uic CACHE INTERNAL "" FORCE)
diff -urN vim-src/src/config.mk.in vim-qt-src/src/config.mk.in
--- vim-src/src/config.mk.in	2016-06-08 06:34:09.770884620 +0200
+++ vim-qt-src/src/config.mk.in	2016-06-08 06:40:09.597637100 +0200
@@ -157,6 +157,12 @@
 GUI_X_LIBS	= @GUI_X_LIBS@
 MOTIF_LIBNAME	= @MOTIF_LIBNAME@
 GTK_LIBNAME	= @GTK_LIBNAME@
+QT_MOC		= @QT_MOC@
+QT_RCC		= @QT_RCC@
+QT_LIBS		= @QT_LIBS@
+QT_INCPATH	= @QT_INCPATH@
+QT_CXXFLAGS	= @QT_CXXFLAGS@
+QT_CFLAGS	= @QT_CFLAGS@
 
 GLIB_COMPILE_RESOURCES = @GLIB_COMPILE_RESOURCES@
 GRESOURCE_SRC = @GRESOURCE_SRC@
diff -urN vim-src/src/configure vim-qt-src/src/configure
--- vim-src/src/configure	2016-01-21 17:44:00.329174853 +0100
+++ vim-qt-src/src/configure	2016-06-08 06:40:09.599637115 +0200
@@ -1,10 +1,16143 @@
 #! /bin/sh
-# run the automatically generated configure script
-CONFIG_STATUS=auto/config.status \
-	auto/configure "$@" --srcdir="${srcdir:-.}" --cache-file=auto/config.cache
-result=$?
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.69.
+#
+#
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+PACKAGE_URL=
+
+ac_unique_file="vim.h"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+LINK_AS_NEEDED
+DEPEND_CFLAGS_FILTER
+MAKEMO
+MSGFMT
+INSTALL_TOOL_LANGS
+INSTALL_LANGS
+TAGPRG
+HANGULIN_OBJ
+HANGULIN_SRC
+GUI_X_LIBS
+GUITYPE
+GUI_LIB_LOC
+GUI_INC_LOC
+QT_CFLAGS
+QT_CXXFLAGS
+QT_INCPATH
+QT_RCC
+QT_MOC
+QT_LIBS
+MAKE_P
+QMAKE
+ac_ct_CXX
+CXXFLAGS
+CXX
+NARROW_PROTO
+MOTIF_LIBNAME
+GRESOURCE_OBJ
+GRESOURCE_SRC
+UPDATE_DESKTOP_DATABASE
+GTK_UPDATE_ICON_CACHE
+GLIB_COMPILE_RESOURCES
+GNOME_INCLUDEDIR
+GNOME_LIBDIR
+GNOME_LIBS
+GTK_LIBNAME
+GTK_LIBS
+GTK_CFLAGS
+PKG_CONFIG
+X_LIB
+X_EXTRA_LIBS
+X_LIBS
+X_PRE_LIBS
+X_CFLAGS
+XMKMF
+xmkmfpath
+CHANNEL_OBJ
+CHANNEL_SRC
+NETBEANS_OBJ
+NETBEANS_SRC
+WORKSHOP_OBJ
+WORKSHOP_SRC
+RUBY_LIBS
+RUBY_CFLAGS
+RUBY_PRO
+RUBY_OBJ
+RUBY_SRC
+vi_cv_path_ruby
+TCL_LIBS
+TCL_CFLAGS
+TCL_PRO
+TCL_OBJ
+TCL_SRC
+vi_cv_path_tcl
+PYTHON3_OBJ
+PYTHON3_SRC
+PYTHON3_CFLAGS
+PYTHON3_LIBS
+PYTHON3_CONFDIR
+vi_cv_path_python3
+PYTHON_OBJ
+PYTHON_SRC
+PYTHON_CFLAGS
+PYTHON_GETPATH_CFLAGS
+PYTHON_LIBS
+PYTHON_CONFDIR
+vi_cv_path_python
+PERL_LIBS
+PERL_CFLAGS
+PERL_PRO
+PERL_OBJ
+PERL_SRC
+shrpenv
+vi_cv_perl_xsubpp
+vi_cv_perllib
+vi_cv_path_perl
+MZSCHEME_MZC
+MZSCHEME_EXTRA
+MZSCHEME_CFLAGS
+MZSCHEME_LIBS
+MZSCHEME_PRO
+MZSCHEME_OBJ
+MZSCHEME_SRC
+vi_cv_path_mzscheme
+LUA_CFLAGS
+LUA_LIBS
+LUA_PRO
+LUA_OBJ
+LUA_SRC
+vi_cv_path_plain_lua
+vi_cv_path_luajit
+vi_cv_path_lua
+compiledby
+dogvimdiff
+dovimdiff
+QUOTESED
+line_break
+VIEWNAME
+EXNAME
+VIMNAME
+OS_EXTRA_OBJ
+OS_EXTRA_SRC
+XCODE_SELECT
+CPP_MM
+CROSS_COMPILING
+STRIP
+AWK
+FGREP
+EGREP
+GREP
+CPP
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+SET_MAKE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_fail_if_missing
+enable_darwin
+with_mac_arch
+with_developer_dir
+with_local_dir
+with_vim_name
+with_ex_name
+with_view_name
+with_global_runtime
+with_modified_by
+enable_smack
+enable_selinux
+with_features
+with_compiledby
+enable_xsmp
+enable_xsmp_interact
+enable_luainterp
+with_lua_prefix
+with_luajit
+enable_mzschemeinterp
+with_plthome
+enable_perlinterp
+enable_pythoninterp
+with_python_config_dir
+enable_python3interp
+with_python3_config_dir
+enable_tclinterp
+with_tclsh
+enable_rubyinterp
+with_ruby_command
+enable_cscope
+enable_workshop
+enable_netbeans
+enable_channel
+enable_multibyte
+enable_hangulinput
+enable_xim
+enable_fontset
+with_x
+enable_gui
+enable_gtk2_check
+enable_gnome_check
+enable_gtk3_check
+enable_motif_check
+enable_athena_check
+enable_nextaw_check
+enable_carbon_check
+enable_gtktest
+with_gnome_includes
+with_gnome_libs
+with_gnome
+enable_icon_cache_update
+enable_desktop_database_update
+with_motif_lib
+with_qt_qmake
+with_tlib
+enable_largefile
+enable_acl
+enable_gpm
+enable_sysmouse
+enable_nls
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP
+XMKMF
+CXX
+CXXFLAGS
+CCC'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+X features:
+  --x-includes=DIR    X include files are in DIR
+  --x-libraries=DIR   X library files are in DIR
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-fail-if-missing    Fail if dependencies on additional features
+     specified on the command line are missing.
+  --disable-darwin        Disable Darwin (Mac OS X) support.
+  --disable-smack	  Do not check for Smack support.
+  --disable-selinux	  Do not check for SELinux support.
+  --disable-xsmp          Disable XSMP session management
+  --disable-xsmp-interact Disable XSMP interaction
+  --enable-luainterp=OPTS     Include Lua interpreter.  default=no OPTS=no/yes/dynamic
+  --enable-mzschemeinterp   Include MzScheme interpreter.
+  --enable-perlinterp=OPTS     Include Perl interpreter.  default=no OPTS=no/yes/dynamic
+  --enable-pythoninterp=OPTS   Include Python interpreter. default=no OPTS=no/yes/dynamic
+  --enable-python3interp=OPTS   Include Python3 interpreter. default=no OPTS=no/yes/dynamic
+  --enable-tclinterp=OPTS      Include Tcl interpreter. default=no OPTS=no/yes/dynamic
+  --enable-rubyinterp=OPTS     Include Ruby interpreter.  default=no OPTS=no/yes/dynamic
+  --enable-cscope         Include cscope interface.
+  --enable-workshop       Include Sun Visual Workshop support.
+  --disable-netbeans      Disable NetBeans integration support.
+  --disable-channel      Disable process communication support.
+  --enable-multibyte      Include multibyte editing support.
+  --enable-hangulinput    Include Hangul input support.
+  --enable-xim            Include XIM input support.
+  --enable-fontset        Include X fontset output support.
+  --enable-gui=OPTS     X11 GUI default=auto OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon/qt
+  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 default=yes
+  --enable-gnome-check    If GTK GUI, check for GNOME default=no
+  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 default=yes
+  --enable-motif-check    If auto-select GUI, check for Motif default=yes
+  --enable-athena-check   If auto-select GUI, check for Athena default=yes
+  --enable-nextaw-check   If auto-select GUI, check for neXtaw default=yes
+  --enable-carbon-check   If auto-select GUI, check for Carbon default=yes
+  --disable-gtktest       Do not try to compile and run a test GTK program
+  --disable-icon-cache-update        update disabled
+  --disable-desktop-database-update  update disabled
+  --disable-largefile     omit support for large files
+  --disable-acl           Don't check for ACL support.
+  --disable-gpm           Don't use gpm (Linux mouse daemon).
+  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).
+  --disable-nls           Don't support NLS (gettext()).
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-mac-arch=ARCH    current, intel, ppc or both
+  --with-developer-dir=PATH    use PATH as location for Xcode developer tools
+  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
+  --without-local-dir     do not search /usr/local for local libraries.
+  --with-vim-name=NAME    what to call the Vim executable
+  --with-ex-name=NAME     what to call the Ex executable
+  --with-view-name=NAME   what to call the View executable
+  --with-global-runtime=DIR    global runtime directory in 'runtimepath'
+  --with-modified-by=NAME       name of who modified a release version
+  --with-features=TYPE    tiny, small, normal, big or huge (default: normal)
+  --with-compiledby=NAME  name to show in :version message
+  --with-lua-prefix=PFX   Prefix where Lua is installed.
+  --with-luajit           Link with LuaJIT instead of Lua.
+  --with-plthome=PLTHOME   Use PLTHOME.
+  --with-python-config-dir=PATH  Python's config directory
+  --with-python3-config-dir=PATH  Python's config directory
+  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)
+  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)
+  --with-x                use the X Window System
+  --with-gnome-includes=DIR Specify location of GNOME headers
+  --with-gnome-libs=DIR   Specify location of GNOME libs
+  --with-gnome            Specify prefix for GNOME files
+  --with-motif-lib=STRING   Library for Motif
+  --with-qt-qmake=PATH   QMake location (ex: /usr/lib/qt4/bin/qmake)
+  --with-tlib=library     terminal library to be used
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+  XMKMF       Path to xmkmf, Makefile generator for X Window System
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+configure
+generated by GNU Autoconf 2.69
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if eval \${$3+:} false; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_header_mongrel
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_func
+
+# ac_fn_cxx_try_compile LINENO
+# ----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_cxx_try_compile
+
+# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
+# -------------------------------------------
+# Tests whether TYPE exists after having included INCLUDES, setting cache
+# variable VAR accordingly.
+ac_fn_c_check_type ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof ($2))
+	 return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof (($2)))
+	    return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  eval "$3=yes"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_type
+
+# ac_fn_c_find_uintX_t LINENO BITS VAR
+# ------------------------------------
+# Finds an unsigned integer type with width BITS, setting cache variable VAR
+# accordingly.
+ac_fn_c_find_uintX_t ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for uint$2_t" >&5
+$as_echo_n "checking for uint$2_t... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=no"
+     # Order is important - never check a type that is potentially smaller
+     # than half of the expected target width.
+     for ac_type in uint$2_t 'unsigned int' 'unsigned long int' \
+	 'unsigned long long int' 'unsigned short int' 'unsigned char'; do
+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !((($ac_type) -1 >> ($2 / 2 - 1)) >> ($2 / 2 - 1) == 3)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  case $ac_type in #(
+  uint$2_t) :
+    eval "$3=yes" ;; #(
+  *) :
+    eval "$3=\$ac_type" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+       if eval test \"x\$"$3"\" = x"no"; then :
+
+else
+  break
+fi
+     done
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_find_uintX_t
+
+# ac_fn_c_compute_int LINENO EXPR VAR INCLUDES
+# --------------------------------------------
+# Tries to find the compile-time value of EXPR in a program that includes
+# INCLUDES, setting VAR accordingly. Returns whether the value could be
+# computed
+ac_fn_c_compute_int ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if test "$cross_compiling" = yes; then
+    # Depending upon the size, compute the lo and hi bounds.
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= 0)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid; break
+else
+  as_fn_arith $ac_mid + 1 && ac_lo=$as_val
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) < 0)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=$ac_mid; break
+else
+  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid && ac_mid=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  ac_lo= ac_hi=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0;
+return test_array [0];
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid
+else
+  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in #((
+?*) eval "$3=\$ac_lo"; ac_retval=0 ;;
+'') ac_retval=1 ;;
+esac
+  else
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+static long int longval () { return $2; }
+static unsigned long int ulongval () { return $2; }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (($2) < 0)
+    {
+      long int i = longval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%ld", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%lu", i);
+    }
+  /* Do not output a trailing newline, as this causes \r\n confusion
+     on some platforms.  */
+  return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  echo >>conftest.val; read $3 <conftest.val; ac_retval=0
+else
+  ac_retval=1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+rm -f conftest.val
+
+  fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_compute_int
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+ac_config_headers="$ac_config_headers auto/config.h:config.h.in"
+
+
+$as_echo "#define UNIX 1" >>confdefs.h
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+if test -z "$ac_file"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+rm -f conftest conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details" "$LINENO" 5; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if ${ac_cv_objext+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if ${ac_cv_prog_cc_c89+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+	ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if ${ac_cv_prog_CPP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if ${ac_cv_path_GREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_GREP" || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if ${ac_cv_path_EGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_EGREP" || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "" >/dev/null 2>&1; then :
+
+fi
+rm -f conftest*
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if ${ac_cv_path_FGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_FGREP" || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing strerror" >&5
+$as_echo_n "checking for library containing strerror... " >&6; }
+if ${ac_cv_search_strerror+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char strerror ();
+int
+main ()
+{
+return strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' cposix; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_strerror=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_strerror+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_strerror+:} false; then :
+
+else
+  ac_cv_search_strerror=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_strerror" >&5
+$as_echo "$ac_cv_search_strerror" >&6; }
+ac_res=$ac_cv_search_strerror
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+	for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AWK+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+# Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_STRIP" && ac_cv_prog_STRIP=":"
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if ${ac_cv_header_stdc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sys/wait.h that is POSIX.1 compatible" >&5
+$as_echo_n "checking for sys/wait.h that is POSIX.1 compatible... " >&6; }
+if ${ac_cv_header_sys_wait_h+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+int
+main ()
+{
+  int s;
+  wait (&s);
+  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_sys_wait_h=yes
+else
+  ac_cv_header_sys_wait_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_sys_wait_h" >&5
+$as_echo "$ac_cv_header_sys_wait_h" >&6; }
+if test $ac_cv_header_sys_wait_h = yes; then
+
+$as_echo "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
+
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-fail-if-missing argument" >&5
+$as_echo_n "checking --enable-fail-if-missing argument... " >&6; }
+# Check whether --enable-fail_if_missing was given.
+if test "${enable_fail_if_missing+set}" = set; then :
+  enableval=$enable_fail_if_missing; fail_if_missing="yes"
+else
+  fail_if_missing="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $fail_if_missing" >&5
+$as_echo "$fail_if_missing" >&6; }
+
+if test -z "$CFLAGS"; then
+  CFLAGS="-O"
+  test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
+fi
+if test "$GCC" = yes; then
+    gccversion=`$CC -dumpversion`
+  if test "x$gccversion" = "x"; then
+        gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[^0-9]*\([0-9]\.[0-9.]*\).*$/\1/g'`
+  fi
+    if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
+    echo 'GCC [34].0.[12] has a bug in the optimizer, disabling "-O#"'
+    CFLAGS=`echo "$CFLAGS" | sed 's/-O[23456789]/-O/'`
+  else
+    if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
+      echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
+      CFLAGS="$CFLAGS -fno-strength-reduce"
+    fi
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for recent clang version" >&5
+$as_echo_n "checking for recent clang version... " >&6; }
+CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/p'`
+if test x"$CLANG_VERSION_STRING" != x"" ; then
+  CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*/\1/p'`
+  CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*/\1/p'`
+  CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.[0-9][0-9]*\.\([0-9][0-9]*\)/\1/p'`
+  CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CLANG_VERSION" >&5
+$as_echo "$CLANG_VERSION" >&6; }
+          if test "$CLANG_VERSION" -ge 500002075 ; then
+    CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+CROSS_COMPILING=
+if test "$cross_compiling" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot compile a simple program; if not cross compiling check CC and CFLAGS" >&5
+$as_echo "cannot compile a simple program; if not cross compiling check CC and CFLAGS" >&6; }
+  CROSS_COMPILING=1
+fi
+
+
+test "$GCC" = yes && CPP_MM=M;
+
+if test -f ./toolcheck; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for buggy tools..." >&5
+$as_echo "$as_me: checking for buggy tools..." >&6;}
+  sh ./toolcheck 1>&6
+fi
+
+OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BeOS" >&5
+$as_echo_n "checking for BeOS... " >&6; }
+case `uname` in
+    BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
+		BEOS=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };;
+    *)		BEOS=no; { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for QNX" >&5
+$as_echo_n "checking for QNX... " >&6; }
+case `uname` in
+    QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
+		test -z "$with_x" && with_x=no
+		QNX=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };;
+    *)		QNX=no; { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Darwin (Mac OS X)" >&5
+$as_echo_n "checking for Darwin (Mac OS X)... " >&6; }
+if test "`(uname) 2>/dev/null`" = Darwin; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-darwin argument" >&5
+$as_echo_n "checking --disable-darwin argument... " >&6; }
+  # Check whether --enable-darwin was given.
+if test "${enable_darwin+set}" = set; then :
+  enableval=$enable_darwin;
+else
+  enable_darwin="yes"
+fi
+
+  if test "$enable_darwin" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if Darwin files are there" >&5
+$as_echo_n "checking if Darwin files are there... " >&6; }
+    if test -f os_macosx.m; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, Darwin support disabled" >&5
+$as_echo "no, Darwin support disabled" >&6; }
+      enable_darwin=no
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, Darwin support excluded" >&5
+$as_echo "yes, Darwin support excluded" >&6; }
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-mac-arch argument" >&5
+$as_echo_n "checking --with-mac-arch argument... " >&6; }
+
+# Check whether --with-mac-arch was given.
+if test "${with_mac_arch+set}" = set; then :
+  withval=$with_mac_arch; MACARCH="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MACARCH" >&5
+$as_echo "$MACARCH" >&6; }
+else
+  MACARCH="current"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: defaulting to $MACARCH" >&5
+$as_echo "defaulting to $MACARCH" >&6; }
+fi
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-developer-dir argument" >&5
+$as_echo_n "checking --with-developer-dir argument... " >&6; }
+
+# Check whether --with-developer-dir was given.
+if test "${with_developer_dir+set}" = set; then :
+  withval=$with_developer_dir; DEVELOPER_DIR="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DEVELOPER_DIR" >&5
+$as_echo "$DEVELOPER_DIR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not present" >&5
+$as_echo "not present" >&6; }
+fi
+
+
+  if test "x$DEVELOPER_DIR" = "x"; then
+    # Extract the first word of "xcode-select", so it can be a program name with args.
+set dummy xcode-select; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_XCODE_SELECT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $XCODE_SELECT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_XCODE_SELECT="$XCODE_SELECT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_XCODE_SELECT="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+XCODE_SELECT=$ac_cv_path_XCODE_SELECT
+if test -n "$XCODE_SELECT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XCODE_SELECT" >&5
+$as_echo "$XCODE_SELECT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test "x$XCODE_SELECT" != "x"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for developer dir using xcode-select" >&5
+$as_echo_n "checking for developer dir using xcode-select... " >&6; }
+      DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DEVELOPER_DIR" >&5
+$as_echo "$DEVELOPER_DIR" >&6; }
+    else
+      DEVELOPER_DIR=/Developer
+    fi
+  fi
+
+  if test "x$MACARCH" = "xboth"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for 10.4 universal SDK" >&5
+$as_echo_n "checking for 10.4 universal SDK... " >&6; }
+                            save_cppflags="$CPPFLAGS"
+    save_cflags="$CFLAGS"
+    save_ldflags="$LDFLAGS"
+    CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: found" >&5
+$as_echo "found" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+	CFLAGS="$save_cflags"
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if Intel architecture is supported" >&5
+$as_echo_n "checking if Intel architecture is supported... " >&6; }
+	CPPFLAGS="$CPPFLAGS -arch i386"
+	LDFLAGS="$save_ldflags -arch i386"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; MACARCH="intel"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		MACARCH="ppc"
+		CPPFLAGS="$save_cppflags -arch ppc"
+		LDFLAGS="$save_ldflags -arch ppc"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  elif test "x$MACARCH" = "xintel"; then
+    CPPFLAGS="$CPPFLAGS -arch intel"
+    LDFLAGS="$LDFLAGS -arch intel"
+  elif test "x$MACARCH" = "xppc"; then
+    CPPFLAGS="$CPPFLAGS -arch ppc"
+    LDFLAGS="$LDFLAGS -arch ppc"
+  fi
+
+  if test "$enable_darwin" = "yes"; then
+    MACOSX=yes
+    OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
+    OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
+            CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
+
+                # On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+ac_fn_c_check_header_mongrel "$LINENO" "Carbon/Carbon.h" "ac_cv_header_Carbon_Carbon_h" "$ac_includes_default"
+if test "x$ac_cv_header_Carbon_Carbon_h" = xyes; then :
+  CARBON=yes
+fi
+
+
+    if test "x$CARBON" = "xyes"; then
+      if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
+	with_x=no
+      fi
+    fi
+  fi
+
+        if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
+    CFLAGS=`echo "$CFLAGS" | sed 's/-O[23456789]/-Oz/'`
+  fi
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+for ac_header in AvailabilityMacros.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "AvailabilityMacros.h" "ac_cv_header_AvailabilityMacros_h" "$ac_includes_default"
+if test "x$ac_cv_header_AvailabilityMacros_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_AVAILABILITYMACROS_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+if test "$cross_compiling" = no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-local-dir argument" >&5
+$as_echo_n "checking --with-local-dir argument... " >&6; }
+  have_local_include=''
+  have_local_lib=''
+
+# Check whether --with-local-dir was given.
+if test "${with_local_dir+set}" = set; then :
+  withval=$with_local_dir;
+    local_dir="$withval"
+    case "$withval" in
+    */*) ;;
+    no)
+      # avoid adding local dir to LDFLAGS and CPPFLAGS
+      have_local_include=yes
+      have_local_lib=yes
+      ;;
+    *) as_fn_error $? "must pass path argument to --with-local-dir" "$LINENO" 5 ;;
+    esac
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $local_dir" >&5
+$as_echo "$local_dir" >&6; }
+
+else
+
+    local_dir=/usr/local
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Defaulting to $local_dir" >&5
+$as_echo "Defaulting to $local_dir" >&6; }
+
+fi
+
+  if test "$GCC" = yes -a "$local_dir" != no; then
+    echo 'void f(){}' > conftest.c
+        have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+    have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
+    rm -f conftest.c conftest.o
+  fi
+  if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
+    tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
+    if test "$tt" = "$LDFLAGS"; then
+      LDFLAGS="$LDFLAGS -L${local_dir}/lib"
+    fi
+  fi
+  if test -z "$have_local_include" -a -d "${local_dir}/include"; then
+    tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
+    if test "$tt" = "$CPPFLAGS"; then
+      CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
+    fi
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-vim-name argument" >&5
+$as_echo_n "checking --with-vim-name argument... " >&6; }
+
+# Check whether --with-vim-name was given.
+if test "${with_vim_name+set}" = set; then :
+  withval=$with_vim_name; VIMNAME="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $VIMNAME" >&5
+$as_echo "$VIMNAME" >&6; }
+else
+  VIMNAME="vim"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: Defaulting to $VIMNAME" >&5
+$as_echo "Defaulting to $VIMNAME" >&6; }
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-ex-name argument" >&5
+$as_echo_n "checking --with-ex-name argument... " >&6; }
+
+# Check whether --with-ex-name was given.
+if test "${with_ex_name+set}" = set; then :
+  withval=$with_ex_name; EXNAME="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $EXNAME" >&5
+$as_echo "$EXNAME" >&6; }
+else
+  EXNAME="ex"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: Defaulting to ex" >&5
+$as_echo "Defaulting to ex" >&6; }
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-view-name argument" >&5
+$as_echo_n "checking --with-view-name argument... " >&6; }
+
+# Check whether --with-view-name was given.
+if test "${with_view_name+set}" = set; then :
+  withval=$with_view_name; VIEWNAME="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $VIEWNAME" >&5
+$as_echo "$VIEWNAME" >&6; }
+else
+  VIEWNAME="view"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: Defaulting to view" >&5
+$as_echo "Defaulting to view" >&6; }
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-global-runtime argument" >&5
+$as_echo_n "checking --with-global-runtime argument... " >&6; }
+
+# Check whether --with-global-runtime was given.
+if test "${with_global_runtime+set}" = set; then :
+  withval=$with_global_runtime; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $withval" >&5
+$as_echo "$withval" >&6; }; cat >>confdefs.h <<_ACEOF
+#define RUNTIME_GLOBAL "$withval"
+_ACEOF
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-modified-by argument" >&5
+$as_echo_n "checking --with-modified-by argument... " >&6; }
+
+# Check whether --with-modified-by was given.
+if test "${with_modified_by+set}" = set; then :
+  withval=$with_modified_by; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $withval" >&5
+$as_echo "$withval" >&6; }; cat >>confdefs.h <<_ACEOF
+#define MODIFIED_BY "$withval"
+_ACEOF
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if character set is EBCDIC" >&5
+$as_echo_n "checking if character set is EBCDIC... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+ /* TryCompile function for CharSet.
+   Treat any failure as ASCII for compatibility with existing art.
+   Use compile-time rather than run-time tests for cross-compiler
+   tolerance.  */
+#if '0'!=240
+make an error "Character set is not EBCDIC"
+#endif
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+   # TryCompile action if true
+cf_cv_ebcdic=yes
+else
+   # TryCompile action if false
+cf_cv_ebcdic=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# end of TryCompile ])
+# end of CacheVal CvEbcdic
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cf_cv_ebcdic" >&5
+$as_echo "$cf_cv_ebcdic" >&6; }
+case "$cf_cv_ebcdic" in  #(vi
+    yes)	$as_echo "#define EBCDIC 1" >>confdefs.h
+
+		line_break='"\\n"'
+		;;
+    *)		line_break='"\\012"';;
+esac
+
+
+if test "$cf_cv_ebcdic" = "yes"; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for z/OS Unix" >&5
+$as_echo_n "checking for z/OS Unix... " >&6; }
+case `uname` in
+    OS/390)	zOSUnix="yes";
+										if test "$CC" = "cc"; then
+		  ccm="$_CC_CCMODE"
+		  ccn="CC"
+		else
+		  if test "$CC" = "c89"; then
+		    ccm="$_CC_C89MODE"
+		    ccn="C89"
+		  else
+		    ccm=1
+		  fi
+		fi
+		if test "$ccm" != "1"; then
+		  echo ""
+		  echo "------------------------------------------"
+		  echo " On z/OS Unix, the environment variable"
+		  echo " _CC_${ccn}MODE must be set to \"1\"!"
+		  echo " Do:"
+		  echo "    export _CC_${ccn}MODE=1"
+		  echo " and then call configure again."
+		  echo "------------------------------------------"
+		  exit 1
+		fi
+		# Set CFLAGS for configure process.
+		# This will be reset later for config.mk.
+		# Use haltonmsg to force error for missing H files.
+		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
+		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		;;
+    *)		zOSUnix="no";
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		;;
+esac
+fi
+
+if test "$zOSUnix" = "yes"; then
+    QUOTESED="sed -e 's/[\\\\\"]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
+else
+    QUOTESED="sed -e 's/[\\\\\"]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-smack argument" >&5
+$as_echo_n "checking --disable-smack argument... " >&6; }
+# Check whether --enable-smack was given.
+if test "${enable_smack+set}" = set; then :
+  enableval=$enable_smack;
+else
+  enable_smack="yes"
+fi
+
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  ac_fn_c_check_header_mongrel "$LINENO" "linux/xattr.h" "ac_cv_header_linux_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_xattr_h" = xyes; then :
+  true
+else
+  enable_smack="no"
+fi
+
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+if test "$enable_smack" = "yes"; then
+  ac_fn_c_check_header_mongrel "$LINENO" "attr/xattr.h" "ac_cv_header_attr_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_attr_xattr_h" = xyes; then :
+  true
+else
+  enable_smack="no"
+fi
+
+
+fi
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XATTR_NAME_SMACKEXEC in linux/xattr.h" >&5
+$as_echo_n "checking for XATTR_NAME_SMACKEXEC in linux/xattr.h... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <linux/xattr.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "XATTR_NAME_SMACKEXEC" >/dev/null 2>&1; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; enable_smack="no"
+fi
+rm -f conftest*
+
+fi
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for setxattr in -lattr" >&5
+$as_echo_n "checking for setxattr in -lattr... " >&6; }
+if ${ac_cv_lib_attr_setxattr+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lattr  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char setxattr ();
+int
+main ()
+{
+return setxattr ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_attr_setxattr=yes
+else
+  ac_cv_lib_attr_setxattr=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_attr_setxattr" >&5
+$as_echo "$ac_cv_lib_attr_setxattr" >&6; }
+if test "x$ac_cv_lib_attr_setxattr" = xyes; then :
+  LIBS="$LIBS -lattr"
+	   found_smack="yes"
+	   $as_echo "#define HAVE_SMACK 1" >>confdefs.h
+
+fi
+
+fi
+
+if test "x$found_smack" = "x"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-selinux argument" >&5
+$as_echo_n "checking --disable-selinux argument... " >&6; }
+  # Check whether --enable-selinux was given.
+if test "${enable_selinux+set}" = set; then :
+  enableval=$enable_selinux;
+else
+  enable_selinux="yes"
+fi
+
+  if test "$enable_selinux" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for is_selinux_enabled in -lselinux" >&5
+$as_echo_n "checking for is_selinux_enabled in -lselinux... " >&6; }
+if ${ac_cv_lib_selinux_is_selinux_enabled+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lselinux  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char is_selinux_enabled ();
+int
+main ()
+{
+return is_selinux_enabled ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_selinux_is_selinux_enabled=yes
+else
+  ac_cv_lib_selinux_is_selinux_enabled=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
+$as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
+if test "x$ac_cv_lib_selinux_is_selinux_enabled" = xyes; then :
+  LIBS="$LIBS -lselinux"
+	     $as_echo "#define HAVE_SELINUX 1" >>confdefs.h
+
+fi
+
+  else
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-features argument" >&5
+$as_echo_n "checking --with-features argument... " >&6; }
+
+# Check whether --with-features was given.
+if test "${with_features+set}" = set; then :
+  withval=$with_features; features="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $features" >&5
+$as_echo "$features" >&6; }
+else
+  features="huge"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: Defaulting to huge" >&5
+$as_echo "Defaulting to huge" >&6; }
+fi
+
+
+dovimdiff=""
+dogvimdiff=""
+case "$features" in
+  tiny)		$as_echo "#define FEAT_TINY 1" >>confdefs.h
+ ;;
+  small)	$as_echo "#define FEAT_SMALL 1" >>confdefs.h
+ ;;
+  normal)	$as_echo "#define FEAT_NORMAL 1" >>confdefs.h
+ dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  big)		$as_echo "#define FEAT_BIG 1" >>confdefs.h
+ dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  huge)		$as_echo "#define FEAT_HUGE 1" >>confdefs.h
+ dovimdiff="installvimdiff";
+			dogvimdiff="installgvimdiff" ;;
+  *)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Sorry, $features is not supported" >&5
+$as_echo "Sorry, $features is not supported" >&6; } ;;
+esac
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-compiledby argument" >&5
+$as_echo_n "checking --with-compiledby argument... " >&6; }
+
+# Check whether --with-compiledby was given.
+if test "${with_compiledby+set}" = set; then :
+  withval=$with_compiledby; compiledby="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $withval" >&5
+$as_echo "$withval" >&6; }
+else
+  compiledby=""; { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-xsmp argument" >&5
+$as_echo_n "checking --disable-xsmp argument... " >&6; }
+# Check whether --enable-xsmp was given.
+if test "${enable_xsmp+set}" = set; then :
+  enableval=$enable_xsmp;
+else
+  enable_xsmp="yes"
+fi
+
+
+if test "$enable_xsmp" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-xsmp-interact argument" >&5
+$as_echo_n "checking --disable-xsmp-interact argument... " >&6; }
+  # Check whether --enable-xsmp-interact was given.
+if test "${enable_xsmp_interact+set}" = set; then :
+  enableval=$enable_xsmp_interact;
+else
+  enable_xsmp_interact="yes"
+fi
+
+  if test "$enable_xsmp_interact" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    $as_echo "#define USE_XSMP_INTERACT 1" >>confdefs.h
+
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-luainterp argument" >&5
+$as_echo_n "checking --enable-luainterp argument... " >&6; }
+# Check whether --enable-luainterp was given.
+if test "${enable_luainterp+set}" = set; then :
+  enableval=$enable_luainterp;
+else
+  enable_luainterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_luainterp" >&5
+$as_echo "$enable_luainterp" >&6; }
+
+if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    as_fn_error $? "cannot use Lua with tiny or small features" "$LINENO" 5
+  fi
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-lua-prefix argument" >&5
+$as_echo_n "checking --with-lua-prefix argument... " >&6; }
+
+# Check whether --with-lua_prefix was given.
+if test "${with_lua_prefix+set}" = set; then :
+  withval=$with_lua_prefix; with_lua_prefix="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_lua_prefix" >&5
+$as_echo "$with_lua_prefix" >&6; }
+else
+  with_lua_prefix="";{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  if test "X$with_lua_prefix" != "X"; then
+       vi_cv_path_lua_pfx="$with_lua_prefix"
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking LUA_PREFIX environment var" >&5
+$as_echo_n "checking LUA_PREFIX environment var... " >&6; }
+    if test "X$LUA_PREFIX" != "X"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: \"$LUA_PREFIX\"" >&5
+$as_echo "\"$LUA_PREFIX\"" >&6; }
+	vi_cv_path_lua_pfx="$LUA_PREFIX"
+    else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not set, default to /usr" >&5
+$as_echo "not set, default to /usr" >&6; }
+	vi_cv_path_lua_pfx="/usr"
+    fi
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-luajit" >&5
+$as_echo_n "checking --with-luajit... " >&6; }
+
+# Check whether --with-luajit was given.
+if test "${with_luajit+set}" = set; then :
+  withval=$with_luajit; vi_cv_with_luajit="$withval"
+else
+  vi_cv_with_luajit="no"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_with_luajit" >&5
+$as_echo "$vi_cv_with_luajit" >&6; }
+
+  LUA_INC=
+  if test "X$vi_cv_path_lua_pfx" != "X"; then
+    if test "x$vi_cv_with_luajit" != "xno"; then
+            # Extract the first word of "luajit", so it can be a program name with args.
+set dummy luajit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_luajit+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_luajit in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_luajit="$vi_cv_path_luajit" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_luajit="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_luajit=$ac_cv_path_vi_cv_path_luajit
+if test -n "$vi_cv_path_luajit"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_luajit" >&5
+$as_echo "$vi_cv_path_luajit" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+      if test "X$vi_cv_path_luajit" != "X"; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking LuaJIT version" >&5
+$as_echo_n "checking LuaJIT version... " >&6; }
+if ${vi_cv_version_luajit+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([0-9.]*\)\.[0-9]\(-[a-z0-9]*\)* .*/\1/'`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_version_luajit" >&5
+$as_echo "$vi_cv_version_luajit" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Lua version of LuaJIT" >&5
+$as_echo_n "checking Lua version of LuaJIT... " >&6; }
+if ${vi_cv_version_lua_luajit+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_version_lua_luajit" >&5
+$as_echo "$vi_cv_version_lua_luajit" >&6; }
+	vi_cv_path_lua="$vi_cv_path_luajit"
+	vi_cv_version_lua="$vi_cv_version_lua_luajit"
+      fi
+    else
+            # Extract the first word of "lua", so it can be a program name with args.
+set dummy lua; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_plain_lua+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_plain_lua in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_plain_lua="$vi_cv_path_plain_lua" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_plain_lua="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_plain_lua=$ac_cv_path_vi_cv_path_plain_lua
+if test -n "$vi_cv_path_plain_lua"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_plain_lua" >&5
+$as_echo "$vi_cv_path_plain_lua" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+      if test "X$vi_cv_path_plain_lua" != "X"; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Lua version" >&5
+$as_echo_n "checking Lua version... " >&6; }
+if ${vi_cv_version_plain_lua+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_version_plain_lua" >&5
+$as_echo "$vi_cv_version_plain_lua" >&6; }
+      fi
+      vi_cv_path_lua="$vi_cv_path_plain_lua"
+      vi_cv_version_lua="$vi_cv_version_plain_lua"
+    fi
+    if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit" >&5
+$as_echo_n "checking if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit... " >&6; }
+      if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	LUA_INC=/luajit-$vi_cv_version_luajit
+      fi
+    fi
+    if test "X$LUA_INC" = "X"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if lua.h can be found in $vi_cv_path_lua_pfx/include" >&5
+$as_echo_n "checking if lua.h can be found in $vi_cv_path_lua_pfx/include... " >&6; }
+      if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua" >&5
+$as_echo_n "checking if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua... " >&6; }
+	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	  LUA_INC=/lua$vi_cv_version_lua
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	  vi_cv_path_lua_pfx=
+	fi
+      fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_lua_pfx" != "X"; then
+    if test "x$vi_cv_with_luajit" != "xno"; then
+      multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+      if test "X$multiarch" != "X"; then
+	lib_multiarch="lib/${multiarch}"
+      else
+	lib_multiarch="lib"
+      fi
+      if test "X$vi_cv_version_lua" = "X"; then
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
+      else
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
+      fi
+    else
+      if test "X$LUA_INC" != "X"; then
+		LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
+      else
+	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
+      fi
+    fi
+    if test "$enable_luainterp" = "dynamic"; then
+      lua_ok="yes"
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if link with ${LUA_LIBS} is sane" >&5
+$as_echo_n "checking if link with ${LUA_LIBS} is sane... " >&6; }
+      libs_save=$LIBS
+      LIBS="$LIBS $LUA_LIBS"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; lua_ok="yes"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; lua_ok="no"; LUA_LIBS=""
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+      LIBS=$libs_save
+    fi
+    if test "x$lua_ok" = "xyes"; then
+      LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
+      LUA_SRC="if_lua.c"
+      LUA_OBJ="objects/if_lua.o"
+      LUA_PRO="if_lua.pro"
+      $as_echo "#define FEAT_LUA 1" >>confdefs.h
+
+    fi
+    if test "$enable_luainterp" = "dynamic"; then
+      if test "x$vi_cv_with_luajit" != "xno"; then
+	luajit="jit"
+      fi
+      if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
+	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
+      else
+	if test "x$MACOSX" = "xyes"; then
+	  ext="dylib"
+	  indexes=""
+	else
+	  ext="so"
+	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
+	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+	  if test "X$multiarch" != "X"; then
+	    lib_multiarch="lib/${multiarch}"
+	  fi
+	fi
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx" >&5
+$as_echo_n "checking if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx... " >&6; }
+	for subdir in "${lib_multiarch}" lib64 lib; do
+	  if test -z "$subdir"; then
+	    continue
+	  fi
+	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
+	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
+	    for i in $indexes ""; do
+	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
+		sover2="$i"
+		break 3
+	      fi
+	    done
+	  done
+	  sover=""
+	done
+	if test "X$sover" = "X"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	  lua_ok="no"
+	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	  lua_ok="yes"
+	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
+	fi
+      fi
+      $as_echo "#define DYNAMIC_LUA 1" >>confdefs.h
+
+      LUA_LIBS=""
+      LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
+    fi
+    if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
+       test "x$MACOSX" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
+       test "`(uname -m) 2>/dev/null`" = "x86_64"; then
+            LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
+    as_fn_error $? "could not configure lua" "$LINENO" 5
+  fi
+
+
+
+
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-mzschemeinterp argument" >&5
+$as_echo_n "checking --enable-mzschemeinterp argument... " >&6; }
+# Check whether --enable-mzschemeinterp was given.
+if test "${enable_mzschemeinterp+set}" = set; then :
+  enableval=$enable_mzschemeinterp;
+else
+  enable_mzschemeinterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_mzschemeinterp" >&5
+$as_echo "$enable_mzschemeinterp" >&6; }
+
+if test "$enable_mzschemeinterp" = "yes"; then
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-plthome argument" >&5
+$as_echo_n "checking --with-plthome argument... " >&6; }
+
+# Check whether --with-plthome was given.
+if test "${with_plthome+set}" = set; then :
+  withval=$with_plthome; with_plthome="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_plthome" >&5
+$as_echo "$with_plthome" >&6; }
+else
+  with_plthome="";{ $as_echo "$as_me:${as_lineno-$LINENO}: result: \"no\"" >&5
+$as_echo "\"no\"" >&6; }
+fi
+
+
+  if test "X$with_plthome" != "X"; then
+       vi_cv_path_mzscheme_pfx="$with_plthome"
+       vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking PLTHOME environment var" >&5
+$as_echo_n "checking PLTHOME environment var... " >&6; }
+    if test "X$PLTHOME" != "X"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: \"$PLTHOME\"" >&5
+$as_echo "\"$PLTHOME\"" >&6; }
+	vi_cv_path_mzscheme_pfx="$PLTHOME"
+	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+    else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not set" >&5
+$as_echo "not set" >&6; }
+		# Extract the first word of "mzscheme", so it can be a program name with args.
+set dummy mzscheme; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_mzscheme+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_mzscheme in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_mzscheme="$vi_cv_path_mzscheme" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_mzscheme="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_mzscheme=$ac_cv_path_vi_cv_path_mzscheme
+if test -n "$vi_cv_path_mzscheme"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_mzscheme" >&5
+$as_echo "$vi_cv_path_mzscheme" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+			if test "X$vi_cv_path_mzscheme" != "X"; then
+	  lsout=`ls -l $vi_cv_path_mzscheme`
+	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
+	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
+	  fi
+	fi
+
+	if test "X$vi_cv_path_mzscheme" != "X"; then
+	    	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking MzScheme install prefix" >&5
+$as_echo_n "checking MzScheme install prefix... " >&6; }
+if ${vi_cv_path_mzscheme_pfx+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  	    	    echo "(display (simplify-path		\
+	       (build-path (call-with-values	\
+		(lambda () (split-path (find-system-path (quote exec-file)))) \
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    	     vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_mzscheme_pfx" >&5
+$as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
+	    rm -f mzdirs.scm
+	fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for racket include directory" >&5
+$as_echo_n "checking for racket include directory... " >&6; }
+    SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_INC" != "X"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${SCHEME_INC}" >&5
+$as_echo "${SCHEME_INC}" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
+      if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt... " >&6; }
+	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket... " >&6; }
+	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
+	  else
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/plt/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
+	    if test -f /usr/include/plt/scheme.h; then
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	      SCHEME_INC=/usr/include/plt
+	    else
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/racket/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/racket/... " >&6; }
+	      if test -f /usr/include/racket/scheme.h; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		SCHEME_INC=/usr/include/racket
+	      else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		vi_cv_path_mzscheme_pfx=
+	      fi
+	    fi
+	  fi
+	fi
+      fi
+    fi
+  fi
+
+  if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for racket lib directory" >&5
+$as_echo_n "checking for racket lib directory... " >&6; }
+    SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_LIB" != "X"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${SCHEME_LIB}" >&5
+$as_echo "${SCHEME_LIB}" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+    fi
+
+    for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
+      if test "X$path" != "X"; then
+	if test "x$MACOSX" = "xyes"; then
+	  MZSCHEME_LIBS="-framework Racket"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libmzscheme3m.a"; then
+	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libracket3m.a"; then
+	  MZSCHEME_LIBS="${path}/libracket3m.a"
+	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	elif test -f "${path}/libracket.a"; then
+	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
+	elif test -f "${path}/libmzscheme.a"; then
+	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
+	else
+	  	  if test -f "${path}/libmzscheme3m.so"; then
+	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
+	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	  elif test -f "${path}/libracket3m.so"; then
+	    MZSCHEME_LIBS="-L${path} -lracket3m"
+	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+	  elif test -f "${path}/libracket.so"; then
+	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
+	  else
+	    	    if test "$path" != "$SCHEME_LIB"; then
+	      continue
+	    fi
+	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
+	  fi
+	  if test "$GCC" = yes; then
+	    	    	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
+	  elif test "`(uname) 2>/dev/null`" = SunOS &&
+				   uname -r | grep '^5' >/dev/null; then
+	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
+	  fi
+	fi
+      fi
+      if test "X$MZSCHEME_LIBS" != "X"; then
+	break
+      fi
+    done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if racket requires -pthread" >&5
+$as_echo_n "checking if racket requires -pthread... " >&6; }
+    if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+      MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for racket config directory" >&5
+$as_echo_n "checking for racket config directory... " >&6; }
+    SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
+    if test "X$SCHEME_CONFIGDIR" != "X"; then
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${SCHEME_CONFIGDIR}" >&5
+$as_echo "${SCHEME_CONFIGDIR}" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+    fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for racket collects directory" >&5
+$as_echo_n "checking for racket collects directory... " >&6; }
+    SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
+    if test "X$SCHEME_COLLECTS" = "X"; then
+      if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
+	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
+      else
+	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
+	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
+	else
+	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
+	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
+	  else
+	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
+	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
+	    fi
+	  fi
+	fi
+      fi
+    fi
+    if test "X$SCHEME_COLLECTS" != "X" ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${SCHEME_COLLECTS}" >&5
+$as_echo "${SCHEME_COLLECTS}" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+    fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for mzscheme_base.c" >&5
+$as_echo_n "checking for mzscheme_base.c... " >&6; }
+    if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+      MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+      MZSCHEME_MOD="++lib scheme/base"
+    else
+      if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+	MZSCHEME_MOD="++lib scheme/base"
+      else
+	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+	  MZSCHEME_EXTRA="mzscheme_base.c"
+	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+	  MZSCHEME_MOD=""
+	fi
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+            MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: needed" >&5
+$as_echo "needed" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not needed" >&5
+$as_echo "not needed" >&6; }
+    fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffi_type_void in -lffi" >&5
+$as_echo_n "checking for ffi_type_void in -lffi... " >&6; }
+if ${ac_cv_lib_ffi_ffi_type_void+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lffi  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ffi_type_void ();
+int
+main ()
+{
+return ffi_type_void ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_ffi_ffi_type_void=yes
+else
+  ac_cv_lib_ffi_ffi_type_void=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ffi_ffi_type_void" >&5
+$as_echo "$ac_cv_lib_ffi_ffi_type_void" >&6; }
+if test "x$ac_cv_lib_ffi_ffi_type_void" = xyes; then :
+  MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"
+fi
+
+
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
+      -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if compile and link flags for MzScheme are sane" >&5
+$as_echo_n "checking if compile and link flags for MzScheme are sane... " >&6; }
+    cflags_save=$CFLAGS
+    libs_save=$LIBS
+    CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
+    LIBS="$LIBS $MZSCHEME_LIBS"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; mzs_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: MZSCHEME DISABLED" >&5
+$as_echo "no: MZSCHEME DISABLED" >&6; }; mzs_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    CFLAGS=$cflags_save
+    LIBS=$libs_save
+    if test $mzs_ok = yes; then
+      MZSCHEME_SRC="if_mzsch.c"
+      MZSCHEME_OBJ="objects/if_mzsch.o"
+      MZSCHEME_PRO="if_mzsch.pro"
+      $as_echo "#define FEAT_MZSCHEME 1" >>confdefs.h
+
+    else
+      MZSCHEME_CFLAGS=
+      MZSCHEME_LIBS=
+      MZSCHEME_EXTRA=
+      MZSCHEME_MZC=
+    fi
+  fi
+
+
+
+
+
+
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-perlinterp argument" >&5
+$as_echo_n "checking --enable-perlinterp argument... " >&6; }
+# Check whether --enable-perlinterp was given.
+if test "${enable_perlinterp+set}" = set; then :
+  enableval=$enable_perlinterp;
+else
+  enable_perlinterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_perlinterp" >&5
+$as_echo "$enable_perlinterp" >&6; }
+if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    as_fn_error $? "cannot use Perl with tiny or small features" "$LINENO" 5
+  fi
+
+  # Extract the first word of "perl", so it can be a program name with args.
+set dummy perl; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_perl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_perl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_perl="$vi_cv_path_perl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_perl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_perl=$ac_cv_path_vi_cv_path_perl
+if test -n "$vi_cv_path_perl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_perl" >&5
+$as_echo "$vi_cv_path_perl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  if test "X$vi_cv_path_perl" != "X"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking Perl version" >&5
+$as_echo_n "checking Perl version... " >&6; }
+    if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
+     eval `$vi_cv_path_perl -V:usethreads`
+     eval `$vi_cv_path_perl -V:libperl`
+     if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
+       badthreads=no
+     else
+       if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
+	 eval `$vi_cv_path_perl -V:use5005threads`
+	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
+	   badthreads=no
+	 else
+	   badthreads=yes
+	   { $as_echo "$as_me:${as_lineno-$LINENO}: result: >>> Perl > 5.6 with 5.5 threads cannot be used <<<" >&5
+$as_echo ">>> Perl > 5.6 with 5.5 threads cannot be used <<<" >&6; }
+	 fi
+       else
+	 badthreads=yes
+	 { $as_echo "$as_me:${as_lineno-$LINENO}: result: >>> Perl 5.5 with threads cannot be used <<<" >&5
+$as_echo ">>> Perl 5.5 with threads cannot be used <<<" >&6; }
+       fi
+     fi
+     if test $badthreads = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: OK" >&5
+$as_echo "OK" >&6; }
+      eval `$vi_cv_path_perl -V:shrpenv`
+      if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
+	shrpenv=""
+      fi
+      vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
+
+      vi_cv_perl_extutils=unknown_perl_extutils_path
+      for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+	if test -f "$xsubpp_path"; then
+	  vi_cv_perl_xsubpp="$xsubpp_path"
+	fi
+      done
+
+                  perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
+	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[^ ]*//' \
+			-e 's/-fdebug-prefix-map[^ ]*//g'`
+            perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
+		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
+			-e 's/-bE:perl.exp//' -e 's/-lc //'`
+                  perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
+		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
+
+                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if compile and link flags for Perl are sane" >&5
+$as_echo_n "checking if compile and link flags for Perl are sane... " >&6; }
+      cflags_save=$CFLAGS
+      libs_save=$LIBS
+      ldflags_save=$LDFLAGS
+      CFLAGS="$CFLAGS $perlcppflags"
+      LIBS="$LIBS $perllibs"
+      perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
+      LDFLAGS="$perlldflags $LDFLAGS"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; perl_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: PERL DISABLED" >&5
+$as_echo "no: PERL DISABLED" >&6; }; perl_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+      CFLAGS=$cflags_save
+      LIBS=$libs_save
+      LDFLAGS=$ldflags_save
+      if test $perl_ok = yes; then
+	if test "X$perlcppflags" != "X"; then
+	  	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[^ ]*//'`
+	fi
+	if test "X$perlldflags" != "X"; then
+	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
+	    LDFLAGS="$perlldflags $LDFLAGS"
+	  fi
+	fi
+	PERL_LIBS=$perllibs
+	PERL_SRC="auto/if_perl.c if_perlsfio.c"
+	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
+	PERL_PRO="if_perl.pro if_perlsfio.pro"
+	$as_echo "#define FEAT_PERL 1" >>confdefs.h
+
+      fi
+     fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: >>> too old; need Perl version 5.003_01 or later <<<" >&5
+$as_echo ">>> too old; need Perl version 5.003_01 or later <<<" >&6; }
+    fi
+  fi
+
+  if test "x$MACOSX" = "xyes"; then
+        dir=/System/Library/Perl
+    darwindir=$dir/darwin
+    if test -d $darwindir; then
+      PERL=/usr/bin/perl
+    else
+            dir=/System/Library/Perl/5.8.1
+      darwindir=$dir/darwin-thread-multi-2level
+      if test -d $darwindir; then
+	PERL=/usr/bin/perl
+      fi
+    fi
+    if test -n "$PERL"; then
+      PERL_DIR="$dir"
+      PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
+      PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
+      PERL_LIBS="-L$darwindir/CORE -lperl"
+    fi
+                PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+    PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+  fi
+  if test "$enable_perlinterp" = "dynamic"; then
+    if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
+      $as_echo "#define DYNAMIC_PERL 1" >>confdefs.h
+
+      PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
+    as_fn_error $? "could not configure perl" "$LINENO" 5
+  fi
+fi
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-pythoninterp argument" >&5
+$as_echo_n "checking --enable-pythoninterp argument... " >&6; }
+# Check whether --enable-pythoninterp was given.
+if test "${enable_pythoninterp+set}" = set; then :
+  enableval=$enable_pythoninterp;
+else
+  enable_pythoninterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_pythoninterp" >&5
+$as_echo "$enable_pythoninterp" >&6; }
+if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    as_fn_error $? "cannot use Python with tiny or small features" "$LINENO" 5
+  fi
+
+    for ac_prog in python2 python
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_python+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_python in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_python="$vi_cv_path_python" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_python="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_python=$ac_cv_path_vi_cv_path_python
+if test -n "$vi_cv_path_python"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python" >&5
+$as_echo "$vi_cv_path_python" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$vi_cv_path_python" && break
+done
+
+  if test "X$vi_cv_path_python" != "X"; then
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python version" >&5
+$as_echo_n "checking Python version... " >&6; }
+if ${vi_cv_var_python_version+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  vi_cv_var_python_version=`
+	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_var_python_version" >&5
+$as_echo "$vi_cv_var_python_version" >&6; }
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python is 2.3 or better" >&5
+$as_echo_n "checking Python is 2.3 or better... " >&6; }
+    if ${vi_cv_path_python} -c \
+	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
+    then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yep" >&5
+$as_echo "yep" >&6; }
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's install prefix" >&5
+$as_echo_n "checking Python's install prefix... " >&6; }
+if ${vi_cv_path_python_pfx+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_python_pfx=`
+	    ${vi_cv_path_python} -c \
+		"import sys; print sys.prefix"`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python_pfx" >&5
+$as_echo "$vi_cv_path_python_pfx" >&6; }
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's execution prefix" >&5
+$as_echo_n "checking Python's execution prefix... " >&6; }
+if ${vi_cv_path_python_epfx+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_python_epfx=`
+	    ${vi_cv_path_python} -c \
+		"import sys; print sys.exec_prefix"`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python_epfx" >&5
+$as_echo "$vi_cv_path_python_epfx" >&6; }
+
+
+      if ${vi_cv_path_pythonpath+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_pythonpath=`
+	    unset PYTHONPATH;
+	    ${vi_cv_path_python} -c \
+		"import sys, string; print string.join(sys.path,':')"`
+fi
+
+
+
+
+# Check whether --with-python-config-dir was given.
+if test "${with_python_config_dir+set}" = set; then :
+  withval=$with_python_config_dir;  vi_cv_path_python_conf="${withval}"
+fi
+
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's configuration directory" >&5
+$as_echo_n "checking Python's configuration directory... " >&6; }
+if ${vi_cv_path_python_conf+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	vi_cv_path_python_conf=
+	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
+	if test -d "$d" && test -f "$d/config.c"; then
+	  vi_cv_path_python_conf="$d"
+	else
+	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
+	    for subdir in lib64 lib share; do
+	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
+	      if test -d "$d" && test -f "$d/config.c"; then
+		vi_cv_path_python_conf="$d"
+	      fi
+	    done
+	  done
+	fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python_conf" >&5
+$as_echo "$vi_cv_path_python_conf" >&6; }
+
+      PYTHON_CONFDIR="${vi_cv_path_python_conf}"
+
+      if test "X$PYTHON_CONFDIR" = "X"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: can't find it!" >&5
+$as_echo "can't find it!" >&6; }
+      else
+
+			if ${vi_cv_path_python_plibs+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	    pwd=`pwd`
+	    tmp_mkf="$pwd/config-PyMake$$"
+	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+__:
+	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
+	@echo "python_LIBS='$(LIBS)'"
+	@echo "python_SYSLIBS='$(SYSLIBS)'"
+	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
+	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
+	@echo "python_INSTSONAME='$(INSTSONAME)'"
+	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
+	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
+	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
+eof
+	    	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
+	    if test "x$MACOSX" = "xyes" && ${vi_cv_path_python} -c \
+		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
+	      vi_cv_path_python_plibs="-framework Python"
+	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
+	      fi
+	    else
+	      if test "${vi_cv_var_python_version}" = "1.4"; then
+		  vi_cv_path_python_plibs="${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a"
+	      else
+		  vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
+	      fi
+	      	      	      	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([^ \t][^ \t]*[ \t][ \t]*[^ \t][^ \t]*\)[ \t].*/\1/'`
+		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([^ \t][^ \t]*[ \t][ \t]*[^ \t][^ \t]*\)[ \t][ \t]*\(.*\)/\2/'`
+	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+	          		  	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
+		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+		    		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
+	            	            		  fi
+	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
+	        fi
+	      fi
+	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
+	      	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
+	    fi
+
+fi
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's dll name" >&5
+$as_echo_n "checking Python's dll name... " >&6; }
+if ${vi_cv_dll_name_python+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	  if test "X$python_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python="$python_INSTSONAME"
+	  fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_dll_name_python" >&5
+$as_echo "$vi_cv_dll_name_python" >&6; }
+
+	PYTHON_LIBS="${vi_cv_path_python_plibs}"
+	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+	else
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+	fi
+	PYTHON_SRC="if_python.c"
+	PYTHON_OBJ="objects/if_python.o"
+	if test "${vi_cv_var_python_version}" = "1.4"; then
+	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
+	fi
+    PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+
+								{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if -pthread should be used" >&5
+$as_echo_n "checking if -pthread should be used... " >&6; }
+	threadsafe_flag=
+	thread_lib=
+	        if test "`(uname) 2>/dev/null`" != Darwin; then
+	  test "$GCC" = yes && threadsafe_flag="-pthread"
+	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
+	    threadsafe_flag="-D_THREAD_SAFE"
+	    thread_lib="-pthread"
+	  fi
+	  if test "`(uname) 2>/dev/null`" = SunOS; then
+	    threadsafe_flag="-pthreads"
+	  fi
+	fi
+	libs_save_old=$LIBS
+	if test -n "$threadsafe_flag"; then
+	  cflags_save=$CFLAGS
+	  CFLAGS="$CFLAGS $threadsafe_flag"
+	  LIBS="$LIBS $thread_lib"
+	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; LIBS=$libs_save_old
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS=$cflags_save
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	fi
+
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if compile and link flags for Python are sane" >&5
+$as_echo_n "checking if compile and link flags for Python are sane... " >&6; }
+	cflags_save=$CFLAGS
+	libs_save=$LIBS
+	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+	LIBS="$LIBS $PYTHON_LIBS"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; python_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: PYTHON DISABLED" >&5
+$as_echo "no: PYTHON DISABLED" >&6; }; python_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	CFLAGS=$cflags_save
+	LIBS=$libs_save
+	if test $python_ok = yes; then
+	  $as_echo "#define FEAT_PYTHON 1" >>confdefs.h
+
+	else
+	  LIBS=$libs_save_old
+	  PYTHON_SRC=
+	  PYTHON_OBJ=
+	  PYTHON_LIBS=
+	  PYTHON_CFLAGS=
+	fi
+      fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: too old" >&5
+$as_echo "too old" >&6; }
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
+    as_fn_error $? "could not configure python" "$LINENO" 5
+  fi
+fi
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-python3interp argument" >&5
+$as_echo_n "checking --enable-python3interp argument... " >&6; }
+# Check whether --enable-python3interp was given.
+if test "${enable_python3interp+set}" = set; then :
+  enableval=$enable_python3interp;
+else
+  enable_python3interp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_python3interp" >&5
+$as_echo "$enable_python3interp" >&6; }
+if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    as_fn_error $? "cannot use Python with tiny or small features" "$LINENO" 5
+  fi
+
+    for ac_prog in python3 python
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_python3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_python3 in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_python3="$vi_cv_path_python3" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_python3="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_python3=$ac_cv_path_vi_cv_path_python3
+if test -n "$vi_cv_path_python3"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python3" >&5
+$as_echo "$vi_cv_path_python3" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$vi_cv_path_python3" && break
+done
+
+  if test "X$vi_cv_path_python3" != "X"; then
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python version" >&5
+$as_echo_n "checking Python version... " >&6; }
+if ${vi_cv_var_python3_version+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  vi_cv_var_python3_version=`
+          ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_var_python3_version" >&5
+$as_echo "$vi_cv_var_python3_version" >&6; }
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python is 3.0 or better" >&5
+$as_echo_n "checking Python is 3.0 or better... " >&6; }
+    if ${vi_cv_path_python3} -c \
+      "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
+    then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yep" >&5
+$as_echo "yep" >&6; }
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's abiflags" >&5
+$as_echo_n "checking Python's abiflags... " >&6; }
+if ${vi_cv_var_python3_abiflags+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+       vi_cv_var_python3_abiflags=
+       if ${vi_cv_path_python3} -c \
+           "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
+       then
+         vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \
+           "import sys; print(sys.abiflags)"`
+       fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_var_python3_abiflags" >&5
+$as_echo "$vi_cv_var_python3_abiflags" >&6; }
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's install prefix" >&5
+$as_echo_n "checking Python's install prefix... " >&6; }
+if ${vi_cv_path_python3_pfx+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_python3_pfx=`
+       ${vi_cv_path_python3} -c \
+       "import sys; print(sys.prefix)"`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python3_pfx" >&5
+$as_echo "$vi_cv_path_python3_pfx" >&6; }
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's execution prefix" >&5
+$as_echo_n "checking Python's execution prefix... " >&6; }
+if ${vi_cv_path_python3_epfx+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_python3_epfx=`
+       ${vi_cv_path_python3} -c \
+       "import sys; print(sys.exec_prefix)"`
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python3_epfx" >&5
+$as_echo "$vi_cv_path_python3_epfx" >&6; }
+
+
+      if ${vi_cv_path_python3path+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+   vi_cv_path_python3path=`
+       unset PYTHONPATH;
+       ${vi_cv_path_python3} -c \
+       "import sys, string; print(':'.join(sys.path))"`
+fi
+
+
+
+
+# Check whether --with-python3-config-dir was given.
+if test "${with_python3_config_dir+set}" = set; then :
+  withval=$with_python3_config_dir;  vi_cv_path_python3_conf="${withval}"
+fi
+
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's configuration directory" >&5
+$as_echo_n "checking Python's configuration directory... " >&6; }
+if ${vi_cv_path_python3_conf+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+       vi_cv_path_python3_conf=
+       config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+       d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
+       if test -d "$d" && test -f "$d/config.c"; then
+         vi_cv_path_python3_conf="$d"
+       else
+         for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
+	   for subdir in lib64 lib share; do
+	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
+	     if test -d "$d" && test -f "$d/config.c"; then
+	       vi_cv_path_python3_conf="$d"
+	     fi
+	   done
+         done
+       fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_python3_conf" >&5
+$as_echo "$vi_cv_path_python3_conf" >&6; }
+
+      PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
+
+      if test "X$PYTHON3_CONFDIR" = "X"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: can't find it!" >&5
+$as_echo "can't find it!" >&6; }
+      else
+
+                        if ${vi_cv_path_python3_plibs+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+            pwd=`pwd`
+            tmp_mkf="$pwd/config-PyMake$$"
+            cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+__:
+	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
+	@echo "python3_LIBS='$(LIBS)'"
+	@echo "python3_SYSLIBS='$(SYSLIBS)'"
+	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
+	@echo "python3_INSTSONAME='$(INSTSONAME)'"
+eof
+	    	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
+	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+	    	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+
+fi
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Python3's dll name" >&5
+$as_echo_n "checking Python3's dll name... " >&6; }
+if ${vi_cv_dll_name_python3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	  if test "X$python3_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+	  fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_dll_name_python3" >&5
+$as_echo "$vi_cv_dll_name_python3" >&6; }
+
+        PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
+        if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
+          PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+        else
+          PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+        fi
+        PYTHON3_SRC="if_python3.c"
+        PYTHON3_OBJ="objects/if_python3.o"
+
+                                                                { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -pthread should be used" >&5
+$as_echo_n "checking if -pthread should be used... " >&6; }
+        threadsafe_flag=
+        thread_lib=
+                if test "`(uname) 2>/dev/null`" != Darwin; then
+          test "$GCC" = yes && threadsafe_flag="-pthread"
+          if test "`(uname) 2>/dev/null`" = FreeBSD; then
+            threadsafe_flag="-D_THREAD_SAFE"
+            thread_lib="-pthread"
+          fi
+          if test "`(uname) 2>/dev/null`" = SunOS; then
+            threadsafe_flag="-pthreads"
+          fi
+        fi
+        libs_save_old=$LIBS
+        if test -n "$threadsafe_flag"; then
+          cflags_save=$CFLAGS
+          CFLAGS="$CFLAGS $threadsafe_flag"
+          LIBS="$LIBS $thread_lib"
+          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; LIBS=$libs_save_old
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+          CFLAGS=$cflags_save
+        else
+          { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+        fi
+
+                        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if compile and link flags for Python 3 are sane" >&5
+$as_echo_n "checking if compile and link flags for Python 3 are sane... " >&6; }
+        cflags_save=$CFLAGS
+        libs_save=$LIBS
+        CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+        LIBS="$LIBS $PYTHON3_LIBS"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; python3_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no: PYTHON3 DISABLED" >&5
+$as_echo "no: PYTHON3 DISABLED" >&6; }; python3_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        CFLAGS=$cflags_save
+        LIBS=$libs_save
+        if test "$python3_ok" = yes; then
+          $as_echo "#define FEAT_PYTHON3 1" >>confdefs.h
+
+        else
+          LIBS=$libs_save_old
+          PYTHON3_SRC=
+          PYTHON3_OBJ=
+          PYTHON3_LIBS=
+          PYTHON3_CFLAGS=
+        fi
+      fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: too old" >&5
+$as_echo "too old" >&6; }
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
+    as_fn_error $? "could not configure python3" "$LINENO" 5
+  fi
+fi
+
+
+
+
+
+
+
+if test "$python_ok" = yes && test "$python3_ok" = yes; then
+  $as_echo "#define DYNAMIC_PYTHON 1" >>confdefs.h
+
+  $as_echo "#define DYNAMIC_PYTHON3 1" >>confdefs.h
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+  libs_save=$LIBS
+    LIBS="-ldl $LIBS"
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <dlfcn.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first python version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+      if (pylib != 0)
+      {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };$as_echo "#define PY_NO_RTLD_GLOBAL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python3" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python3... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  libs_save=$LIBS
+    LIBS="-ldl $LIBS"
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first python version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };$as_echo "#define PY3_NO_RTLD_GLOBAL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+
+  PYTHON_SRC="if_python.c"
+  PYTHON_OBJ="objects/if_python.o"
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+  PYTHON_LIBS=
+  PYTHON3_SRC="if_python3.c"
+  PYTHON3_OBJ="objects/if_python3.o"
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+  PYTHON3_LIBS=
+elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
+  $as_echo "#define DYNAMIC_PYTHON 1" >>confdefs.h
+
+  PYTHON_SRC="if_python.c"
+  PYTHON_OBJ="objects/if_python.o"
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+  PYTHON_LIBS=
+elif test "$python_ok" = yes; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -fPIE can be added for Python" >&5
+$as_echo_n "checking if -fPIE can be added for Python... " >&6; }
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
+  LIBS="$LIBS $PYTHON_LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; fpie_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; fpie_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+  if test $fpie_ok = yes; then
+    PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
+  fi
+elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
+  $as_echo "#define DYNAMIC_PYTHON3 1" >>confdefs.h
+
+  PYTHON3_SRC="if_python3.c"
+  PYTHON3_OBJ="objects/if_python3.o"
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+  PYTHON3_LIBS=
+elif test "$python3_ok" = yes; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -fPIE can be added for Python3" >&5
+$as_echo_n "checking if -fPIE can be added for Python3... " >&6; }
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
+  LIBS="$LIBS $PYTHON3_LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; fpie_ok=yes
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; fpie_ok=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+  if test $fpie_ok = yes; then
+    PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-tclinterp argument" >&5
+$as_echo_n "checking --enable-tclinterp argument... " >&6; }
+# Check whether --enable-tclinterp was given.
+if test "${enable_tclinterp+set}" = set; then :
+  enableval=$enable_tclinterp;
+else
+  enable_tclinterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_tclinterp" >&5
+$as_echo "$enable_tclinterp" >&6; }
+
+if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-tclsh argument" >&5
+$as_echo_n "checking --with-tclsh argument... " >&6; }
+
+# Check whether --with-tclsh was given.
+if test "${with_tclsh+set}" = set; then :
+  withval=$with_tclsh; tclsh_name="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $tclsh_name" >&5
+$as_echo "$tclsh_name" >&6; }
+else
+  tclsh_name="tclsh8.5"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  # Extract the first word of "$tclsh_name", so it can be a program name with args.
+set dummy $tclsh_name; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_tcl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_tcl="$vi_cv_path_tcl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_tcl=$ac_cv_path_vi_cv_path_tcl
+if test -n "$vi_cv_path_tcl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_tcl" >&5
+$as_echo "$vi_cv_path_tcl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+    if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
+    tclsh_name="tclsh8.4"
+    # Extract the first word of "$tclsh_name", so it can be a program name with args.
+set dummy $tclsh_name; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_tcl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_tcl="$vi_cv_path_tcl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_tcl=$ac_cv_path_vi_cv_path_tcl
+if test -n "$vi_cv_path_tcl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_tcl" >&5
+$as_echo "$vi_cv_path_tcl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+  if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
+    tclsh_name="tclsh8.2"
+    # Extract the first word of "$tclsh_name", so it can be a program name with args.
+set dummy $tclsh_name; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_tcl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_tcl="$vi_cv_path_tcl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_tcl=$ac_cv_path_vi_cv_path_tcl
+if test -n "$vi_cv_path_tcl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_tcl" >&5
+$as_echo "$vi_cv_path_tcl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+  if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
+    tclsh_name="tclsh8.0"
+    # Extract the first word of "$tclsh_name", so it can be a program name with args.
+set dummy $tclsh_name; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_tcl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_tcl="$vi_cv_path_tcl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_tcl=$ac_cv_path_vi_cv_path_tcl
+if test -n "$vi_cv_path_tcl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_tcl" >&5
+$as_echo "$vi_cv_path_tcl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+    if test "X$vi_cv_path_tcl" = "X"; then
+    tclsh_name="tclsh"
+    # Extract the first word of "$tclsh_name", so it can be a program name with args.
+set dummy $tclsh_name; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_tcl in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_tcl="$vi_cv_path_tcl" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_tcl=$ac_cv_path_vi_cv_path_tcl
+if test -n "$vi_cv_path_tcl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_tcl" >&5
+$as_echo "$vi_cv_path_tcl" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+  if test "X$vi_cv_path_tcl" != "X"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking Tcl version" >&5
+$as_echo_n "checking Tcl version... " >&6; }
+    if echo 'exit [expr [info tclversion] < 8.0]' | "$vi_cv_path_tcl" - ; then
+      tclver=`echo 'puts [info tclversion]' | $vi_cv_path_tcl -`
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $tclver - OK" >&5
+$as_echo "$tclver - OK" >&6; };
+      tclloc=`echo 'set l [info library];set i [string last lib $l];incr i -2;puts [string range $l 0 $i]' | $vi_cv_path_tcl -`
+      tcldll=`echo 'puts libtcl[info tclversion][info sharedlibextension]' | $vi_cv_path_tcl -`
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for location of Tcl include" >&5
+$as_echo_n "checking for location of Tcl include... " >&6; }
+      if test "x$MACOSX" != "xyes"; then
+	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
+      else
+		tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
+      fi
+      TCL_INC=
+      for try in $tclinc; do
+	if test -f "$try/tcl.h"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $try/tcl.h" >&5
+$as_echo "$try/tcl.h" >&6; }
+	  TCL_INC=$try
+	  break
+	fi
+      done
+      if test -z "$TCL_INC"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: <not found>" >&5
+$as_echo "<not found>" >&6; }
+	SKIP_TCL=YES
+      fi
+      if test -z "$SKIP_TCL"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for location of tclConfig.sh script" >&5
+$as_echo_n "checking for location of tclConfig.sh script... " >&6; }
+	if test "x$MACOSX" != "xyes"; then
+	  tclcnf=`echo $tclinc | sed s/include/lib/g`
+	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
+	else
+	  	  tclcnf="/System/Library/Frameworks/Tcl.framework"
+	fi
+	for try in $tclcnf; do
+	  if test -f "$try/tclConfig.sh"; then
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $try/tclConfig.sh" >&5
+$as_echo "$try/tclConfig.sh" >&6; }
+	    . "$try/tclConfig.sh"
+	    	    if test "$enable_tclinterp" = "dynamic"; then
+	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
+	    else
+	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
+	    fi
+	    	    	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[^-]/d' -e '/^-[^D]/d' -e '/-D[^_]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
+	    break
+	  fi
+	done
+	if test -z "$TCL_LIBS"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: <not found>" >&5
+$as_echo "<not found>" >&6; }
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Tcl library by myself" >&5
+$as_echo_n "checking for Tcl library by myself... " >&6; }
+	  tcllib=`echo $tclinc | sed s/include/lib/g`
+	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
+	  for ext in .so .a ; do
+	    for ver in "" $tclver ; do
+	      for try in $tcllib ; do
+		trylib=tcl$ver$ext
+		if test -f "$try/lib$trylib" ; then
+		  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $try/lib$trylib" >&5
+$as_echo "$try/lib$trylib" >&6; }
+		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
+		  if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+		    TCL_LIBS="$TCL_LIBS -R $try"
+		  fi
+		  break 3
+		fi
+	      done
+	    done
+	  done
+	  if test -z "$TCL_LIBS"; then
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: <not found>" >&5
+$as_echo "<not found>" >&6; }
+	    SKIP_TCL=YES
+	  fi
+	fi
+	if test -z "$SKIP_TCL"; then
+	  $as_echo "#define FEAT_TCL 1" >>confdefs.h
+
+	  TCL_SRC=if_tcl.c
+	  TCL_OBJ=objects/if_tcl.o
+	  TCL_PRO=if_tcl.pro
+	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
+	fi
+      fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: too old; need Tcl version 8.0 or later" >&5
+$as_echo "too old; need Tcl version 8.0 or later" >&6; }
+    fi
+  fi
+  if test "$enable_tclinterp" = "dynamic"; then
+    if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
+      $as_echo "#define DYNAMIC_TCL 1" >>confdefs.h
+
+      TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
+    fi
+  fi
+  if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
+    as_fn_error $? "could not configure Tcl" "$LINENO" 5
+  fi
+fi
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-rubyinterp argument" >&5
+$as_echo_n "checking --enable-rubyinterp argument... " >&6; }
+# Check whether --enable-rubyinterp was given.
+if test "${enable_rubyinterp+set}" = set; then :
+  enableval=$enable_rubyinterp;
+else
+  enable_rubyinterp="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_rubyinterp" >&5
+$as_echo "$enable_rubyinterp" >&6; }
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    as_fn_error $? "cannot use Ruby with tiny or small features" "$LINENO" 5
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-ruby-command argument" >&5
+$as_echo_n "checking --with-ruby-command argument... " >&6; }
+
+
+# Check whether --with-ruby-command was given.
+if test "${with_ruby_command+set}" = set; then :
+  withval=$with_ruby_command; RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RUBY_CMD" >&5
+$as_echo "$RUBY_CMD" >&6; }
+else
+  RUBY_CMD="ruby"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: defaulting to $RUBY_CMD" >&5
+$as_echo "defaulting to $RUBY_CMD" >&6; }
+fi
+
+  # Extract the first word of "$RUBY_CMD", so it can be a program name with args.
+set dummy $RUBY_CMD; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_vi_cv_path_ruby+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $vi_cv_path_ruby in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_vi_cv_path_ruby="$vi_cv_path_ruby" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_vi_cv_path_ruby="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+vi_cv_path_ruby=$ac_cv_path_vi_cv_path_ruby
+if test -n "$vi_cv_path_ruby"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_path_ruby" >&5
+$as_echo "$vi_cv_path_ruby" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  if test "X$vi_cv_path_ruby" != "X"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking Ruby version" >&5
+$as_echo_n "checking Ruby version... " >&6; }
+    if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: OK" >&5
+$as_echo "OK" >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Ruby rbconfig" >&5
+$as_echo_n "checking Ruby rbconfig... " >&6; }
+      ruby_rbconfig="RbConfig"
+      if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
+	ruby_rbconfig="Config"
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ruby_rbconfig" >&5
+$as_echo "$ruby_rbconfig" >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking Ruby header files" >&5
+$as_echo_n "checking Ruby header files... " >&6; }
+      rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG['rubyhdrdir'] || $ruby_rbconfig::CONFIG['archdir'] || \\$hdrdir" 2>/dev/null`
+      if test "X$rubyhdrdir" != "X"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $rubyhdrdir" >&5
+$as_echo "$rubyhdrdir" >&6; }
+	RUBY_CFLAGS="-I$rubyhdrdir"
+        rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG['rubyarchhdrdir'] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG['arch']"`
+        if test -d "$rubyarchdir"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
+        fi
+        rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG['ruby_version'].gsub(/\./, '')[0,2]"`
+	if test "X$rubyversion" = "X"; then
+	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[0,2]"`
+	fi
+        RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
+	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG['LIBS']"`
+	if test "X$rubylibs" != "X"; then
+	  RUBY_LIBS="$rubylibs"
+	fi
+	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG['LIBRUBYARG'])"`
+	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG['LIBRUBY_A'])"`
+	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG['libdir'])"`
+	if test -f "$rubylibdir/$librubya"; then
+	  librubyarg="$librubyarg"
+	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+	elif test "$librubyarg" = "libruby.a"; then
+	  	  librubyarg="-lruby"
+	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+	fi
+
+	if test "X$librubyarg" != "X"; then
+	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
+	fi
+	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG['LDFLAGS']"`
+	if test "X$rubyldflags" != "X"; then
+	  	  	  	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+	  if test "X$rubyldflags" != "X"; then
+	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
+	      LDFLAGS="$rubyldflags $LDFLAGS"
+	    fi
+	  fi
+	fi
+	RUBY_SRC="if_ruby.c"
+	RUBY_OBJ="objects/if_ruby.o"
+	RUBY_PRO="if_ruby.pro"
+	$as_echo "#define FEAT_RUBY 1" >>confdefs.h
+
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG['LIBRUBY_SO']"`
+	  $as_echo "#define DYNAMIC_RUBY 1" >>confdefs.h
+
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found; disabling Ruby" >&5
+$as_echo "not found; disabling Ruby" >&6; }
+      fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: too old; need Ruby version 1.6.0 or later" >&5
+$as_echo "too old; need Ruby version 1.6.0 or later" >&6; }
+    fi
+  fi
+
+  if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
+    as_fn_error $? "could not configure Ruby" "$LINENO" 5
+  fi
+fi
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-cscope argument" >&5
+$as_echo_n "checking --enable-cscope argument... " >&6; }
+# Check whether --enable-cscope was given.
+if test "${enable_cscope+set}" = set; then :
+  enableval=$enable_cscope;
+else
+  enable_cscope="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_cscope" >&5
+$as_echo "$enable_cscope" >&6; }
+if test "$enable_cscope" = "yes"; then
+  $as_echo "#define FEAT_CSCOPE 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-workshop argument" >&5
+$as_echo_n "checking --enable-workshop argument... " >&6; }
+# Check whether --enable-workshop was given.
+if test "${enable_workshop+set}" = set; then :
+  enableval=$enable_workshop;
+else
+  enable_workshop="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_workshop" >&5
+$as_echo "$enable_workshop" >&6; }
+if test "$enable_workshop" = "yes"; then
+  $as_echo "#define FEAT_SUN_WORKSHOP 1" >>confdefs.h
+
+  WORKSHOP_SRC="workshop.c integration.c"
+
+  WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
+
+  if test "${enable_gui-xxx}" = xxx; then
+    enable_gui=motif
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-netbeans argument" >&5
+$as_echo_n "checking --disable-netbeans argument... " >&6; }
+# Check whether --enable-netbeans was given.
+if test "${enable_netbeans+set}" = set; then :
+  enableval=$enable_netbeans;
+else
+  enable_netbeans="yes"
+fi
+
+if test "$enable_netbeans" = "yes"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot use NetBeans with tiny or small features" >&5
+$as_echo "cannot use NetBeans with tiny or small features" >&6; }
+    enable_netbeans="no"
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-channel argument" >&5
+$as_echo_n "checking --disable-channel argument... " >&6; }
+# Check whether --enable-channel was given.
+if test "${enable_channel+set}" = set; then :
+  enableval=$enable_channel;
+else
+  enable_channel="yes"
+fi
+
+if test "$enable_channel" = "yes"; then
+  if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot use channels with tiny or small features" >&5
+$as_echo "cannot use channels with tiny or small features" >&6; }
+    enable_channel="no"
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  fi
+else
+  if test "$enable_netbeans" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes, netbeans also disabled" >&5
+$as_echo "yes, netbeans also disabled" >&6; }
+    enable_netbeans="no"
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  fi
+fi
+
+if test "$enable_channel" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for socket in -lsocket" >&5
+$as_echo_n "checking for socket in -lsocket... " >&6; }
+if ${ac_cv_lib_socket_socket+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char socket ();
+int
+main ()
+{
+return socket ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_socket_socket=yes
+else
+  ac_cv_lib_socket_socket=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_socket" >&5
+$as_echo "$ac_cv_lib_socket_socket" >&6; }
+if test "x$ac_cv_lib_socket_socket" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
+$as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
+if ${ac_cv_lib_nsl_gethostbyname+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gethostbyname ();
+int
+main ()
+{
+return gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
+$as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
+if test "x$ac_cv_lib_nsl_gethostbyname" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiling with process communication is possible" >&5
+$as_echo_n "checking whether compiling with process communication is possible... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+	/* Check bitfields */
+	struct nbbuf {
+	unsigned int  initDone:1;
+	ushort signmaplen;
+	};
+
+int
+main ()
+{
+
+		/* Check creating a socket. */
+		struct sockaddr_in server;
+		(void)socket(AF_INET, SOCK_STREAM, 0);
+		(void)htons(100);
+		(void)gethostbyname("microsoft.com");
+		if (errno == ECONNREFUSED)
+		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; enable_netbeans="no"; enable_channel="no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+if test "$enable_netbeans" = "yes"; then
+  $as_echo "#define FEAT_NETBEANS_INTG 1" >>confdefs.h
+
+  NETBEANS_SRC="netbeans.c"
+
+  NETBEANS_OBJ="objects/netbeans.o"
+
+fi
+if test "$enable_channel" = "yes"; then
+  $as_echo "#define FEAT_JOB_CHANNEL 1" >>confdefs.h
+
+  CHANNEL_SRC="channel.c"
+
+  CHANNEL_OBJ="objects/channel.o"
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-multibyte argument" >&5
+$as_echo_n "checking --enable-multibyte argument... " >&6; }
+# Check whether --enable-multibyte was given.
+if test "${enable_multibyte+set}" = set; then :
+  enableval=$enable_multibyte;
+else
+  enable_multibyte="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_multibyte" >&5
+$as_echo "$enable_multibyte" >&6; }
+if test "$enable_multibyte" = "yes"; then
+  $as_echo "#define FEAT_MBYTE 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-hangulinput argument" >&5
+$as_echo_n "checking --enable-hangulinput argument... " >&6; }
+# Check whether --enable-hangulinput was given.
+if test "${enable_hangulinput+set}" = set; then :
+  enableval=$enable_hangulinput;
+else
+  enable_hangulinput="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_hangulinput" >&5
+$as_echo "$enable_hangulinput" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-xim argument" >&5
+$as_echo_n "checking --enable-xim argument... " >&6; }
+# Check whether --enable-xim was given.
+if test "${enable_xim+set}" = set; then :
+  enableval=$enable_xim; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_xim" >&5
+$as_echo "$enable_xim" >&6; }
+else
+  enable_xim="auto"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: defaulting to auto" >&5
+$as_echo "defaulting to auto" >&6; }
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-fontset argument" >&5
+$as_echo_n "checking --enable-fontset argument... " >&6; }
+# Check whether --enable-fontset was given.
+if test "${enable_fontset+set}" = set; then :
+  enableval=$enable_fontset;
+else
+  enable_fontset="no"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_fontset" >&5
+$as_echo "$enable_fontset" >&6; }
+
+test -z "$with_x" && with_x=yes
+test "${enable_gui-yes}" != no -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
+if test "$with_x" = no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: defaulting to: don't HAVE_X11" >&5
+$as_echo "defaulting to: don't HAVE_X11" >&6; }
+else
+
+  # Extract the first word of "xmkmf", so it can be a program name with args.
+set dummy xmkmf; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_xmkmfpath+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $xmkmfpath in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_xmkmfpath="$xmkmfpath" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_xmkmfpath="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+xmkmfpath=$ac_cv_path_xmkmfpath
+if test -n "$xmkmfpath"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $xmkmfpath" >&5
+$as_echo "$xmkmfpath" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+$as_echo_n "checking for X... " >&6; }
+
+
+# Check whether --with-x was given.
+if test "${with_x+set}" = set; then :
+  withval=$with_x;
+fi
+
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  case $x_includes,$x_libraries in #(
+    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -f -r conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  cat >Imakefile <<'_ACEOF'
+incroot:
+	@echo incroot='${INCROOT}'
+usrlibdir:
+	@echo usrlibdir='${USRLIBDIR}'
+libdir:
+	@echo libdir='${LIBDIR}'
+_ACEOF
+  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+    for ac_var in incroot usrlibdir libdir; do
+      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
+    done
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl dylib la dll; do
+      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
+	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ac_x_includes= ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -f -r conftest.dir
+fi
+
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R7/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R7
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R7/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R7
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Xlib.h.
+  # First, try using that file with no special directory specified.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Xlib.h"; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  LIBS=$ac_save_LIBS
+for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl dylib la dll; do
+    if test -r "$ac_dir/libX11.$ac_extension"; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+case $ac_x_includes,$ac_x_libraries in #(
+  no,* | *,no | *\'*)
+    # Didn't find X, or a directory has "'" in its name.
+    ac_cv_have_x="have_x=no";; #(
+  *)
+    # Record where we found X for the cache.
+    ac_cv_have_x="have_x=yes\
+	ac_x_includes='$ac_x_includes'\
+	ac_x_libraries='$ac_x_libraries'"
+esac
+fi
+;; #(
+    *) have_x=yes;;
+  esac
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+$as_echo "$have_x" >&6; }
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes\
+	ac_x_includes='$x_includes'\
+	ac_x_libraries='$x_libraries'"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
+fi
+
+if test "$no_x" = yes; then
+  # Not all programs may use this symbol, but it does not hurt to define it.
+
+$as_echo "#define X_DISPLAY_MISSING 1" >>confdefs.h
+
+  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
+else
+  if test -n "$x_includes"; then
+    X_CFLAGS="$X_CFLAGS -I$x_includes"
+  fi
+
+  # It would also be nice to do this for all -L options, not just this one.
+  if test -n "$x_libraries"; then
+    X_LIBS="$X_LIBS -L$x_libraries"
+    # For Solaris; some versions of Sun CC require a space after -R and
+    # others require no space.  Words are not sufficient . . . .
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -R must be followed by a space" >&5
+$as_echo_n "checking whether -R must be followed by a space... " >&6; }
+    ac_xsave_LIBS=$LIBS; LIBS="$LIBS -R$x_libraries"
+    ac_xsave_c_werror_flag=$ac_c_werror_flag
+    ac_c_werror_flag=yes
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+       X_LIBS="$X_LIBS -R$x_libraries"
+else
+  LIBS="$ac_xsave_LIBS -R $x_libraries"
+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	  X_LIBS="$X_LIBS -R $x_libraries"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: neither works" >&5
+$as_echo "neither works" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    ac_c_werror_flag=$ac_xsave_c_werror_flag
+    LIBS=$ac_xsave_LIBS
+  fi
+
+  # Check for system-dependent libraries X programs must link with.
+  # Do this before checking for the system-independent R6 libraries
+  # (-lICE), since we may need -lsocket or whatever for X linking.
+
+  if test "$ISC" = yes; then
+    X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl_s -linet"
+  else
+    # Martyn Johnson says this is needed for Ultrix, if the X
+    # libraries were built with DECnet support.  And Karl Berry says
+    # the Alpha needs dnet_stub (dnet does not exist).
+    ac_xsave_LIBS="$LIBS"; LIBS="$LIBS $X_LIBS -lX11"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XOpenDisplay ();
+int
+main ()
+{
+return XOpenDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet" >&5
+$as_echo_n "checking for dnet_ntoa in -ldnet... " >&6; }
+if ${ac_cv_lib_dnet_dnet_ntoa+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldnet  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dnet_ntoa ();
+int
+main ()
+{
+return dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dnet_dnet_ntoa=yes
+else
+  ac_cv_lib_dnet_dnet_ntoa=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
+$as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
+fi
+
+    if test $ac_cv_lib_dnet_dnet_ntoa = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet_stub" >&5
+$as_echo_n "checking for dnet_ntoa in -ldnet_stub... " >&6; }
+if ${ac_cv_lib_dnet_stub_dnet_ntoa+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldnet_stub  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dnet_ntoa ();
+int
+main ()
+{
+return dnet_ntoa ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dnet_stub_dnet_ntoa=yes
+else
+  ac_cv_lib_dnet_stub_dnet_ntoa=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
+$as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
+fi
+
+    fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    LIBS="$ac_xsave_LIBS"
+
+    # msh@cis.ufl.edu says -lnsl (and -lsocket) are needed for his 386/AT,
+    # to get the SysV transport functions.
+    # Chad R. Larson says the Pyramis MIS-ES running DC/OSx (SVR4)
+    # needs -lnsl.
+    # The nsl library prevents programs from opening the X display
+    # on Irix 5.2, according to T.E. Dickey.
+    # The functions gethostbyname, getservbyname, and inet_addr are
+    # in -lbsd on LynxOS 3.0.1/i386, according to Lars Hecking.
+    ac_fn_c_check_func "$LINENO" "gethostbyname" "ac_cv_func_gethostbyname"
+if test "x$ac_cv_func_gethostbyname" = xyes; then :
+
+fi
+
+    if test $ac_cv_func_gethostbyname = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
+$as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
+if ${ac_cv_lib_nsl_gethostbyname+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gethostbyname ();
+int
+main ()
+{
+return gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
+$as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
+if test "x$ac_cv_lib_nsl_gethostbyname" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
+fi
+
+      if test $ac_cv_lib_nsl_gethostbyname = no; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lbsd" >&5
+$as_echo_n "checking for gethostbyname in -lbsd... " >&6; }
+if ${ac_cv_lib_bsd_gethostbyname+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbsd  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gethostbyname ();
+int
+main ()
+{
+return gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_bsd_gethostbyname=yes
+else
+  ac_cv_lib_bsd_gethostbyname=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_gethostbyname" >&5
+$as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
+if test "x$ac_cv_lib_bsd_gethostbyname" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
+fi
+
+      fi
+    fi
+
+    # lieder@skyler.mavd.honeywell.com says without -lsocket,
+    # socket/setsockopt and other routines are undefined under SCO ODT
+    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary
+    # on later versions), says Simon Leinen: it contains gethostby*
+    # variants that don't use the name server (or something).  -lsocket
+    # must be given before -lnsl if both are needed.  We assume that
+    # if connect needs -lnsl, so does gethostbyname.
+    ac_fn_c_check_func "$LINENO" "connect" "ac_cv_func_connect"
+if test "x$ac_cv_func_connect" = xyes; then :
+
+fi
+
+    if test $ac_cv_func_connect = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for connect in -lsocket" >&5
+$as_echo_n "checking for connect in -lsocket... " >&6; }
+if ${ac_cv_lib_socket_connect+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char connect ();
+int
+main ()
+{
+return connect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_socket_connect=yes
+else
+  ac_cv_lib_socket_connect=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_connect" >&5
+$as_echo "$ac_cv_lib_socket_connect" >&6; }
+if test "x$ac_cv_lib_socket_connect" = xyes; then :
+  X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
+fi
+
+    fi
+
+    # Guillermo Gomez says -lposix is necessary on A/UX.
+    ac_fn_c_check_func "$LINENO" "remove" "ac_cv_func_remove"
+if test "x$ac_cv_func_remove" = xyes; then :
+
+fi
+
+    if test $ac_cv_func_remove = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for remove in -lposix" >&5
+$as_echo_n "checking for remove in -lposix... " >&6; }
+if ${ac_cv_lib_posix_remove+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lposix  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char remove ();
+int
+main ()
+{
+return remove ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_posix_remove=yes
+else
+  ac_cv_lib_posix_remove=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix_remove" >&5
+$as_echo "$ac_cv_lib_posix_remove" >&6; }
+if test "x$ac_cv_lib_posix_remove" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
+fi
+
+    fi
+
+    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
+    ac_fn_c_check_func "$LINENO" "shmat" "ac_cv_func_shmat"
+if test "x$ac_cv_func_shmat" = xyes; then :
+
+fi
+
+    if test $ac_cv_func_shmat = no; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shmat in -lipc" >&5
+$as_echo_n "checking for shmat in -lipc... " >&6; }
+if ${ac_cv_lib_ipc_shmat+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lipc  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shmat ();
+int
+main ()
+{
+return shmat ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_ipc_shmat=yes
+else
+  ac_cv_lib_ipc_shmat=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ipc_shmat" >&5
+$as_echo "$ac_cv_lib_ipc_shmat" >&6; }
+if test "x$ac_cv_lib_ipc_shmat" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
+fi
+
+    fi
+  fi
+
+  # Check for libraries that X11R6 Xt/Xaw programs need.
+  ac_save_LDFLAGS=$LDFLAGS
+  test -n "$x_libraries" && LDFLAGS="$LDFLAGS -L$x_libraries"
+  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to
+  # check for ICE first), but we must link in the order -lSM -lICE or
+  # we get undefined symbols.  So assume we have SM if we have ICE.
+  # These have to be linked with before -lX11, unlike the other
+  # libraries we check for below, so use a different variable.
+  # John Interrante, Karl Berry
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for IceConnectionNumber in -lICE" >&5
+$as_echo_n "checking for IceConnectionNumber in -lICE... " >&6; }
+if ${ac_cv_lib_ICE_IceConnectionNumber+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lICE $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char IceConnectionNumber ();
+int
+main ()
+{
+return IceConnectionNumber ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_ICE_IceConnectionNumber=yes
+else
+  ac_cv_lib_ICE_IceConnectionNumber=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
+$as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = xyes; then :
+  X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
+fi
+
+  LDFLAGS=$ac_save_LDFLAGS
+
+fi
+
+
+        if test "$zOSUnix" = "yes"; then
+    CFLAGS="$CFLAGS -W c,dll"
+    LDFLAGS="$LDFLAGS -W l,dll"
+    X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
+  fi
+
+
+  if test -d "$x_includes" && test ! -d "$x_libraries"; then
+    x_libraries=`echo "$x_includes" | sed s/include/lib/`
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Corrected X libraries to $x_libraries" >&5
+$as_echo "Corrected X libraries to $x_libraries" >&6; }
+    X_LIBS="$X_LIBS -L$x_libraries"
+    if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+      X_LIBS="$X_LIBS -R $x_libraries"
+    fi
+  fi
+
+  if test -d "$x_libraries" && test ! -d "$x_includes"; then
+    x_includes=`echo "$x_libraries" | sed s/lib/include/`
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Corrected X includes to $x_includes" >&5
+$as_echo "Corrected X includes to $x_includes" >&6; }
+    X_CFLAGS="$X_CFLAGS -I$x_includes"
+  fi
+
+    X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
+    X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
+    X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
+
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if X11 header files can be found" >&5
+$as_echo_n "checking if X11 header files can be found... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/Intrinsic.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; no_x=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  CFLAGS=$cflags_save
+
+  if test "${no_x-no}" = yes; then
+    with_x=no
+  else
+    $as_echo "#define HAVE_X11 1" >>confdefs.h
+
+    X_LIB="-lXt -lX11";
+
+
+    ac_save_LDFLAGS="$LDFLAGS"
+    LDFLAGS="-L$x_libraries $LDFLAGS"
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _XdmcpAuthDoIt in -lXdmcp" >&5
+$as_echo_n "checking for _XdmcpAuthDoIt in -lXdmcp... " >&6; }
+if ${ac_cv_lib_Xdmcp__XdmcpAuthDoIt+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXdmcp -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char _XdmcpAuthDoIt ();
+int
+main ()
+{
+return _XdmcpAuthDoIt ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_Xdmcp__XdmcpAuthDoIt=yes
+else
+  ac_cv_lib_Xdmcp__XdmcpAuthDoIt=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
+$as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
+if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
+fi
+
+
+                    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for IceOpenConnection in -lICE" >&5
+$as_echo_n "checking for IceOpenConnection in -lICE... " >&6; }
+if ${ac_cv_lib_ICE_IceOpenConnection+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lICE $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char IceOpenConnection ();
+int
+main ()
+{
+return IceOpenConnection ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_ICE_IceOpenConnection=yes
+else
+  ac_cv_lib_ICE_IceOpenConnection=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
+$as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
+if test "x$ac_cv_lib_ICE_IceOpenConnection" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
+fi
+
+
+        LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XpmCreatePixmapFromData in -lXpm" >&5
+$as_echo_n "checking for XpmCreatePixmapFromData in -lXpm... " >&6; }
+if ${ac_cv_lib_Xpm_XpmCreatePixmapFromData+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXpm -lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XpmCreatePixmapFromData ();
+int
+main ()
+{
+return XpmCreatePixmapFromData ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_Xpm_XpmCreatePixmapFromData=yes
+else
+  ac_cv_lib_Xpm_XpmCreatePixmapFromData=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
+$as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
+if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = xyes; then :
+  X_PRE_LIBS="$X_PRE_LIBS -lXpm"
+fi
+
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if X11 header files implicitly declare return values" >&5
+$as_echo_n "checking if X11 header files implicitly declare return values... " >&6; }
+    cflags_save=$CFLAGS
+        if test "$GCC" = yes; then
+      CFLAGS="$CFLAGS $X_CFLAGS -Werror"
+    else
+      CFLAGS="$CFLAGS $X_CFLAGS"
+    fi
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+else
+  CFLAGS="$CFLAGS -Wno-implicit-int"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; cflags_save="$cflags_save -Wno-implicit-int"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: test failed" >&5
+$as_echo "test failed" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    CFLAGS=$cflags_save
+
+    LDFLAGS="$ac_save_LDFLAGS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of wchar_t is 2 bytes" >&5
+$as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
+    if ${ac_cv_small_wchar_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then :
+  as_fn_error $? "failed to compile test program" "$LINENO" 5
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_small_wchar_t="no"
+else
+  ac_cv_small_wchar_t="yes"
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_small_wchar_t" >&5
+$as_echo "$ac_cv_small_wchar_t" >&6; }
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      $as_echo "#define SMALL_WCHAR_T 1" >>confdefs.h
+
+    fi
+
+  fi
+fi
+
+test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" -a "x$enable_gui" != "xqt" && enable_gui=no
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-gui argument" >&5
+$as_echo_n "checking --enable-gui argument... " >&6; }
+# Check whether --enable-gui was given.
+if test "${enable_gui+set}" = set; then :
+  enableval=$enable_gui;
+else
+  enable_gui="auto"
+fi
+
+
+enable_gui_canon=`echo "_$enable_gui" | \
+	sed 's/[ _+-]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+
+SKIP_GTK2=YES
+SKIP_GTK3=YES
+SKIP_GNOME=YES
+SKIP_MOTIF=YES
+SKIP_ATHENA=YES
+SKIP_NEXTAW=YES
+SKIP_PHOTON=YES
+SKIP_CARBON=YES
+SKIP_QT=YES
+GUITYPE=NONE
+
+if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
+  SKIP_PHOTON=
+  case "$enable_gui_canon" in
+    no)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI support" >&5
+$as_echo "no GUI support" >&6; }
+		SKIP_PHOTON=YES ;;
+    yes|"")	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes - automatic GUI support" >&5
+$as_echo "yes - automatic GUI support" >&6; } ;;
+    auto)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: auto - automatic GUI support" >&5
+$as_echo "auto - automatic GUI support" >&6; } ;;
+    photon)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Photon GUI support" >&5
+$as_echo "Photon GUI support" >&6; } ;;
+    *)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Sorry, $enable_gui GUI is not supported" >&5
+$as_echo "Sorry, $enable_gui GUI is not supported" >&6; }
+		SKIP_PHOTON=YES ;;
+  esac
+
+elif test "x$MACOSX" = "xyes" -a "x$with_x" = "xno" ; then
+  SKIP_CARBON=
+  case "$enable_gui_canon" in
+    no)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI support" >&5
+$as_echo "no GUI support" >&6; }
+		SKIP_CARBON=YES ;;
+    yes|"")	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes - automatic GUI support" >&5
+$as_echo "yes - automatic GUI support" >&6; } ;;
+    auto)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: auto - Carbon GUI is outdated - disable GUI support" >&5
+$as_echo "auto - Carbon GUI is outdated - disable GUI support" >&6; }
+		SKIP_CARBON=YES ;;
+    carbon)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Carbon GUI support" >&5
+$as_echo "Carbon GUI support" >&6; } ;;
+    *)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Sorry, $enable_gui GUI is not supported" >&5
+$as_echo "Sorry, $enable_gui GUI is not supported" >&6; }
+		SKIP_CARBON=YES ;;
+  esac
+
+else
+
+  case "$enable_gui_canon" in
+    no|none)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI support" >&5
+$as_echo "no GUI support" >&6; } ;;
+    yes|""|auto)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes/auto - automatic GUI support" >&5
+$as_echo "yes/auto - automatic GUI support" >&6; }
+		SKIP_GTK2=
+		SKIP_GNOME=
+		SKIP_MOTIF=
+		SKIP_ATHENA=
+		SKIP_NEXTAW=
+		SKIP_CARBON=
+		SKIP_QT=;;
+    gtk2)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: GTK+ 2.x GUI support" >&5
+$as_echo "GTK+ 2.x GUI support" >&6; }
+		SKIP_GTK2=;;
+    gnome2)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: GNOME 2.x GUI support" >&5
+$as_echo "GNOME 2.x GUI support" >&6; }
+		SKIP_GNOME=
+		SKIP_GTK2=;;
+    gtk3)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: GTK+ 3.x GUI support" >&5
+$as_echo "GTK+ 3.x GUI support" >&6; }
+		SKIP_GTK3=;;
+    motif)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Motif GUI support" >&5
+$as_echo "Motif GUI support" >&6; }
+		SKIP_MOTIF=;;
+    athena)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Athena GUI support" >&5
+$as_echo "Athena GUI support" >&6; }
+		SKIP_ATHENA=;;
+    nextaw)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: neXtaw GUI support" >&5
+$as_echo "neXtaw GUI support" >&6; }
+		SKIP_NEXTAW=;;
+    qt)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Qt GUI support" >&5
+$as_echo "Qt GUI support" >&6; }
+    		SKIP_QT=;;
+    *)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Sorry, $enable_gui GUI is not supported" >&5
+$as_echo "Sorry, $enable_gui GUI is not supported" >&6; } ;;
+  esac
+
+fi
+
+if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
+				-a "$enable_gui_canon" != "gnome2"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for GTK+ 2" >&5
+$as_echo_n "checking whether or not to look for GTK+ 2... " >&6; }
+  # Check whether --enable-gtk2-check was given.
+if test "${enable_gtk2_check+set}" = set; then :
+  enableval=$enable_gtk2_check;
+else
+  enable_gtk2_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_gtk2_check" >&5
+$as_echo "$enable_gtk2_check" >&6; }
+  if test "x$enable_gtk2_check" = "xno"; then
+    SKIP_GTK2=YES
+    SKIP_GNOME=YES
+  fi
+fi
+
+if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for GNOME" >&5
+$as_echo_n "checking whether or not to look for GNOME... " >&6; }
+  # Check whether --enable-gnome-check was given.
+if test "${enable_gnome_check+set}" = set; then :
+  enableval=$enable_gnome_check;
+else
+  enable_gnome_check="no"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_gnome_check" >&5
+$as_echo "$enable_gnome_check" >&6; }
+  if test "x$enable_gnome_check" = "xno"; then
+    SKIP_GNOME=YES
+  fi
+fi
+
+if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for GTK+ 3" >&5
+$as_echo_n "checking whether or not to look for GTK+ 3... " >&6; }
+  # Check whether --enable-gtk3-check was given.
+if test "${enable_gtk3_check+set}" = set; then :
+  enableval=$enable_gtk3_check;
+else
+  enable_gtk3_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_gtk3_check" >&5
+$as_echo "$enable_gtk3_check" >&6; }
+  if test "x$enable_gtk3_check" = "xno"; then
+    SKIP_GTK3=YES
+  fi
+fi
+
+if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for Motif" >&5
+$as_echo_n "checking whether or not to look for Motif... " >&6; }
+  # Check whether --enable-motif-check was given.
+if test "${enable_motif_check+set}" = set; then :
+  enableval=$enable_motif_check;
+else
+  enable_motif_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_motif_check" >&5
+$as_echo "$enable_motif_check" >&6; }
+  if test "x$enable_motif_check" = "xno"; then
+    SKIP_MOTIF=YES
+  fi
+fi
+
+if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for Athena" >&5
+$as_echo_n "checking whether or not to look for Athena... " >&6; }
+  # Check whether --enable-athena-check was given.
+if test "${enable_athena_check+set}" = set; then :
+  enableval=$enable_athena_check;
+else
+  enable_athena_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_athena_check" >&5
+$as_echo "$enable_athena_check" >&6; }
+  if test "x$enable_athena_check" = "xno"; then
+    SKIP_ATHENA=YES
+  fi
+fi
+
+if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for neXtaw" >&5
+$as_echo_n "checking whether or not to look for neXtaw... " >&6; }
+  # Check whether --enable-nextaw-check was given.
+if test "${enable_nextaw_check+set}" = set; then :
+  enableval=$enable_nextaw_check;
+else
+  enable_nextaw_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_nextaw_check" >&5
+$as_echo "$enable_nextaw_check" >&6; };
+  if test "x$enable_nextaw_check" = "xno"; then
+    SKIP_NEXTAW=YES
+  fi
+fi
+
+if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not to look for Carbon" >&5
+$as_echo_n "checking whether or not to look for Carbon... " >&6; }
+  # Check whether --enable-carbon-check was given.
+if test "${enable_carbon_check+set}" = set; then :
+  enableval=$enable_carbon_check;
+else
+  enable_carbon_check="yes"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_carbon_check" >&5
+$as_echo "$enable_carbon_check" >&6; };
+  if test "x$enable_carbon_check" = "xno"; then
+    SKIP_CARBON=YES
+  fi
+fi
+
+if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Carbon GUI" >&5
+$as_echo_n "checking for Carbon GUI... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+  GUITYPE=CARBONGUI
+  if test "$VIMNAME" = "vim"; then
+    VIMNAME=Vim
+  fi
+
+  if test "x$MACARCH" = "xboth"; then
+    CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+  else
+    CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
+  fi
+
+    if test x$prefix = xNONE; then
+    prefix=/Applications
+  fi
+
+    datadir='${prefix}/Vim.app/Contents/Resources'
+
+    SKIP_GTK2=YES;
+  SKIP_GNOME=YES;
+  SKIP_MOTIF=YES;
+  SKIP_ATHENA=YES;
+  SKIP_NEXTAW=YES;
+  SKIP_PHOTON=YES;
+  SKIP_CARBON=YES;
+  SKIP_QT=YES;
+fi
+
+
+
+
+
+
+
+
+if test -z "$SKIP_GTK2"; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-gtktest argument" >&5
+$as_echo_n "checking --disable-gtktest argument... " >&6; }
+  # Check whether --enable-gtktest was given.
+if test "${enable_gtktest+set}" = set; then :
+  enableval=$enable_gtktest;
+else
+  enable_gtktest=yes
+fi
+
+  if test "x$enable_gtktest" = "xyes" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: gtk test enabled" >&5
+$as_echo "gtk test enabled" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: gtk test disabled" >&5
+$as_echo "gtk test disabled" >&6; }
+  fi
+
+  if test "X$PKG_CONFIG" = "X"; then
+    # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_PKG_CONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_PKG_CONFIG" && ac_cv_path_PKG_CONFIG="no"
+  ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+$as_echo "$PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$PKG_CONFIG" != "xno"; then
+
+  if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
+  {
+    no_gtk=""
+    if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-2.0; then
+    {
+      min_gtk_version=2.2.0
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK - version >= $min_gtk_version" >&5
+$as_echo_n "checking for GTK - version >= $min_gtk_version... " >&6; }
+                        GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3/'`
+    }
+    elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-3.0; then
+    {
+      min_gtk_version=2.2.0
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK - version >= $min_gtk_version" >&5
+$as_echo_n "checking for GTK - version >= $min_gtk_version... " >&6; }
+
+      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3/'`
+    }
+    else
+      no_gtk=yes
+    fi
+
+    if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
+    {
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $GTK_CFLAGS"
+      LIBS="$LIBS $GTK_LIBS"
+
+                        rm -f conf.gtktest
+      if test "$cross_compiling" = yes; then :
+  echo $ac_n "cross compiling; assumed OK... $ac_c"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <gtk/gtk.h>
+#include <stdio.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+int major, minor, micro;
+char *tmp_version;
+
+system ("touch conf.gtktest");
+
+/* HP/UX 9 (%@#!) writes to sscanf strings */
+tmp_version = g_strdup("$min_gtk_version");
+if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+   printf("%s, bad version string\n", "$min_gtk_version");
+   exit(1);
+ }
+
+if ((gtk_major_version > major) ||
+    ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
+    ((gtk_major_version == major) && (gtk_minor_version == minor) &&
+				     (gtk_micro_version >= micro)))
+{
+    return 0;
+}
+return 1;
+}
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  no_gtk=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+      CFLAGS="$ac_save_CFLAGS"
+      LIBS="$ac_save_LIBS"
+    }
+    fi
+    if test "x$no_gtk" = x ; then
+      if test "x$enable_gtktest" = "xyes"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&5
+$as_echo "yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&6; }
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&5
+$as_echo "found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&6; }
+      fi
+      GUI_LIB_LOC="$GTK_LIBDIR"
+		 GTK_LIBNAME="$GTK_LIBS"
+		GUI_INC_LOC="$GTK_CFLAGS"
+    else
+    {
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+      GTK_CFLAGS=""
+      GTK_LIBS=""
+      :
+    }
+    fi
+  }
+  else
+    GTK_CFLAGS=""
+    GTK_LIBS=""
+    :
+  fi
+
+
+  rm -f conf.gtktest
+
+    if test "x$GTK_CFLAGS" != "x"; then
+      SKIP_GTK3=YES
+      SKIP_ATHENA=YES
+      SKIP_NEXTAW=YES
+      SKIP_MOTIF=YES
+      SKIP_QT=YES
+      GUITYPE=GTK
+
+    fi
+  fi
+  if test "x$GUITYPE" = "xGTK"; then
+    if test "$gtk_minor_version" = 1 -a "0$gtk_micro_version" -ge 1 \
+	|| test "0$gtk_minor_version" -ge 2; then
+      $as_echo "#define HAVE_GTK_MULTIHEAD 1" >>confdefs.h
+
+    fi
+                if test -z "$SKIP_GNOME"; then
+    {
+
+
+
+
+
+
+# Check whether --with-gnome-includes was given.
+if test "${with_gnome_includes+set}" = set; then :
+  withval=$with_gnome_includes; CFLAGS="$CFLAGS -I$withval"
+
+fi
+
+
+
+# Check whether --with-gnome-libs was given.
+if test "${with_gnome_libs+set}" = set; then :
+  withval=$with_gnome_libs; LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval
+
+fi
+
+
+
+# Check whether --with-gnome was given.
+if test "${with_gnome+set}" = set; then :
+  withval=$with_gnome; if test x$withval = xyes; then
+      want_gnome=yes
+      have_gnome=yes
+    else
+      if test "x$withval" = xno; then
+	want_gnome=no
+      else
+	want_gnome=yes
+	LDFLAGS="$LDFLAGS -L$withval/lib"
+	CFLAGS="$CFLAGS -I$withval/include"
+	gnome_prefix=$withval/lib
+      fi
+    fi
+else
+  want_gnome=yes
+fi
+
+
+  if test "x$want_gnome" = xyes; then
+  {
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libgnomeui-2.0" >&5
+$as_echo_n "checking for libgnomeui-2.0... " >&6; }
+    if $PKG_CONFIG --exists libgnomeui-2.0; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+      GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
+      GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
+      GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
+
+                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for FreeBSD" >&5
+$as_echo_n "checking for FreeBSD... " >&6; }
+      if test "`(uname) 2>/dev/null`" = FreeBSD; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
+	GNOME_LIBS="$GNOME_LIBS -pthread"
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+      fi
+      have_gnome=yes
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+      if test "x" = xfail; then
+	as_fn_error $? "Could not find libgnomeui-2.0 via pkg-config" "$LINENO" 5
+      fi
+    fi
+  }
+  fi
+
+      if test "x$have_gnome" = xyes ; then
+	$as_echo "#define FEAT_GUI_GNOME 1" >>confdefs.h
+
+	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
+	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+      fi
+    }
+    fi
+  fi
+fi
+
+
+if test -z "$SKIP_GTK3"; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-gtktest argument" >&5
+$as_echo_n "checking --disable-gtktest argument... " >&6; }
+  # Check whether --enable-gtktest was given.
+if test "${enable_gtktest+set}" = set; then :
+  enableval=$enable_gtktest;
+else
+  enable_gtktest=yes
+fi
+
+  if test "x$enable_gtktest" = "xyes" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: gtk test enabled" >&5
+$as_echo "gtk test enabled" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: gtk test disabled" >&5
+$as_echo "gtk test disabled" >&6; }
+  fi
+
+  if test "X$PKG_CONFIG" = "X"; then
+    # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_PKG_CONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_PKG_CONFIG" && ac_cv_path_PKG_CONFIG="no"
+  ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+$as_echo "$PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$PKG_CONFIG" != "xno"; then
+
+  if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
+  {
+    no_gtk=""
+    if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-2.0; then
+    {
+      min_gtk_version=3.0.0
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK - version >= $min_gtk_version" >&5
+$as_echo_n "checking for GTK - version >= $min_gtk_version... " >&6; }
+                        GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3/'`
+    }
+    elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+	  && $PKG_CONFIG --exists gtk+-3.0; then
+    {
+      min_gtk_version=3.0.0
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK - version >= $min_gtk_version" >&5
+$as_echo_n "checking for GTK - version >= $min_gtk_version... " >&6; }
+
+      GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
+      GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
+      GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
+      gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+      gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\2/'`
+      gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+	     sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3/'`
+    }
+    else
+      no_gtk=yes
+    fi
+
+    if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
+    {
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $GTK_CFLAGS"
+      LIBS="$LIBS $GTK_LIBS"
+
+                        rm -f conf.gtktest
+      if test "$cross_compiling" = yes; then :
+  echo $ac_n "cross compiling; assumed OK... $ac_c"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <gtk/gtk.h>
+#include <stdio.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+int major, minor, micro;
+char *tmp_version;
+
+system ("touch conf.gtktest");
+
+/* HP/UX 9 (%@#!) writes to sscanf strings */
+tmp_version = g_strdup("$min_gtk_version");
+if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+   printf("%s, bad version string\n", "$min_gtk_version");
+   exit(1);
+ }
+
+if ((gtk_major_version > major) ||
+    ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
+    ((gtk_major_version == major) && (gtk_minor_version == minor) &&
+				     (gtk_micro_version >= micro)))
+{
+    return 0;
+}
+return 1;
+}
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  no_gtk=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+      CFLAGS="$ac_save_CFLAGS"
+      LIBS="$ac_save_LIBS"
+    }
+    fi
+    if test "x$no_gtk" = x ; then
+      if test "x$enable_gtktest" = "xyes"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&5
+$as_echo "yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&6; }
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&5
+$as_echo "found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version" >&6; }
+      fi
+      GUI_LIB_LOC="$GTK_LIBDIR"
+		 GTK_LIBNAME="$GTK_LIBS"
+		GUI_INC_LOC="$GTK_CFLAGS"
+    else
+    {
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+      GTK_CFLAGS=""
+      GTK_LIBS=""
+      :
+    }
+    fi
+  }
+  else
+    GTK_CFLAGS=""
+    GTK_LIBS=""
+    :
+  fi
+
+
+  rm -f conf.gtktest
+
+    if test "x$GTK_CFLAGS" != "x"; then
+      SKIP_GTK2=YES
+      SKIP_GNOME=YES
+      SKIP_ATHENA=YES
+      SKIP_NEXTAW=YES
+      SKIP_MOTIF=YES
+      GUITYPE=GTK
+
+      $as_echo "#define HAVE_GTK_MULTIHEAD 1" >>confdefs.h
+
+      $as_echo "#define USE_GTK3 1" >>confdefs.h
+
+    fi
+  fi
+fi
+
+if test "x$GUITYPE" = "xGTK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking version of Gdk-Pixbuf" >&5
+$as_echo_n "checking version of Gdk-Pixbuf... " >&6; }
+  gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
+  if test "x$gdk_pixbuf_version" != x ; then
+    gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
+      sed -e 's/[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*/\1/'`
+    if test "x$gdk_pixbuf_version_minor" != x -a \
+	$gdk_pixbuf_version_minor -ge 31 ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: OK." >&5
+$as_echo "OK." >&6; }
+      # Extract the first word of "glib-compile-resources", so it can be a program name with args.
+set dummy glib-compile-resources; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_GLIB_COMPILE_RESOURCES+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GLIB_COMPILE_RESOURCES in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GLIB_COMPILE_RESOURCES="$GLIB_COMPILE_RESOURCES" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GLIB_COMPILE_RESOURCES="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_GLIB_COMPILE_RESOURCES" && ac_cv_path_GLIB_COMPILE_RESOURCES="no"
+  ;;
+esac
+fi
+GLIB_COMPILE_RESOURCES=$ac_cv_path_GLIB_COMPILE_RESOURCES
+if test -n "$GLIB_COMPILE_RESOURCES"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GLIB_COMPILE_RESOURCES" >&5
+$as_echo "$GLIB_COMPILE_RESOURCES" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking glib-compile-resources" >&5
+$as_echo_n "checking glib-compile-resources... " >&6; }
+      if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
+	GLIB_COMPILE_RESOURCES=""
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot be found in PATH." >&5
+$as_echo "cannot be found in PATH." >&6; }
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: usable." >&5
+$as_echo "usable." >&6; }
+	$as_echo "#define USE_GRESOURCE 1" >>confdefs.h
+
+	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
+	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
+      fi
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not usable." >&5
+$as_echo "not usable." >&6; }
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot obtain from pkg_config." >&5
+$as_echo "cannot obtain from pkg_config." >&6; }
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-icon-cache-update argument" >&5
+$as_echo_n "checking --disable-icon-cache-update argument... " >&6; }
+  # Check whether --enable-icon_cache_update was given.
+if test "${enable_icon_cache_update+set}" = set; then :
+  enableval=$enable_icon_cache_update;
+else
+  enable_icon_cache_update="yes"
+fi
+
+  if test "$enable_icon_cache_update" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: not set" >&5
+$as_echo "not set" >&6; }
+    # Extract the first word of "gtk-update-icon-cache", so it can be a program name with args.
+set dummy gtk-update-icon-cache; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_GTK_UPDATE_ICON_CACHE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GTK_UPDATE_ICON_CACHE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GTK_UPDATE_ICON_CACHE="$GTK_UPDATE_ICON_CACHE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GTK_UPDATE_ICON_CACHE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_GTK_UPDATE_ICON_CACHE" && ac_cv_path_GTK_UPDATE_ICON_CACHE="no"
+  ;;
+esac
+fi
+GTK_UPDATE_ICON_CACHE=$ac_cv_path_GTK_UPDATE_ICON_CACHE
+if test -n "$GTK_UPDATE_ICON_CACHE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GTK_UPDATE_ICON_CACHE" >&5
+$as_echo "$GTK_UPDATE_ICON_CACHE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found in PATH." >&5
+$as_echo "not found in PATH." >&6; }
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: update disabled" >&5
+$as_echo "update disabled" >&6; }
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-desktop-database-update argument" >&5
+$as_echo_n "checking --disable-desktop-database-update argument... " >&6; }
+  # Check whether --enable-desktop_database_update was given.
+if test "${enable_desktop_database_update+set}" = set; then :
+  enableval=$enable_desktop_database_update;
+else
+  enable_desktop_database_update="yes"
+fi
+
+  if test "$enable_desktop_database_update" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: not set" >&5
+$as_echo "not set" >&6; }
+    # Extract the first word of "update-desktop-database", so it can be a program name with args.
+set dummy update-desktop-database; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_UPDATE_DESKTOP_DATABASE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $UPDATE_DESKTOP_DATABASE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_UPDATE_DESKTOP_DATABASE="$UPDATE_DESKTOP_DATABASE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_UPDATE_DESKTOP_DATABASE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_UPDATE_DESKTOP_DATABASE" && ac_cv_path_UPDATE_DESKTOP_DATABASE="no"
+  ;;
+esac
+fi
+UPDATE_DESKTOP_DATABASE=$ac_cv_path_UPDATE_DESKTOP_DATABASE
+if test -n "$UPDATE_DESKTOP_DATABASE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $UPDATE_DESKTOP_DATABASE" >&5
+$as_echo "$UPDATE_DESKTOP_DATABASE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found in PATH." >&5
+$as_echo "not found in PATH." >&6; }
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: update disabled" >&5
+$as_echo "update disabled" >&6; }
+  fi
+fi
+
+
+
+
+
+
+
+if test -z "$SKIP_MOTIF"; then
+  gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
+    GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for location of Motif GUI includes" >&5
+$as_echo_n "checking for location of Motif GUI includes... " >&6; }
+  gui_includes="`echo $x_includes|sed 's%/^/^/*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
+  GUI_INC_LOC=
+  for try in $gui_includes; do
+    if test -f "$try/Xm/Xm.h"; then
+      GUI_INC_LOC=$try
+    fi
+  done
+  if test -n "$GUI_INC_LOC"; then
+    if test "$GUI_INC_LOC" = /usr/include; then
+      GUI_INC_LOC=
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: in default path" >&5
+$as_echo "in default path" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GUI_INC_LOC" >&5
+$as_echo "$GUI_INC_LOC" >&6; }
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: <not found>" >&5
+$as_echo "<not found>" >&6; }
+    SKIP_MOTIF=YES
+  fi
+fi
+
+
+if test -z "$SKIP_MOTIF"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-motif-lib argument" >&5
+$as_echo_n "checking --with-motif-lib argument... " >&6; }
+
+# Check whether --with-motif-lib was given.
+if test "${with_motif_lib+set}" = set; then :
+  withval=$with_motif_lib;  MOTIF_LIBNAME="${withval}"
+fi
+
+
+  if test -n "$MOTIF_LIBNAME"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MOTIF_LIBNAME" >&5
+$as_echo "$MOTIF_LIBNAME" >&6; }
+    GUI_LIB_LOC=
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+        GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for location of Motif GUI libs" >&5
+$as_echo_n "checking for location of Motif GUI libs... " >&6; }
+    gui_libs="`echo $x_libraries|sed 's%/^/^/*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
+    GUI_LIB_LOC=
+    for try in $gui_libs; do
+      for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
+	if test -f "$libtry"; then
+	  GUI_LIB_LOC=$try
+	fi
+      done
+    done
+    if test -n "$GUI_LIB_LOC"; then
+            if test "$GUI_LIB_LOC" = /usr/lib \
+	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
+	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
+	GUI_LIB_LOC=
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: in default path" >&5
+$as_echo "in default path" >&6; }
+      else
+	if test -n "$GUI_LIB_LOC"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GUI_LIB_LOC" >&5
+$as_echo "$GUI_LIB_LOC" >&6; }
+	  if test "`(uname) 2>/dev/null`" = SunOS &&
+					 uname -r | grep '^5' >/dev/null; then
+	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
+	  fi
+	fi
+      fi
+      MOTIF_LIBNAME=-lXm
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: <not found>" >&5
+$as_echo "<not found>" >&6; }
+      SKIP_MOTIF=YES
+    fi
+  fi
+fi
+
+if test -z "$SKIP_MOTIF"; then
+  SKIP_ATHENA=YES
+  SKIP_NEXTAW=YES
+  SKIP_QT=YES
+  GUITYPE=MOTIF
+
+fi
+
+
+GUI_X_LIBS=
+
+if test -z "$SKIP_ATHENA"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if Athena header files can be found" >&5
+$as_echo_n "checking if Athena header files can be found... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <X11/Intrinsic.h>
+#include <X11/Xaw/Paned.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; SKIP_ATHENA=YES
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  CFLAGS=$cflags_save
+fi
+
+if test -z "$SKIP_ATHENA"; then
+  GUITYPE=ATHENA
+fi
+
+if test -z "$SKIP_NEXTAW"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if neXtaw header files can be found" >&5
+$as_echo_n "checking if neXtaw header files can be found... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <X11/Intrinsic.h>
+#include <X11/neXtaw/Paned.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; SKIP_NEXTAW=YES
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  CFLAGS=$cflags_save
+fi
+
+if test -z "$SKIP_NEXTAW"; then
+  GUITYPE=NEXTAW
+fi
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+      if test -n "$GUI_INC_LOC"; then
+    GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
+  fi
+  if test -n "$GUI_LIB_LOC"; then
+    GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
+  fi
+
+    ldflags_save=$LDFLAGS
+  LDFLAGS="$X_LIBS $LDFLAGS"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XShapeQueryExtension in -lXext" >&5
+$as_echo_n "checking for XShapeQueryExtension in -lXext... " >&6; }
+if ${ac_cv_lib_Xext_XShapeQueryExtension+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXext -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XShapeQueryExtension ();
+int
+main ()
+{
+return XShapeQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_Xext_XShapeQueryExtension=yes
+else
+  ac_cv_lib_Xext_XShapeQueryExtension=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
+$as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = xyes; then :
+  GUI_X_LIBS="-lXext"
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for wslen in -lw" >&5
+$as_echo_n "checking for wslen in -lw... " >&6; }
+if ${ac_cv_lib_w_wslen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lw $GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char wslen ();
+int
+main ()
+{
+return wslen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_w_wslen=yes
+else
+  ac_cv_lib_w_wslen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_w_wslen" >&5
+$as_echo "$ac_cv_lib_w_wslen" >&6; }
+if test "x$ac_cv_lib_w_wslen" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlsym in -ldl" >&5
+$as_echo_n "checking for dlsym in -ldl... " >&6; }
+if ${ac_cv_lib_dl_dlsym+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl $GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlsym ();
+int
+main ()
+{
+return dlsym ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlsym=yes
+else
+  ac_cv_lib_dl_dlsym=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlsym" >&5
+$as_echo "$ac_cv_lib_dl_dlsym" >&6; }
+if test "x$ac_cv_lib_dl_dlsym" = xyes; then :
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XmuCreateStippledPixmap in -lXmu" >&5
+$as_echo_n "checking for XmuCreateStippledPixmap in -lXmu... " >&6; }
+if ${ac_cv_lib_Xmu_XmuCreateStippledPixmap+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXmu $GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XmuCreateStippledPixmap ();
+int
+main ()
+{
+return XmuCreateStippledPixmap ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_Xmu_XmuCreateStippledPixmap=yes
+else
+  ac_cv_lib_Xmu_XmuCreateStippledPixmap=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
+$as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
+if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = xyes; then :
+  GUI_X_LIBS="-lXmu $GUI_X_LIBS"
+fi
+
+  if test -z "$SKIP_MOTIF"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XpEndJob in -lXp" >&5
+$as_echo_n "checking for XpEndJob in -lXp... " >&6; }
+if ${ac_cv_lib_Xp_XpEndJob+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXp $GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XpEndJob ();
+int
+main ()
+{
+return XpEndJob ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_Xp_XpEndJob=yes
+else
+  ac_cv_lib_Xp_XpEndJob=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xp_XpEndJob" >&5
+$as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
+if test "x$ac_cv_lib_Xp_XpEndJob" = xyes; then :
+  GUI_X_LIBS="-lXp $GUI_X_LIBS"
+fi
+
+  fi
+  LDFLAGS=$ldflags_save
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for extra X11 defines" >&5
+$as_echo_n "checking for extra X11 defines... " >&6; }
+  NARROW_PROTO=
+  rm -fr conftestdir
+  if mkdir conftestdir; then
+    cd conftestdir
+    cat > Imakefile <<'EOF'
+acfindx:
+	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
+EOF
+    if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+      eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+    fi
+    cd ..
+    rm -fr conftestdir
+  fi
+  if test -z "$NARROW_PROTO"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NARROW_PROTO" >&5
+$as_echo "$NARROW_PROTO" >&6; }
+  fi
+
+fi
+
+if test "$enable_xsmp" = "yes"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  for ac_header in X11/SM/SMlib.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "X11/SM/SMlib.h" "ac_cv_header_X11_SM_SMlib_h" "$ac_includes_default"
+if test "x$ac_cv_header_X11_SM_SMlib_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_X11_SM_SMLIB_H 1
+_ACEOF
+
+fi
+
+done
+
+  CPPFLAGS=$cppflags_save
+fi
+
+
+if test -z "$SKIP_QT" -a -z "$DONT_FIND_QT"; then
+    ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+    ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CXX+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CXX+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if ${ac_cv_cxx_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if ${ac_cv_prog_cxx_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
+else
+  CXXFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+else
+  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+    QT_FOUND="no"
+    QT_MIN_VERSION="4.7.0"
+
+    # Disable xim - Qt will decide on this
+    enable_xim="no"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-qt-qmake argument" >&5
+$as_echo_n "checking --with-qt-qmake argument... " >&6; }
+
+# Check whether --with-qt-qmake was given.
+if test "${with_qt_qmake+set}" = set; then :
+  withval=$with_qt_qmake;  QMAKE="${withval}"
+fi
+
+
+    if test -n "$QMAKE"; then
+
+    	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $QMAKE" >&5
+$as_echo_n "checking for $QMAKE... " >&6; }
+	if test ! -x "$QMAKE"; then
+            as_fn_error $? "\"Unable to find the given qmake $QMAKE\"" "$LINENO" 5
+	fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+        #
+        # Find qmake
+        # 1. First look for "qmake4" in the PATH - some systems use the name qmake(Qt3) and qmake4(Qt4)
+        # 2. If qmake4 is not found then look for qmake-qt4 in the PATH
+	# 3. Look for qmake in the PATH
+        # 4. Look for "qmake", outside the path, in the following locations
+        QT_BIN_PATH="/usr/lib64/qt4/bin:/usr/local/lib64/qt4/bin:/usr/lib/qt4/bin:/usr/local/lib/qt4/bin"
+
+        # Extract the first word of "qmake4", so it can be a program name with args.
+set dummy qmake4; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake-qt4", so it can be a program name with args.
+set dummy qmake-qt4; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake", so it can be a program name with args.
+set dummy qmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake", so it can be a program name with args.
+set dummy qmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $QT_BIN_PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            as_fn_error $? "\"Unable to find qmake\"" "$LINENO" 5
+        fi
+
+    fi
+
+    #
+    # Check Qt version >= 4.7.0
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking Qt version" >&5
+$as_echo_n "checking Qt version... " >&6; }
+    QT_VERSION=`$QMAKE -query QT_VERSION | cut -f1`
+    if test  "$QT_VERSION" \< "$QT_MIN_VERSION" ; then
+       as_fn_error $? "\"Qt version is too old - need at least $QT_MIN_VERSION\"" "$LINENO" 5
+    fi
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QT_VERSION" >&5
+$as_echo "$QT_VERSION" >&6; }
+
+    QT_INSTALL_BINS=`$QMAKE -query QT_INSTALL_BINS | cut -f1`
+    QT_MOC="$QT_INSTALL_BINS/moc"
+    if test ! -x "$QT_MOC"; then
+    	as_fn_error $? "\"Unable to find the given Qt moc $QT_MOC\"" "$LINENO" 5
+    fi
+    QT_RCC="$QT_INSTALL_BINS/rcc"
+    if test ! -x "$QT_RCC"; then
+    	as_fn_error $? "\"Unable to find the given Qt rcc $QT_RCC\"" "$LINENO" 5
+    fi
+
+    #
+    # Call qmake to generate bogus project
+    #
+    # What we do here is call qmake to generate a valid Makefile and
+    # then extract the Qt compiler flags from the generated Makefile
+    #
+    TMPDIR=/tmp
+    tmp=`(umask 077 && mktemp -d -q "$TMPDIR/test-vim-qt-XXXXXXXX") 2>/dev/null`;
+    if test -z "$tmp" -a -d "$tmp"; then
+	as_fn_error $? "Unable to create temporary directory" "$LINENO" 5
+    fi
+
+cat > $tmp/qttest.cpp << EOF
+#include <QApplication>
+int main(int ac, char **av) {
+    QApplication app(ac, av);
+    return app.exec();
+}
+EOF
+
+    # Extract the first word of "gmake", so it can be a program name with args.
+set dummy gmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_MAKE_P+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAKE_P in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MAKE_P="$MAKE_P" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_MAKE_P="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+MAKE_P=$ac_cv_path_MAKE_P
+if test -n "$MAKE_P"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAKE_P" >&5
+$as_echo "$MAKE_P" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test -z "$MAKE_P"; then
+    	MAKE_P="make"
+
+    else
+        # Extract the first word of "gmake", so it can be a program name with args.
+set dummy gmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_MAKE_P+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAKE_P in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MAKE_P="$MAKE_P" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_MAKE_P="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+MAKE_P=$ac_cv_path_MAKE_P
+if test -n "$MAKE_P"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAKE_P" >&5
+$as_echo "$MAKE_P" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    fi
+    echo "$MAKE_P"
+
+    # Generate qmake project
+    qmake_try=`cd $tmp; $QMAKE -project -o test.pro`
+    { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$qt_try\""; } >&5
+  (eval $qt_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+    if test x"$ac_status" != x0; then
+        as_fn_error $? "qmake failed" "$LINENO" 5
+    fi
+
+    # Qt Modules
+    echo "QT += network" >> $tmp/test.pro
+    if test ! "5.0.0" \> "$QT_VERSION" ; then
+    	# Qt5 needs QtWidgets
+	echo "QT += widgets" >> $tmp/test.pro
+    fi
+
+
+    # generate Makefile
+    qmake_try=`cd $tmp; $QMAKE`
+    { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$qt_try\""; } >&5
+  (eval $qt_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+    if test x"$ac_status" != x0; then
+        as_fn_error $? "qmake failed" "$LINENO" 5
+    fi
+
+    #
+    # A dummy Makefile to help extract the
+    # real parameters
+    #
+cat > $tmp/makefile.dummy << EOF
+def: info
+include $tmp/Makefile
+info:
+	@echo "CXXFLAGS = \$(CXXFLAGS)"
+	@echo "CFLAGS = \$(CFLAGS)"
+	@echo "LFLAGS = \$(LFLAGS)"
+	@echo "LIBS = \$(LIBS)"
+	@echo "INCPATH = \$(INCPATH)"
+EOF
+
+    # LIBS
+    QT_LIBS=`$MAKE_P -f $tmp/makefile.dummy |grep LIBS.*= | awk '{sub(/^LIBS +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        as_fn_error $? "Unable to find Qt libraries" "$LINENO" 5
+    fi
+
+    # Include directives
+    QT_INCPATH=`$MAKE_P -f $tmp/makefile.dummy |grep INCPATH.*= | awk '{sub(/^INCPATH +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        as_fn_error $? "Unable to find Qt include path" "$LINENO" 5
+    fi
+
+    # LFLAGS
+    QT_LFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep LFLAGS.*= | awk '{sub(/^LFLAGS +=/, ""); print}'`
+    if test -z "$QT_LFLAGS"; then
+        as_fn_error $? "Unable to find Qt link flags" "$LINENO" 5
+    fi
+
+    # Qt CXXFLAGS
+    QT_CXXFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CXXFLAGS.*= | awk '{sub(/^CXXFLAGS +=/, ""); print}'`
+    QT_CXXFLAGS=`echo "$QT_CXXFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_LFLAGS"; then
+        as_fn_error $? "Unable to find Qt C flags" "$LINENO" 5
+    fi
+
+    # Qt CFLAGS
+    QT_CFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CFLAGS.*= | awk '{sub(/^CFLAGS +=/, ""); print}'`
+    QT_CFLAGS=`echo "$QT_CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_CFLAGS"; then
+        as_fn_error $? "Unable to find Qt C++ flags" "$LINENO" 5
+    fi
+
+    LDFLAGS="$LDFLAGS $QT_LFLAGS -lstdc++"
+
+
+
+
+
+
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+    # Remove temp directory
+    rm $tmp/Makefile
+    rm $tmp/qttest.cpp
+    rm $tmp/test.pro
+    rm $tmp/makefile.dummy
+    rmdir $tmp
+fi
+
+if test -z "$SKIP_QT"; then
+  GUITYPE=QT
+  GUI_X_LIBS=
+fi
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
+    cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  for ac_header in X11/xpm.h X11/Sunkeysym.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+    if test ! "$enable_xim" = "no"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XIMText in X11/Xlib.h" >&5
+$as_echo_n "checking for XIMText in X11/Xlib.h... " >&6; }
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "XIMText" >/dev/null 2>&1; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no; xim has been disabled" >&5
+$as_echo "no; xim has been disabled" >&6; }; enable_xim="no"
+fi
+rm -f conftest*
+
+  fi
+  CPPFLAGS=$cppflags_save
+
+    if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
+		-a "x$GUITYPE" != "xNONE" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: X GUI selected; xim has been enabled" >&5
+$as_echo "X GUI selected; xim has been enabled" >&6; }
+    enable_xim="yes"
+  fi
+fi
+
+if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X11/Xmu/Editres.h" >&5
+$as_echo_n "checking for X11/Xmu/Editres.h... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <X11/Intrinsic.h>
+#include <X11/Xmu/Editres.h>
+int
+main ()
+{
+int i; i = 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		      $as_echo "#define HAVE_X11_XMU_EDITRES_H 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  CPPFLAGS=$cppflags_save
+fi
+
+if test -z "$SKIP_MOTIF"; then
+  cppflags_save=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  if test "$zOSUnix" = "yes"; then
+	xmheader="Xm/Xm.h"
+  else
+	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
+	   Xm/UnhighlightT.h Xm/Notebook.h"
+  fi
+  for ac_header in $xmheader
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+  if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XpmAttributes_21 in Xm/XpmP.h" >&5
+$as_echo_n "checking for XpmAttributes_21 in Xm/XpmP.h... " >&6; }
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <Xm/XpmP.h>
+int
+main ()
+{
+XpmAttributes_21 attr;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define XPMATTRIBUTES_TYPE XpmAttributes_21" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; $as_echo "#define XPMATTRIBUTES_TYPE XpmAttributes" >>confdefs.h
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  else
+    $as_echo "#define XPMATTRIBUTES_TYPE XpmAttributes" >>confdefs.h
+
+  fi
+  CPPFLAGS=$cppflags_save
+fi
+
+if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI selected; xim has been disabled" >&5
+$as_echo "no GUI selected; xim has been disabled" >&6; }
+  enable_xim="no"
+fi
+if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI selected; fontset has been disabled" >&5
+$as_echo "no GUI selected; fontset has been disabled" >&6; }
+  enable_fontset="no"
+fi
+if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: GTK+ 2 GUI selected; fontset has been disabled" >&5
+$as_echo "GTK+ 2 GUI selected; fontset has been disabled" >&6; }
+  enable_fontset="no"
+fi
+
+if test -z "$SKIP_PHOTON"; then
+  GUITYPE=PHOTONGUI
+fi
+
+
+
+
+
+
+if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
+  as_fn_error $? "cannot use workshop without Motif" "$LINENO" 5
+fi
+
+if test "$enable_xim" = "yes"; then
+  $as_echo "#define FEAT_XIM 1" >>confdefs.h
+
+fi
+if test "$enable_fontset" = "yes"; then
+  $as_echo "#define FEAT_XFONTSET 1" >>confdefs.h
+
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for CYGWIN or MSYS environment" >&5
+$as_echo_n "checking for CYGWIN or MSYS environment... " >&6; }
+case `uname` in
+    CYGWIN*|MSYS*)    CYGWIN=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for CYGWIN clipboard support" >&5
+$as_echo_n "checking for CYGWIN clipboard support... " >&6; }
+                if test "x$with_x" = "xno" ; then
+                  OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
+                  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+                  $as_echo "#define FEAT_CYGWIN_WIN32_CLIPBOARD 1" >>confdefs.h
+
+                else
+                  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no - using X11" >&5
+$as_echo "no - using X11" >&6; }
+                fi ;;
+
+    *)          CYGWIN=no; { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };;
+esac
+
+if test "$enable_hangulinput" = "yes"; then
+  if test "x$GUITYPE" = "xNONE"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no GUI selected; hangul input has been disabled" >&5
+$as_echo "no GUI selected; hangul input has been disabled" >&6; }
+    enable_hangulinput=no
+  else
+    $as_echo "#define FEAT_HANGULIN 1" >>confdefs.h
+
+    HANGULIN_SRC=hangulin.c
+
+    HANGULIN_OBJ=objects/hangulin.o
+
+  fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether toupper is broken" >&5
+$as_echo_n "checking whether toupper is broken... " >&6; }
+if ${vim_cv_toupper_broken+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+    as_fn_error $? "cross-compiling: please set 'vim_cv_toupper_broken'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#include <ctype.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+    vim_cv_toupper_broken=yes
+
+else
+
+    vim_cv_toupper_broken=no
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_toupper_broken" >&5
+$as_echo "$vim_cv_toupper_broken" >&6; }
+
+if test "x$vim_cv_toupper_broken" = "xyes" ; then
+  $as_echo "#define BROKEN_TOUPPER 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether __DATE__ and __TIME__ work" >&5
+$as_echo_n "checking whether __DATE__ and __TIME__ work... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+printf("(" __DATE__ " " __TIME__ ")");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_DATE_TIME 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether __attribute__((unused)) is allowed" >&5
+$as_echo_n "checking whether __attribute__((unused)) is allowed... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+int x __attribute__((unused));
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_ATTRIBUTE_UNUSED 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+ac_fn_c_check_header_mongrel "$LINENO" "elf.h" "ac_cv_header_elf_h" "$ac_includes_default"
+if test "x$ac_cv_header_elf_h" = xyes; then :
+  HAS_ELF=1
+fi
+
+
+if test "$HAS_ELF" = 1; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lelf" >&5
+$as_echo_n "checking for main in -lelf... " >&6; }
+if ${ac_cv_lib_elf_main+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lelf  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_elf_main=yes
+else
+  ac_cv_lib_elf_main=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_elf_main" >&5
+$as_echo "$ac_cv_lib_elf_main" >&6; }
+if test "x$ac_cv_lib_elf_main" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBELF 1
+_ACEOF
+
+  LIBS="-lelf $LIBS"
+
+fi
+
+fi
+
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
+  as_ac_Header=`$as_echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_hdr that defines DIR" >&5
+$as_echo_n "checking for $ac_hdr that defines DIR... " >&6; }
+if eval \${$as_ac_Header+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <$ac_hdr>
+
+int
+main ()
+{
+if ((DIR *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$as_ac_Header=yes"
+else
+  eval "$as_ac_Header=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$as_ac_Header
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
+_ACEOF
+
+ac_header_dirent=$ac_hdr; break
+fi
+
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
+$as_echo_n "checking for library containing opendir... " >&6; }
+if ${ac_cv_search_opendir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char opendir ();
+int
+main ()
+{
+return opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' dir; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_opendir=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_opendir+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_opendir+:} false; then :
+
+else
+  ac_cv_search_opendir=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir" >&5
+$as_echo "$ac_cv_search_opendir" >&6; }
+ac_res=$ac_cv_search_opendir
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
+$as_echo_n "checking for library containing opendir... " >&6; }
+if ${ac_cv_search_opendir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char opendir ();
+int
+main ()
+{
+return opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' x; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_opendir=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_opendir+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_opendir+:} false; then :
+
+else
+  ac_cv_search_opendir=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir" >&5
+$as_echo "$ac_cv_search_opendir" >&6; }
+ac_res=$ac_cv_search_opendir
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+fi
+
+
+if test $ac_cv_header_sys_wait_h = no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sys/wait.h that defines union wait" >&5
+$as_echo_n "checking for sys/wait.h that defines union wait... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/wait.h>
+int
+main ()
+{
+union wait xx, yy; xx = yy
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+			$as_echo "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
+
+			$as_echo "#define HAVE_UNION_WAIT 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+for ac_header in stdint.h stdlib.h string.h \
+	sys/select.h sys/utsname.h termcap.h fcntl.h \
+	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
+	termio.h iconv.h inttypes.h langinfo.h math.h \
+	unistd.h stropts.h errno.h sys/resource.h \
+	sys/systeminfo.h locale.h sys/stream.h termios.h \
+	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
+	utime.h sys/param.h libintl.h libgen.h \
+	util/debug.h util/msg18n.h frame.h sys/acl.h \
+	sys/access.h sys/sysinfo.h wchar.h wctype.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in sys/ptem.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "sys/ptem.h" "ac_cv_header_sys_ptem_h" "#if defined HAVE_SYS_STREAM_H
+#  include <sys/stream.h>
+#endif
+"
+if test "x$ac_cv_header_sys_ptem_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_PTEM_H 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in sys/sysctl.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif
+"
+if test "x$ac_cv_header_sys_sysctl_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_SYSCTL_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_np.h" >&5
+$as_echo_n "checking for pthread_np.h... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <pthread.h>
+#include <pthread_np.h>
+int
+main ()
+{
+int i; i = 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		      $as_echo "#define HAVE_PTHREAD_NP_H 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+for ac_header in strings.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "strings.h" "ac_cv_header_strings_h" "$ac_includes_default"
+if test "x$ac_cv_header_strings_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_STRINGS_H 1
+_ACEOF
+
+fi
+
+done
+
+if test "x$MACOSX" = "xyes"; then
+    $as_echo "#define NO_STRINGS_WITH_STRING_H 1" >>confdefs.h
+
+else
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if strings.h can be included after string.h" >&5
+$as_echo_n "checking if strings.h can be included after string.h... " >&6; }
+cppflags_save=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
+# define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
+			/* but don't do it on AIX 5.1 (Uribarri) */
+#endif
+#ifdef HAVE_XM_XM_H
+# include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if defined(HAVE_STRINGS_H)
+# include <strings.h>
+#endif
+
+int
+main ()
+{
+int i; i = 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  $as_echo "#define NO_STRINGS_WITH_STRING_H 1" >>confdefs.h
+
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+CPPFLAGS=$cppflags_save
+fi
+
+if test $ac_cv_c_compiler_gnu = yes; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC needs -traditional" >&5
+$as_echo_n "checking whether $CC needs -traditional... " >&6; }
+if ${ac_cv_prog_gcc_traditional+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sgtty.h>
+Autoconf TIOCGETP
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then :
+  ac_cv_prog_gcc_traditional=yes
+else
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <termio.h>
+Autoconf TCGETA
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then :
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_gcc_traditional" >&5
+$as_echo "$ac_cv_prog_gcc_traditional" >&6; }
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
+$as_echo_n "checking for an ANSI C-conforming const... " >&6; }
+if ${ac_cv_c_const+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this sort of thing.  */
+  typedef int charset[2];
+  const charset cs = { 0, 0 };
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_const=yes
+else
+  ac_cv_c_const=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_const" >&5
+$as_echo "$ac_cv_c_const" >&6; }
+if test $ac_cv_c_const = no; then
+
+$as_echo "#define const /**/" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working volatile" >&5
+$as_echo_n "checking for working volatile... " >&6; }
+if ${ac_cv_c_volatile+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+volatile int x;
+int * volatile y = (int *) 0;
+return !x && !y;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_volatile=yes
+else
+  ac_cv_c_volatile=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_volatile" >&5
+$as_echo "$ac_cv_c_volatile" >&6; }
+if test $ac_cv_c_volatile = no; then
+
+$as_echo "#define volatile /**/" >>confdefs.h
+
+fi
+
+ac_fn_c_check_type "$LINENO" "mode_t" "ac_cv_type_mode_t" "$ac_includes_default"
+if test "x$ac_cv_type_mode_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define mode_t int
+_ACEOF
+
+fi
+
+ac_fn_c_check_type "$LINENO" "off_t" "ac_cv_type_off_t" "$ac_includes_default"
+if test "x$ac_cv_type_off_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long int
+_ACEOF
+
+fi
+
+ac_fn_c_check_type "$LINENO" "pid_t" "ac_cv_type_pid_t" "$ac_includes_default"
+if test "x$ac_cv_type_pid_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define pid_t int
+_ACEOF
+
+fi
+
+ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
+if test "x$ac_cv_type_size_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for uid_t in sys/types.h" >&5
+$as_echo_n "checking for uid_t in sys/types.h... " >&6; }
+if ${ac_cv_type_uid_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "uid_t" >/dev/null 2>&1; then :
+  ac_cv_type_uid_t=yes
+else
+  ac_cv_type_uid_t=no
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_uid_t" >&5
+$as_echo "$ac_cv_type_uid_t" >&6; }
+if test $ac_cv_type_uid_t = no; then
+
+$as_echo "#define uid_t int" >>confdefs.h
+
+
+$as_echo "#define gid_t int" >>confdefs.h
+
+fi
+
+ac_fn_c_find_uintX_t "$LINENO" "32" "ac_cv_c_uint32_t"
+case $ac_cv_c_uint32_t in #(
+  no|yes) ;; #(
+  *)
+
+$as_echo "#define _UINT32_T 1" >>confdefs.h
+
+
+cat >>confdefs.h <<_ACEOF
+#define uint32_t $ac_cv_c_uint32_t
+_ACEOF
+;;
+  esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether time.h and sys/time.h may both be included" >&5
+$as_echo_n "checking whether time.h and sys/time.h may both be included... " >&6; }
+if ${ac_cv_header_time+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+int
+main ()
+{
+if ((struct tm *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_time=yes
+else
+  ac_cv_header_time=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_time" >&5
+$as_echo "$ac_cv_header_time" >&6; }
+if test $ac_cv_header_time = yes; then
+
+$as_echo "#define TIME_WITH_SYS_TIME 1" >>confdefs.h
+
+fi
+
+ac_fn_c_check_type "$LINENO" "ino_t" "ac_cv_type_ino_t" "$ac_includes_default"
+if test "x$ac_cv_type_ino_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define ino_t long
+_ACEOF
+
+fi
+
+ac_fn_c_check_type "$LINENO" "dev_t" "ac_cv_type_dev_t" "$ac_includes_default"
+if test "x$ac_cv_type_dev_t" = xyes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define dev_t unsigned
+_ACEOF
+
+fi
+
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
+$as_echo_n "checking whether byte ordering is bigendian... " >&6; }
+if ${ac_cv_c_bigendian+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_bigendian=unknown
+    # See if we're dealing with a universal compiler.
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __APPLE_CC__
+	       not a universal capable compiler
+	     #endif
+	     typedef int dummy;
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+	# Check for potential -arch flags.  It is not universal unless
+	# there are at least two -arch flags with different values.
+	ac_arch=
+	ac_prev=
+	for ac_word in $CC $CFLAGS $CPPFLAGS $LDFLAGS; do
+	 if test -n "$ac_prev"; then
+	   case $ac_word in
+	     i?86 | x86_64 | ppc | ppc64)
+	       if test -z "$ac_arch" || test "$ac_arch" = "$ac_word"; then
+		 ac_arch=$ac_word
+	       else
+		 ac_cv_c_bigendian=universal
+		 break
+	       fi
+	       ;;
+	   esac
+	   ac_prev=
+	 elif test "x$ac_word" = "x-arch"; then
+	   ac_prev=arch
+	 fi
+       done
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if sys/param.h defines the BYTE_ORDER macro.
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+	     #include <sys/param.h>
+
+int
+main ()
+{
+#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \
+		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \
+		     && LITTLE_ENDIAN)
+	      bogus endian macros
+	     #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+		#include <sys/param.h>
+
+int
+main ()
+{
+#if BYTE_ORDER != BIG_ENDIAN
+		 not big endian
+		#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_bigendian=yes
+else
+  ac_cv_c_bigendian=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+    if test $ac_cv_c_bigendian = unknown; then
+      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+
+int
+main ()
+{
+#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
+	      bogus endian macros
+	     #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  # It does; now see whether it defined to _BIG_ENDIAN or not.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+
+int
+main ()
+{
+#ifndef _BIG_ENDIAN
+		 not big endian
+		#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_bigendian=yes
+else
+  ac_cv_c_bigendian=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+    if test $ac_cv_c_bigendian = unknown; then
+      # Compile a test program.
+      if test "$cross_compiling" = yes; then :
+  # Try to guess by grepping values from an object file.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+short int ascii_mm[] =
+		  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+		short int ascii_ii[] =
+		  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+		int use_ascii (int i) {
+		  return ascii_mm[i] + ascii_ii[i];
+		}
+		short int ebcdic_ii[] =
+		  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+		short int ebcdic_mm[] =
+		  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+		int use_ebcdic (int i) {
+		  return ebcdic_mm[i] + ebcdic_ii[i];
+		}
+		extern int foo;
+
+int
+main ()
+{
+return use_ascii (foo) == use_ebcdic (foo);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then
+	      ac_cv_c_bigendian=yes
+	    fi
+	    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+	      if test "$ac_cv_c_bigendian" = unknown; then
+		ac_cv_c_bigendian=no
+	      else
+		# finding both strings is unlikely to happen, but who knows?
+		ac_cv_c_bigendian=unknown
+	      fi
+	    fi
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+
+	     /* Are we little or big endian?  From Harbison&Steele.  */
+	     union
+	     {
+	       long int l;
+	       char c[sizeof (long int)];
+	     } u;
+	     u.l = 1;
+	     return u.c[sizeof (long int) - 1] == 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_c_bigendian=no
+else
+  ac_cv_c_bigendian=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_bigendian" >&5
+$as_echo "$ac_cv_c_bigendian" >&6; }
+ case $ac_cv_c_bigendian in #(
+   yes)
+     $as_echo "#define WORDS_BIGENDIAN 1" >>confdefs.h
+;; #(
+   no)
+      ;; #(
+   universal)
+
+$as_echo "#define AC_APPLE_UNIVERSAL_BUILD 1" >>confdefs.h
+
+     ;; #(
+   *)
+     as_fn_error $? "unknown endianness
+ presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
+ esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
+$as_echo_n "checking for inline... " >&6; }
+if ${ac_cv_c_inline+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_inline=$ac_kw
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
+$as_echo "$ac_cv_c_inline" >&6; }
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for rlim_t" >&5
+$as_echo_n "checking for rlim_t... " >&6; }
+if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: (cached) $ac_cv_type_rlim_t" >&5
+$as_echo "(cached) $ac_cv_type_rlim_t" >&6; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then :
+  ac_cv_type_rlim_t=yes
+else
+  ac_cv_type_rlim_t=no
+fi
+rm -f conftest*
+
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_rlim_t" >&5
+$as_echo "$ac_cv_type_rlim_t" >&6; }
+fi
+if test $ac_cv_type_rlim_t = no; then
+  cat >> confdefs.h <<\EOF
+#define rlim_t unsigned long
+EOF
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for stack_t" >&5
+$as_echo_n "checking for stack_t... " >&6; }
+if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: (cached) $ac_cv_type_stack_t" >&5
+$as_echo "(cached) $ac_cv_type_stack_t" >&6; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <signal.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "stack_t" >/dev/null 2>&1; then :
+  ac_cv_type_stack_t=yes
+else
+  ac_cv_type_stack_t=no
+fi
+rm -f conftest*
+
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_stack_t" >&5
+$as_echo "$ac_cv_type_stack_t" >&6; }
+fi
+if test $ac_cv_type_stack_t = no; then
+  cat >> confdefs.h <<\EOF
+#define stack_t struct sigaltstack
+EOF
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stack_t has an ss_base field" >&5
+$as_echo_n "checking whether stack_t has an ss_base field... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <signal.h>
+#include "confdefs.h"
+
+int
+main ()
+{
+stack_t sigstk; sigstk.ss_base = 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SS_BASE 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+olibs="$LIBS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-tlib argument" >&5
+$as_echo_n "checking --with-tlib argument... " >&6; }
+
+# Check whether --with-tlib was given.
+if test "${with_tlib+set}" = set; then :
+  withval=$with_tlib;
+fi
+
+if test -n "$with_tlib"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_tlib" >&5
+$as_echo "$with_tlib" >&6; }
+  LIBS="$LIBS -l$with_tlib"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for linking with $with_tlib library" >&5
+$as_echo_n "checking for linking with $with_tlib library... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: OK" >&5
+$as_echo "OK" >&6; }
+else
+  as_fn_error $? "FAILED" "$LINENO" 5
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    olibs="$LIBS"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: empty: automatic terminal library selection" >&5
+$as_echo "empty: automatic terminal library selection" >&6; }
+                case "`uname -s 2>/dev/null`" in
+	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+	*)	tlibs="tinfo ncurses termlib termcap curses";;
+  esac
+  for libname in $tlibs; do
+    as_ac_Lib=`$as_echo "ac_cv_lib_${libname}''_tgetent" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for tgetent in -l${libname}" >&5
+$as_echo_n "checking for tgetent in -l${libname}... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-l${libname}  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char tgetent ();
+int
+main ()
+{
+return tgetent ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
+_ACEOF
+
+  LIBS="-l${libname} $LIBS"
+
+fi
+
+    if test "x$olibs" != "x$LIBS"; then
+                        if test "$cross_compiling" = yes; then :
+  res="FAIL"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  res="OK"
+else
+  res="FAIL"
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+      if test "$res" = "OK"; then
+	break
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $libname library is not usable" >&5
+$as_echo "$libname library is not usable" >&6; }
+      LIBS="$olibs"
+    fi
+  done
+  if test "x$olibs" = "x$LIBS"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no terminal library found" >&5
+$as_echo "no terminal library found" >&6; }
+  fi
+fi
+
+if test "x$olibs" = "x$LIBS"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for tgetent()" >&5
+$as_echo_n "checking for tgetent()... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  as_fn_error $? "NOT FOUND!
+      You need to install a terminal library; for example ncurses.
+      Or specify the name of the library with --with-tlib." "$LINENO" 5
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we talk terminfo" >&5
+$as_echo_n "checking whether we talk terminfo... " >&6; }
+if ${vim_cv_terminfo+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+      as_fn_error $? "cross-compiling: please set 'vim_cv_terminfo'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main()
+{char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+      vim_cv_terminfo=no
+
+else
+
+      vim_cv_terminfo=yes
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_terminfo" >&5
+$as_echo "$vim_cv_terminfo" >&6; }
+
+if test "x$vim_cv_terminfo" = "xyes" ; then
+  $as_echo "#define TERMINFO 1" >>confdefs.h
+
+fi
+
+if test "x$olibs" != "x$LIBS"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking what tgetent() returns for an unknown terminal" >&5
+$as_echo_n "checking what tgetent() returns for an unknown terminal... " >&6; }
+if ${vim_cv_tgent+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+      if test "$cross_compiling" = yes; then :
+
+	as_fn_error $? "failed to compile test program." "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main()
+{char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+	vim_cv_tgent=zero
+
+else
+
+	vim_cv_tgent=non-zero
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_tgent" >&5
+$as_echo "$vim_cv_tgent" >&6; }
+
+  if test "x$vim_cv_tgent" = "xzero" ; then
+    $as_echo "#define TGETENT_ZERO_ERR 0" >>confdefs.h
+
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether termcap.h contains ospeed" >&5
+$as_echo_n "checking whether termcap.h contains ospeed... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+
+int
+main ()
+{
+ospeed = 20000
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_OSPEED 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ospeed can be extern" >&5
+$as_echo_n "checking whether ospeed can be extern... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+extern short ospeed;
+
+int
+main ()
+{
+ospeed = 20000
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define OSPEED_EXTERN 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether termcap.h contains UP, BC and PC" >&5
+$as_echo_n "checking whether termcap.h contains UP, BC and PC... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+
+int
+main ()
+{
+if (UP == 0 && BC == 0) PC = 1
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_UP_BC_PC 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether UP, BC and PC can be extern" >&5
+$as_echo_n "checking whether UP, BC and PC can be extern... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+extern char *UP, *BC, PC;
+
+int
+main ()
+{
+if (UP == 0 && BC == 0) PC = 1
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define UP_BC_PC_EXTERN 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether tputs() uses outfuntype" >&5
+$as_echo_n "checking whether tputs() uses outfuntype... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_TERMCAP_H
+# include <termcap.h>
+#endif
+
+int
+main ()
+{
+extern int xx(); tputs("test", 1, (outfuntype)xx)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_OUTFUNTYPE 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether sys/select.h and sys/time.h may both be included" >&5
+$as_echo_n "checking whether sys/select.h and sys/time.h may both be included... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/select.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+			$as_echo "#define SYS_SELECT_WITH_SYS_TIME 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for /dev/ptc" >&5
+$as_echo_n "checking for /dev/ptc... " >&6; }
+if test -r /dev/ptc; then
+  $as_echo "#define HAVE_DEV_PTC 1" >>confdefs.h
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SVR4 ptys" >&5
+$as_echo_n "checking for SVR4 ptys... " >&6; }
+if test -c /dev/ptmx ; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+ptsname(0);grantpt(0);unlockpt(0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SVR4_PTYS 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ptyranges" >&5
+$as_echo_n "checking for ptyranges... " >&6; }
+if test -d /dev/ptym ; then
+  pdir='/dev/ptym'
+else
+  pdir='/dev'
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef M_UNIX
+   yes;
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then :
+  ptys=`echo /dev/ptyp??`
+else
+  ptys=`echo $pdir/pty??`
+fi
+rm -f conftest*
+
+if test "$ptys" != "$pdir/pty??" ; then
+  p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
+  p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
+  cat >>confdefs.h <<_ACEOF
+#define PTYRANGE0 "$p0"
+_ACEOF
+
+  cat >>confdefs.h <<_ACEOF
+#define PTYRANGE1 "$p1"
+_ACEOF
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $p0 / $p1" >&5
+$as_echo "$p0 / $p1" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: don't know" >&5
+$as_echo "don't know" >&6; }
+fi
+
+rm -f conftest_grp
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking default tty permissions/group" >&5
+$as_echo_n "checking default tty permissions/group... " >&6; }
+if ${vim_cv_tty_group+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+      as_fn_error $? "cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/stat.h>
+#include <stdio.h>
+main()
+{
+  struct stat sb;
+  char *x,*ttyname();
+  int om, m;
+  FILE *fp;
+
+  if (!(x = ttyname(0))) exit(1);
+  if (stat(x, &sb)) exit(1);
+  om = sb.st_mode;
+  if (om & 002) exit(0);
+  m = system("mesg y");
+  if (m == -1 || m == 127) exit(1);
+  if (stat(x, &sb)) exit(1);
+  m = sb.st_mode;
+  if (chmod(x, om)) exit(1);
+  if (m & 002) exit(0);
+  if (sb.st_gid == getgid()) exit(1);
+  if (!(fp=fopen("conftest_grp", "w")))
+    exit(1);
+  fprintf(fp, "%d\n", sb.st_gid);
+  fclose(fp);
+  exit(0);
+}
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+      if test -f conftest_grp; then
+	vim_cv_tty_group=`cat conftest_grp`
+	if test "x$vim_cv_tty_mode" = "x" ; then
+	  vim_cv_tty_mode=0620
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group" >&5
+$as_echo "pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group" >&6; }
+      else
+	vim_cv_tty_group=world
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: ptys are world accessible" >&5
+$as_echo "ptys are world accessible" >&6; }
+      fi
+
+else
+
+      vim_cv_tty_group=world
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: can't determine - assume ptys are world accessible" >&5
+$as_echo "can't determine - assume ptys are world accessible" >&6; }
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_tty_group" >&5
+$as_echo "$vim_cv_tty_group" >&6; }
+rm -f conftest_grp
+
+if test "x$vim_cv_tty_group" != "xworld" ; then
+  cat >>confdefs.h <<_ACEOF
+#define PTYGROUP $vim_cv_tty_group
+_ACEOF
+
+  if test "x$vim_cv_tty_mode" = "x" ; then
+    as_fn_error $? "It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)" "$LINENO" 5
+  else
+    $as_echo "#define PTYMODE 0620" >>confdefs.h
+
+  fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking return type of signal handlers" >&5
+$as_echo_n "checking return type of signal handlers... " >&6; }
+if ${ac_cv_type_signal+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+
+int
+main ()
+{
+return *(signal (0, 0)) (0) == 1;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_type_signal=int
+else
+  ac_cv_type_signal=void
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_signal" >&5
+$as_echo "$ac_cv_type_signal" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+if test $ac_cv_type_signal = void; then
+  $as_echo "#define SIGRETURN return" >>confdefs.h
+
+else
+  $as_echo "#define SIGRETURN return 0" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct sigcontext" >&5
+$as_echo_n "checking for struct sigcontext... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <signal.h>
+test_sig()
+{
+    struct sigcontext *scont;
+    scont = (struct sigcontext *)0;
+    return 1;
+}
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		$as_echo "#define HAVE_SIGCONTEXT 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking getcwd implementation is broken" >&5
+$as_echo_n "checking getcwd implementation is broken... " >&6; }
+if ${vim_cv_getcwd_broken+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+      as_fn_error $? "cross-compiling: please set 'vim_cv_getcwd_broken'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+char *dagger[] = { "IFS=pwd", 0 };
+main()
+{
+  char buffer[500];
+  extern char **environ;
+  environ = dagger;
+  return getcwd(buffer, 500) ? 0 : 1;
+}
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+      vim_cv_getcwd_broken=no
+
+else
+
+      vim_cv_getcwd_broken=yes
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_getcwd_broken" >&5
+$as_echo "$vim_cv_getcwd_broken" >&6; }
+
+if test "x$vim_cv_getcwd_broken" = "xyes" ; then
+  $as_echo "#define BAD_GETCWD 1" >>confdefs.h
+
+fi
+
+for ac_func in bcmp fchdir fchown fsync getcwd getpseudotty \
+	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
+	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
+	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
+	sigvec strcasecmp strerror strftime stricmp strncasecmp \
+	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
+	usleep utime utimes
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGEFILE_SOURCE value needed for large files" >&5
+$as_echo_n "checking for _LARGEFILE_SOURCE value needed for large files... " >&6; }
+if ${ac_cv_sys_largefile_source+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h> /* for off_t */
+     #include <stdio.h>
+int
+main ()
+{
+int (*fp) (FILE *, off_t, int) = fseeko;
+     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_sys_largefile_source=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _LARGEFILE_SOURCE 1
+#include <sys/types.h> /* for off_t */
+     #include <stdio.h>
+int
+main ()
+{
+int (*fp) (FILE *, off_t, int) = fseeko;
+     return fseeko (stdin, 0, 0) && fp (stdin, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_sys_largefile_source=1; break
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  ac_cv_sys_largefile_source=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_source" >&5
+$as_echo "$ac_cv_sys_largefile_source" >&6; }
+case $ac_cv_sys_largefile_source in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGEFILE_SOURCE $ac_cv_sys_largefile_source
+_ACEOF
+;;
+esac
+rm -rf conftest*
+
+# We used to try defining _XOPEN_SOURCE=500 too, to work around a bug
+# in glibc 2.1.3, but that breaks too many other things.
+# If you want fseeko and ftello with glibc, upgrade to a fixed glibc.
+if test $ac_cv_sys_largefile_source != unknown; then
+
+$as_echo "#define HAVE_FSEEKO 1" >>confdefs.h
+
+fi
+
+
+# Check whether --enable-largefile was given.
+if test "${enable_largefile+set}" = set; then :
+  enableval=$enable_largefile;
+fi
+
+if test "$enable_largefile" != no; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
+$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
+if ${ac_cv_sys_largefile_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_sys_largefile_CC=no
+     if test "$GCC" != yes; then
+       ac_save_CC=$CC
+       while :; do
+	 # IRIX 6.2 and later do not support large files by default,
+	 # so use the C compiler's -n32 option if that helps.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 CC="$CC -n32"
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_largefile_CC=' -n32'; break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 break
+       done
+       CC=$ac_save_CC
+       rm -f conftest.$ac_ext
+    fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
+$as_echo "$ac_cv_sys_largefile_CC" >&6; }
+  if test "$ac_cv_sys_largefile_CC" != no; then
+    CC=$CC$ac_cv_sys_largefile_CC
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
+if ${ac_cv_sys_file_offset_bits+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=64; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_file_offset_bits=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
+$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
+case $ac_cv_sys_file_offset_bits in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  if test $ac_cv_sys_file_offset_bits = unknown; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
+$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
+if ${ac_cv_sys_large_files+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _LARGE_FILES 1
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=1; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_large_files=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
+$as_echo "$ac_cv_sys_large_files" >&6; }
+case $ac_cv_sys_large_files in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGE_FILES $ac_cv_sys_large_files
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  fi
+
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for st_blksize" >&5
+$as_echo_n "checking for st_blksize... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/stat.h>
+int
+main ()
+{
+	struct stat st;
+	int n;
+
+	stat("/", &st);
+	n = (int)st.st_blksize;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_ST_BLKSIZE 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stat() ignores a trailing slash" >&5
+$as_echo_n "checking whether stat() ignores a trailing slash... " >&6; }
+if ${vim_cv_stat_ignores_slash+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+      as_fn_error $? "cross-compiling: please set 'vim_cv_stat_ignores_slash'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include "confdefs.h"
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#include <sys/types.h>
+#include <sys/stat.h>
+main() {struct stat st;  exit(stat("configure/", &st) != 0); }
+
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+      vim_cv_stat_ignores_slash=yes
+
+else
+
+      vim_cv_stat_ignores_slash=no
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_stat_ignores_slash" >&5
+$as_echo "$vim_cv_stat_ignores_slash" >&6; }
+
+if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
+  $as_echo "#define STAT_IGNORES_SLASH 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for iconv_open()" >&5
+$as_echo_n "checking for iconv_open()... " >&6; }
+save_LIBS="$LIBS"
+LIBS="$LIBS -liconv"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_ICONV_H
+# include <iconv.h>
+#endif
+
+int
+main ()
+{
+iconv_open("fr", "to");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes; with -liconv" >&5
+$as_echo "yes; with -liconv" >&6; }; $as_echo "#define HAVE_ICONV 1" >>confdefs.h
+
+else
+  LIBS="$save_LIBS"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_ICONV_H
+# include <iconv.h>
+#endif
+
+int
+main ()
+{
+iconv_open("fr", "to");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_ICONV 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for nl_langinfo(CODESET)" >&5
+$as_echo_n "checking for nl_langinfo(CODESET)... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_LANGINFO_H
+# include <langinfo.h>
+#endif
+
+int
+main ()
+{
+char *cs = nl_langinfo(CODESET);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_NL_LANGINFO_CODESET 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for strtod in -lm" >&5
+$as_echo_n "checking for strtod in -lm... " >&6; }
+if ${ac_cv_lib_m_strtod+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char strtod ();
+int
+main ()
+{
+return strtod ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_m_strtod=yes
+else
+  ac_cv_lib_m_strtod=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_strtod" >&5
+$as_echo "$ac_cv_lib_m_strtod" >&6; }
+if test "x$ac_cv_lib_m_strtod" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for strtod() and other floating point functions" >&5
+$as_echo_n "checking for strtod() and other floating point functions... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+char *s; double d;
+    d = strtod("1.1", &s);
+    d = fabs(1.11);
+    d = ceil(1.11);
+    d = floor(1.11);
+    d = log10(1.11);
+    d = pow(1.11, 2.22);
+    d = sqrt(1.11);
+    d = sin(1.11);
+    d = cos(1.11);
+    d = atan(1.11);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_FLOAT_FUNCS 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for isinf()" >&5
+$as_echo_n "checking for isinf()... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+int r = isinf(1.11);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_ISINF 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for isnan()" >&5
+$as_echo_n "checking for isnan()... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_MATH_H
+# include <math.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+
+int
+main ()
+{
+int r = isnan(1.11);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_ISNAN 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-acl argument" >&5
+$as_echo_n "checking --disable-acl argument... " >&6; }
+# Check whether --enable-acl was given.
+if test "${enable_acl+set}" = set; then :
+  enableval=$enable_acl;
+else
+  enable_acl="yes"
+fi
+
+if test "$enable_acl" = "yes"; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get_file in -lposix1e" >&5
+$as_echo_n "checking for acl_get_file in -lposix1e... " >&6; }
+if ${ac_cv_lib_posix1e_acl_get_file+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lposix1e  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char acl_get_file ();
+int
+main ()
+{
+return acl_get_file ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_posix1e_acl_get_file=yes
+else
+  ac_cv_lib_posix1e_acl_get_file=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix1e_acl_get_file" >&5
+$as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
+if test "x$ac_cv_lib_posix1e_acl_get_file" = xyes; then :
+  LIBS="$LIBS -lposix1e"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get_file in -lacl" >&5
+$as_echo_n "checking for acl_get_file in -lacl... " >&6; }
+if ${ac_cv_lib_acl_acl_get_file+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lacl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char acl_get_file ();
+int
+main ()
+{
+return acl_get_file ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_acl_acl_get_file=yes
+else
+  ac_cv_lib_acl_acl_get_file=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_acl_acl_get_file" >&5
+$as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
+if test "x$ac_cv_lib_acl_acl_get_file" = xyes; then :
+  LIBS="$LIBS -lacl"
+		  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgetxattr in -lattr" >&5
+$as_echo_n "checking for fgetxattr in -lattr... " >&6; }
+if ${ac_cv_lib_attr_fgetxattr+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lattr  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fgetxattr ();
+int
+main ()
+{
+return fgetxattr ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_attr_fgetxattr=yes
+else
+  ac_cv_lib_attr_fgetxattr=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_attr_fgetxattr" >&5
+$as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
+if test "x$ac_cv_lib_attr_fgetxattr" = xyes; then :
+  LIBS="$LIBS -lattr"
+fi
+
+fi
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for POSIX ACL support" >&5
+$as_echo_n "checking for POSIX ACL support... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif
+acl_t acl;
+int
+main ()
+{
+acl = acl_get_file("foo", ACL_TYPE_ACCESS);
+	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
+	acl_free(acl);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_POSIX_ACL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get in -lsec" >&5
+$as_echo_n "checking for acl_get in -lsec... " >&6; }
+if ${ac_cv_lib_sec_acl_get+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsec  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char acl_get ();
+int
+main ()
+{
+return acl_get ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_sec_acl_get=yes
+else
+  ac_cv_lib_sec_acl_get=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sec_acl_get" >&5
+$as_echo "$ac_cv_lib_sec_acl_get" >&6; }
+if test "x$ac_cv_lib_sec_acl_get" = xyes; then :
+  LIBS="$LIBS -lsec"; $as_echo "#define HAVE_SOLARIS_ZFS_ACL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Solaris ACL support" >&5
+$as_echo_n "checking for Solaris ACL support... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif
+int
+main ()
+{
+acl("foo", GETACLCNT, 0, NULL);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SOLARIS_ACL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for AIX ACL support" >&5
+$as_echo_n "checking for AIX ACL support... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+#ifdef HAVE_SYS_ACL_H
+# include <sys/acl.h>
+#endif
+#ifdef HAVE_SYS_ACCESS_H
+# include <sys/access.h>
+#endif
+#define _ALL_SOURCE
+
+#include <sys/stat.h>
+
+int aclsize;
+struct acl *aclent;
+int
+main ()
+{
+aclsize = sizeof(struct acl);
+	aclent = (void *)malloc(aclsize);
+	statacl("foo", STX_NORMAL, aclent, aclsize);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_AIX_ACL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+if test "x$GTK_CFLAGS" != "x"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pango_shape_full" >&5
+$as_echo_n "checking for pango_shape_full... " >&6; }
+  ac_save_CFLAGS="$CFLAGS"
+  ac_save_LIBS="$LIBS"
+  CFLAGS="$CFLAGS $GTK_CFLAGS"
+  LIBS="$LIBS $GTK_LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <gtk/gtk.h>
+int
+main ()
+{
+ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_PANGO_SHAPE_FULL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  CFLAGS="$ac_save_CFLAGS"
+  LIBS="$ac_save_LIBS"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-gpm argument" >&5
+$as_echo_n "checking --disable-gpm argument... " >&6; }
+# Check whether --enable-gpm was given.
+if test "${enable_gpm+set}" = set; then :
+  enableval=$enable_gpm;
+else
+  enable_gpm="yes"
+fi
+
+
+if test "$enable_gpm" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gpm" >&5
+$as_echo_n "checking for gpm... " >&6; }
+if ${vi_cv_have_gpm+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  olibs="$LIBS" ; LIBS="-lgpm"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <gpm.h>
+	    #include <linux/keyboard.h>
+int
+main ()
+{
+Gpm_GetLibVersion(NULL);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  	    	    vi_cv_have_gpm=yes
+else
+  vi_cv_have_gpm=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LIBS="$olibs"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_have_gpm" >&5
+$as_echo "$vi_cv_have_gpm" >&6; }
+  if test $vi_cv_have_gpm = yes; then
+    LIBS="$LIBS -lgpm"
+    $as_echo "#define HAVE_GPM 1" >>confdefs.h
+
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-sysmouse argument" >&5
+$as_echo_n "checking --disable-sysmouse argument... " >&6; }
+# Check whether --enable-sysmouse was given.
+if test "${enable_sysmouse+set}" = set; then :
+  enableval=$enable_sysmouse;
+else
+  enable_sysmouse="yes"
+fi
+
+
+if test "$enable_sysmouse" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysmouse" >&5
+$as_echo_n "checking for sysmouse... " >&6; }
+if ${vi_cv_have_sysmouse+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/consio.h>
+	     #include <signal.h>
+	     #include <sys/fbio.h>
+int
+main ()
+{
+struct mouse_info   mouse;
+	     mouse.operation = MOUSE_MODE;
+	     mouse.operation = MOUSE_SHOW;
+	     mouse.u.mode.mode = 0;
+	     mouse.u.mode.signal = SIGUSR2;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  vi_cv_have_sysmouse=yes
+else
+  vi_cv_have_sysmouse=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_have_sysmouse" >&5
+$as_echo "$vi_cv_have_sysmouse" >&6; }
+  if test $vi_cv_have_sysmouse = yes; then
+    $as_echo "#define HAVE_SYSMOUSE 1" >>confdefs.h
+
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for FD_CLOEXEC" >&5
+$as_echo_n "checking for FD_CLOEXEC... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#if HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+int
+main ()
+{
+	int flag = FD_CLOEXEC;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_FD_CLOEXEC 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not usable" >&5
+$as_echo "not usable" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for rename" >&5
+$as_echo_n "checking for rename... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+rename("this", "that")
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_RENAME 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysctl" >&5
+$as_echo_n "checking for sysctl... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/sysctl.h>
+int
+main ()
+{
+	int mib[2], r;
+	size_t len;
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_USERMEM;
+	len = sizeof(r);
+	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SYSCTL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not usable" >&5
+$as_echo "not usable" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysinfo" >&5
+$as_echo_n "checking for sysinfo... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/sysinfo.h>
+int
+main ()
+{
+	struct sysinfo sinfo;
+	int t;
+
+	(void)sysinfo(&sinfo);
+	t = sinfo.totalram;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SYSINFO 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not usable" >&5
+$as_echo "not usable" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysinfo.mem_unit" >&5
+$as_echo_n "checking for sysinfo.mem_unit... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/sysinfo.h>
+int
+main ()
+{
+	struct sysinfo sinfo;
+	sinfo.mem_unit = 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SYSINFO_MEM_UNIT 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysconf" >&5
+$as_echo_n "checking for sysconf... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <unistd.h>
+int
+main ()
+{
+	(void)sysconf(_SC_PAGESIZE);
+	(void)sysconf(_SC_PHYS_PAGES);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_SYSCONF 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not usable" >&5
+$as_echo "not usable" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
+$as_echo_n "checking size of int... " >&6; }
+if ${ac_cv_sizeof_int+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_int" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (int)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_int=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_int" >&5
+$as_echo "$ac_cv_sizeof_int" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_INT $ac_cv_sizeof_int
+_ACEOF
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
+$as_echo_n "checking size of long... " >&6; }
+if ${ac_cv_sizeof_long+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (long)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_long=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long" >&5
+$as_echo "$ac_cv_sizeof_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of time_t" >&5
+$as_echo_n "checking size of time_t... " >&6; }
+if ${ac_cv_sizeof_time_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (time_t))" "ac_cv_sizeof_time_t"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_time_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (time_t)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_time_t=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_time_t" >&5
+$as_echo "$ac_cv_sizeof_time_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_TIME_T $ac_cv_sizeof_time_t
+_ACEOF
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of off_t" >&5
+$as_echo_n "checking size of off_t... " >&6; }
+if ${ac_cv_sizeof_off_t+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (off_t))" "ac_cv_sizeof_off_t"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_off_t" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (off_t)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_off_t=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_off_t" >&5
+$as_echo "$ac_cv_sizeof_off_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_OFF_T $ac_cv_sizeof_off_t
+_ACEOF
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define VIM_SIZEOF_INT $ac_cv_sizeof_int
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define VIM_SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking uint32_t is 32 bits" >&5
+$as_echo_n "checking uint32_t is 32 bits... " >&6; }
+if test "$cross_compiling" = yes; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cannot check uint32_t when cross-compiling." >&5
+$as_echo "$as_me: WARNING: cannot check uint32_t when cross-compiling." >&2;}
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+main() {
+  uint32_t nr1 = (uint32_t)-1;
+  uint32_t nr2 = (uint32_t)0xffffffffUL;
+  if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
+  exit(0);
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+else
+  as_fn_error $? "WRONG!  uint32_t not defined correctly." "$LINENO" 5
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+
+bcopy_test_prog='
+#include "confdefs.h"
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+main() {
+  char buf[10];
+  strcpy(buf, "abcdefghi");
+  mch_memmove(buf, buf + 2, 3);
+  if (strncmp(buf, "ababcf", 6))
+    exit(1);
+  strcpy(buf, "abcdefghi");
+  mch_memmove(buf + 2, buf, 3);
+  if (strncmp(buf, "cdedef", 6))
+    exit(1);
+  exit(0); /* libc version works properly.  */
+}'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether memmove handles overlaps" >&5
+$as_echo_n "checking whether memmove handles overlaps... " >&6; }
+if ${vim_cv_memmove_handles_overlap+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    if test "$cross_compiling" = yes; then :
+
+	as_fn_error $? "cross-compiling: please set 'vim_cv_memmove_handles_overlap'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+	vim_cv_memmove_handles_overlap=yes
+
+else
+
+	vim_cv_memmove_handles_overlap=no
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_memmove_handles_overlap" >&5
+$as_echo "$vim_cv_memmove_handles_overlap" >&6; }
+
+if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
+  $as_echo "#define USEMEMMOVE 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bcopy handles overlaps" >&5
+$as_echo_n "checking whether bcopy handles overlaps... " >&6; }
+if ${vim_cv_bcopy_handles_overlap+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+      if test "$cross_compiling" = yes; then :
+
+	as_fn_error $? "cross-compiling: please set 'vim_cv_bcopy_handles_overlap'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+	vim_cv_bcopy_handles_overlap=yes
+
+else
+
+	vim_cv_bcopy_handles_overlap=no
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_bcopy_handles_overlap" >&5
+$as_echo "$vim_cv_bcopy_handles_overlap" >&6; }
+
+  if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
+    $as_echo "#define USEBCOPY 1" >>confdefs.h
+
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether memcpy handles overlaps" >&5
+$as_echo_n "checking whether memcpy handles overlaps... " >&6; }
+if ${vim_cv_memcpy_handles_overlap+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	if test "$cross_compiling" = yes; then :
+
+	    as_fn_error $? "cross-compiling: please set 'vim_cv_memcpy_handles_overlap'" "$LINENO" 5
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+	    vim_cv_memcpy_handles_overlap=yes
+
+else
+
+	    vim_cv_memcpy_handles_overlap=no
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $vim_cv_memcpy_handles_overlap" >&5
+$as_echo "$vim_cv_memcpy_handles_overlap" >&6; }
+
+    if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
+      $as_echo "#define USEMEMCPY 1" >>confdefs.h
+
+    fi
+  fi
+fi
+
+
+if test "x$with_x" = "xyes"; then
+  cflags_save=$CFLAGS
+  libs_save=$LIBS
+  LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
+  CFLAGS="$CFLAGS $X_CFLAGS"
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether X_LOCALE needed" >&5
+$as_echo_n "checking whether X_LOCALE needed... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlocale.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char _Xsetlocale ();
+int
+main ()
+{
+return _Xsetlocale ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	      $as_echo "#define X_LOCALE 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether Xutf8SetWMProperties() can be used" >&5
+$as_echo_n "checking whether Xutf8SetWMProperties() can be used... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char Xutf8SetWMProperties ();
+int
+main ()
+{
+return Xutf8SetWMProperties ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	      $as_echo "#define HAVE_XUTF8SETWMPROPERTIES 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+  CFLAGS=$cflags_save
+  LIBS=$libs_save
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for _xpg4_setrunelocale in -lxpg4" >&5
+$as_echo_n "checking for _xpg4_setrunelocale in -lxpg4... " >&6; }
+if ${ac_cv_lib_xpg4__xpg4_setrunelocale+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxpg4  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char _xpg4_setrunelocale ();
+int
+main ()
+{
+return _xpg4_setrunelocale ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_xpg4__xpg4_setrunelocale=yes
+else
+  ac_cv_lib_xpg4__xpg4_setrunelocale=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
+$as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
+if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = xyes; then :
+  LIBS="$LIBS -lxpg4"
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to create tags" >&5
+$as_echo_n "checking how to create tags... " >&6; }
+test -f tags && mv tags tags.save
+if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
+  TAGPRG="ctags -I INIT+ --fields=+S"
+elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
+  TAGPRG="exctags -I INIT+ --fields=+S"
+elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
+  TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
+else
+  TAGPRG="ctags"
+  (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
+  (eval etags -c   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags -c"
+  (eval ctags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags"
+  (eval ctags -t   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -t"
+  (eval ctags -ts  /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -ts"
+  (eval ctags -tvs /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -tvs"
+  (eval ctags -i+m /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags -i+m"
+fi
+test -f tags.save && mv tags.save tags
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $TAGPRG" >&5
+$as_echo "$TAGPRG" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run man with a section nr" >&5
+$as_echo_n "checking how to run man with a section nr... " >&6; }
+MANDEF="man"
+(eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&5 && MANDEF="man -s"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MANDEF" >&5
+$as_echo "$MANDEF" >&6; }
+if test "$MANDEF" = "man -s"; then
+  $as_echo "#define USEMAN_S 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-nls argument" >&5
+$as_echo_n "checking --disable-nls argument... " >&6; }
+# Check whether --enable-nls was given.
+if test "${enable_nls+set}" = set; then :
+  enableval=$enable_nls;
+else
+  enable_nls="yes"
+fi
+
+
+if test "$enable_nls" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+  INSTALL_LANGS=install-languages
+
+  INSTALL_TOOL_LANGS=install-tool-languages
+
+
+  # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_MSGFMT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$MSGFMT"; then
+  ac_cv_prog_MSGFMT="$MSGFMT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_MSGFMT="msgfmt"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+MSGFMT=$ac_cv_prog_MSGFMT
+if test -n "$MSGFMT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
+$as_echo "$MSGFMT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for NLS" >&5
+$as_echo_n "checking for NLS... " >&6; }
+  if test -f po/Makefile; then
+    have_gettext="no"
+    if test -n "$MSGFMT"; then
+      olibs=$LIBS
+      LIBS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <libintl.h>
+int
+main ()
+{
+gettext("Test");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() works" >&5
+$as_echo "gettext() works" >&6; }; have_gettext="yes"; LIBS=$olibs
+else
+  LIBS="-lintl"
+	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <libintl.h>
+int
+main ()
+{
+gettext("Test");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() works with -lintl" >&5
+$as_echo "gettext() works with -lintl" >&6; }; have_gettext="yes";
+	      LIBS="$olibs -lintl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() doesn't work" >&5
+$as_echo "gettext() doesn't work" >&6; };
+	      LIBS=$olibs
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: msgfmt not found - disabled" >&5
+$as_echo "msgfmt not found - disabled" >&6; };
+    fi
+    if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
+      $as_echo "#define HAVE_GETTEXT 1" >>confdefs.h
+
+      MAKEMO=yes
+
+            for ac_func in bind_textdomain_codeset
+do :
+  ac_fn_c_check_func "$LINENO" "bind_textdomain_codeset" "ac_cv_func_bind_textdomain_codeset"
+if test "x$ac_cv_func_bind_textdomain_codeset" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_BIND_TEXTDOMAIN_CODESET 1
+_ACEOF
+
+fi
+done
+
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _nl_msg_cat_cntr" >&5
+$as_echo_n "checking for _nl_msg_cat_cntr... " >&6; }
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <libintl.h>
+		extern int _nl_msg_cat_cntr;
+int
+main ()
+{
+++_nl_msg_cat_cntr;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }; $as_echo "#define HAVE_NL_MSG_CAT_CNTR 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no \"po/Makefile\" - disabled" >&5
+$as_echo "no \"po/Makefile\" - disabled" >&6; };
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+
+ac_fn_c_check_header_mongrel "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default"
+if test "x$ac_cv_header_dlfcn_h" = xyes; then :
+  DLL=dlfcn.h
+else
+  ac_fn_c_check_header_mongrel "$LINENO" "dl.h" "ac_cv_header_dl_h" "$ac_includes_default"
+if test "x$ac_cv_header_dl_h" = xyes; then :
+  DLL=dl.h
+fi
+
+
+fi
+
+
+if test x${DLL} = xdlfcn.h; then
+
+$as_echo "#define HAVE_DLFCN_H 1" >>confdefs.h
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen()" >&5
+$as_echo_n "checking for dlopen()... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+		extern void* dlopen();
+		dlopen();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_DLOPEN 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen() in -ldl" >&5
+$as_echo_n "checking for dlopen() in -ldl... " >&6; }
+	      olibs=$LIBS
+	      LIBS="$LIBS -ldl"
+	      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+				extern void* dlopen();
+				dlopen();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_DLOPEN 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+			  LIBS=$olibs
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlsym()" >&5
+$as_echo_n "checking for dlsym()... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+		extern void* dlsym();
+		dlsym();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_DLSYM 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlsym() in -ldl" >&5
+$as_echo_n "checking for dlsym() in -ldl... " >&6; }
+	      olibs=$LIBS
+	      LIBS="$LIBS -ldl"
+	      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+				extern void* dlsym();
+				dlsym();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_DLSYM 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+			  LIBS=$olibs
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+elif test x${DLL} = xdl.h; then
+
+$as_echo "#define HAVE_DL_H 1" >>confdefs.h
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load()" >&5
+$as_echo_n "checking for shl_load()... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+		extern void* shl_load();
+		shl_load();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_SHL_LOAD 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load() in -ldld" >&5
+$as_echo_n "checking for shl_load() in -ldld... " >&6; }
+	  olibs=$LIBS
+	  LIBS="$LIBS -ldld"
+	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+			extern void* shl_load();
+			shl_load();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };
+
+$as_echo "#define HAVE_SHL_LOAD 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; };
+		  LIBS=$olibs
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+for ac_header in setjmp.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "setjmp.h" "ac_cv_header_setjmp_h" "$ac_includes_default"
+if test "x$ac_cv_header_setjmp_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SETJMP_H 1
+_ACEOF
+
+fi
+
+done
+
+
+if test "x$MACOSX" = "xyes" -a -n "$PERL"; then
+    if echo $LIBS | grep -e '-ldl' >/dev/null; then
+    LIBS=`echo $LIBS | sed s/-ldl//`
+    PERL_LIBS="$PERL_LIBS -ldl"
+  fi
+fi
+
+if test "x$MACOSX" = "xyes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need -framework Cocoa" >&5
+$as_echo_n "checking whether we need -framework Cocoa... " >&6; }
+      if test "x$features" != "xtiny" || test "x$enable_multibyte" = "xyes"; then
+    LIBS=$"$LIBS -framework Cocoa"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  fi
+        if test "x$features" = "xtiny"; then
+    OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
+    OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
+  fi
+fi
+if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
+  LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+fi
+
+DEPEND_CFLAGS_FILTER=
+if test "$GCC" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GCC 3 or later" >&5
+$as_echo_n "checking for GCC 3 or later... " >&6; }
+  gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
+  if test "$gccmajor" -gt "2"; then
+    DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  fi
+          { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need -D_FORTIFY_SOURCE=1" >&5
+$as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking linker --as-needed support" >&5
+$as_echo_n "checking linker --as-needed support... " >&6; }
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# IBM z/OS reset CFLAGS for config.mk
+if test "$zOSUnix" = "yes"; then
+	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
+fi
+
+ac_config_files="$ac_config_files auto/config.mk:config.mk.in"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    if test "x$cache_file" != "x/dev/null"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+
+: "${CONFIG_STATUS=./config.status}"
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.69,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error $? "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "auto/config.h") CONFIG_HEADERS="$CONFIG_HEADERS auto/config.h:config.h.in" ;;
+    "auto/config.mk") CONFIG_FILES="$CONFIG_FILES auto/config.mk:config.mk.in" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp= ac_tmp=
+  trap 'exit_status=$?
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
+s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    "
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$ac_tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&2;}
+
+  rm -f "$ac_tmp/stdin"
+  case $ac_file in
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
+  fi
+ ;;
+
+
+  esac
+
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
 
-# Stupid autoconf 2.5x causes this file to be left behind.
-if test -f configure.lineno; then rm -f configure.lineno; fi
 
-exit $result
diff -urN vim-src/src/configure.in vim-qt-src/src/configure.in
--- vim-src/src/configure.in	2016-06-08 06:34:09.773884643 +0200
+++ vim-qt-src/src/configure.in	2016-06-08 06:40:09.600637123 +0200
@@ -2184,11 +2184,11 @@
   fi
 fi
 
-test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" -a "x$enable_gui" != "xqt" && enable_gui=no
 
 AC_MSG_CHECKING(--enable-gui argument)
 AC_ARG_ENABLE(gui,
- [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+ [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon/qt]], , enable_gui="auto")
 
 dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
 dnl Do not use character classes for portability with old tools.
@@ -2204,6 +2204,7 @@
 SKIP_NEXTAW=YES
 SKIP_PHOTON=YES
 SKIP_CARBON=YES
+SKIP_QT=YES
 GUITYPE=NONE
 
 if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
@@ -2241,7 +2242,8 @@
 		SKIP_MOTIF=
 		SKIP_ATHENA=
 		SKIP_NEXTAW=
-		SKIP_CARBON=;;
+		SKIP_CARBON=
+		SKIP_QT=;;
     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
 		SKIP_GTK2=;;
     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
@@ -2255,6 +2257,8 @@
 		SKIP_ATHENA=;;
     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
 		SKIP_NEXTAW=;;
+    qt)		AC_MSG_RESULT(Qt GUI support)
+    		SKIP_QT=;;
     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
   esac
 
@@ -2339,7 +2343,6 @@
   fi
 fi
 
-
 if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
   AC_MSG_CHECKING(for Carbon GUI)
   dnl already did the check, just give the message
@@ -2370,7 +2373,8 @@
   SKIP_ATHENA=YES;
   SKIP_NEXTAW=YES;
   SKIP_PHOTON=YES;
-  SKIP_CARBON=YES
+  SKIP_CARBON=YES;
+  SKIP_QT=YES;
 fi
 
 dnl define an autoconf function to check for a specified version of GTK, and
@@ -2597,6 +2601,7 @@
       SKIP_ATHENA=YES
       SKIP_NEXTAW=YES
       SKIP_MOTIF=YES
+      SKIP_QT=YES
       GUITYPE=GTK
       AC_SUBST(GTK_LIBNAME)
     fi
@@ -2812,6 +2817,7 @@
 if test -z "$SKIP_MOTIF"; then
   SKIP_ATHENA=YES
   SKIP_NEXTAW=YES
+  SKIP_QT=YES
   GUITYPE=MOTIF
   AC_SUBST(MOTIF_LIBNAME)
 fi
@@ -2913,6 +2919,199 @@
   CPPFLAGS=$cppflags_save
 fi
 
+dnl Check if the Qt files can be found
+
+if test -z "$SKIP_QT" -a -z "$DONT_FIND_QT"; then
+    AC_LANG_PUSH(C++)
+    AC_PROG_CXX
+    QT_FOUND="no"
+    QT_MIN_VERSION="4.7.0"
+
+    # Disable xim - Qt will decide on this
+    enable_xim="no"
+
+    AC_MSG_CHECKING(--with-qt-qmake argument)
+    AC_ARG_WITH(qt-qmake,
+    [  --with-qt-qmake=PATH   QMake location (ex: /usr/lib/qt4/bin/qmake)],
+    [ QMAKE="${withval}" ] )
+
+    if test -n "$QMAKE"; then
+
+    	AC_MSG_CHECKING(for $QMAKE)
+	if test ! -x "$QMAKE"; then
+            AC_MSG_ERROR("Unable to find the given qmake $QMAKE")
+	fi
+
+        AC_MSG_RESULT(yes)
+    else
+        AC_MSG_RESULT(no)
+
+        #
+        # Find qmake
+        # 1. First look for "qmake4" in the PATH - some systems use the name qmake(Qt3) and qmake4(Qt4) 
+        # 2. If qmake4 is not found then look for qmake-qt4 in the PATH
+	# 3. Look for qmake in the PATH
+        # 4. Look for "qmake", outside the path, in the following locations
+        QT_BIN_PATH="/usr/lib64/qt4/bin:/usr/local/lib64/qt4/bin:/usr/lib/qt4/bin:/usr/local/lib/qt4/bin"
+    
+        AC_PATH_PROG(QMAKE, qmake4)
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake-qt4)
+        fi
+ 
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake)
+        fi
+
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake, , $QT_BIN_PATH)
+        fi
+    
+        if test -z "$QMAKE"; then
+            AC_MSG_ERROR("Unable to find qmake")
+        fi
+    
+    fi
+
+    #
+    # Check Qt version >= 4.7.0
+
+    AC_MSG_CHECKING(Qt version)
+    QT_VERSION=`$QMAKE -query QT_VERSION | cut -f1`
+    if test [ "$QT_VERSION" \< "$QT_MIN_VERSION" ]; then
+       AC_MSG_ERROR("Qt version is too old - need at least $QT_MIN_VERSION")
+    fi
+    AC_MSG_RESULT($QT_VERSION)
+
+    QT_INSTALL_BINS=`$QMAKE -query QT_INSTALL_BINS | cut -f1`
+    QT_MOC="$QT_INSTALL_BINS/moc"
+    if test ! -x "$QT_MOC"; then
+    	AC_MSG_ERROR("Unable to find the given Qt moc $QT_MOC")
+    fi
+    QT_RCC="$QT_INSTALL_BINS/rcc"
+    if test ! -x "$QT_RCC"; then
+    	AC_MSG_ERROR("Unable to find the given Qt rcc $QT_RCC")
+    fi
+
+    #
+    # Call qmake to generate bogus project
+    #
+    # What we do here is call qmake to generate a valid Makefile and
+    # then extract the Qt compiler flags from the generated Makefile
+    #
+    TMPDIR=/tmp
+    tmp=`(umask 077 && mktemp -d -q "$TMPDIR/test-vim-qt-XXXXXXXX") 2>/dev/null`;
+    if test -z "$tmp" -a -d "$tmp"; then
+	AC_MSG_ERROR(Unable to create temporary directory)
+    fi
+
+cat > $tmp/qttest.cpp << EOF
+#include <QApplication>
+int main(int ac, char **av) {
+    QApplication app(ac, av);
+    return app.exec();
+}
+EOF
+
+    AC_PATH_PROG(MAKE_P, gmake)
+    if test -z "$MAKE_P"; then
+    	MAKE_P="make"
+
+    else
+        AC_PATH_PROG(MAKE_P, gmake)
+    fi
+    echo "$MAKE_P"
+
+    # Generate qmake project
+    qmake_try=`cd $tmp; $QMAKE -project -o test.pro`
+    AC_TRY_EVAL(qt_try)
+    if test x"$ac_status" != x0; then
+        AC_MSG_ERROR(qmake failed)
+    fi
+
+    # Qt Modules
+    echo "QT += network" >> $tmp/test.pro
+    if test ![ "5.0.0" \> "$QT_VERSION" ]; then
+    	# Qt5 needs QtWidgets
+	echo "QT += widgets" >> $tmp/test.pro
+    fi
+
+
+    # generate Makefile
+    qmake_try=`cd $tmp; $QMAKE`
+    AC_TRY_EVAL(qt_try)
+    if test x"$ac_status" != x0; then
+        AC_MSG_ERROR(qmake failed)
+    fi
+
+    #
+    # A dummy Makefile to help extract the
+    # real parameters
+    #
+cat > $tmp/makefile.dummy << EOF
+def: info
+include $tmp/Makefile
+info:
+	@echo "CXXFLAGS = \$(CXXFLAGS)"
+	@echo "CFLAGS = \$(CFLAGS)"
+	@echo "LFLAGS = \$(LFLAGS)"
+	@echo "LIBS = \$(LIBS)"
+	@echo "INCPATH = \$(INCPATH)"
+EOF
+
+    # LIBS
+    QT_LIBS=`$MAKE_P -f $tmp/makefile.dummy |grep LIBS.*= | awk '{sub(/^LIBS +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        AC_MSG_ERROR(Unable to find Qt libraries)
+    fi
+
+    # Include directives
+    QT_INCPATH=`$MAKE_P -f $tmp/makefile.dummy |grep INCPATH.*= | awk '{sub(/^INCPATH +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        AC_MSG_ERROR(Unable to find Qt include path)
+    fi
+
+    # LFLAGS
+    QT_LFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep LFLAGS.*= | awk '{sub(/^LFLAGS +=/, ""); print}'`
+    if test -z "$QT_LFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt link flags)
+    fi
+
+    # Qt CXXFLAGS
+    QT_CXXFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CXXFLAGS.*= | awk '{sub(/^CXXFLAGS +=/, ""); print}'`
+    QT_CXXFLAGS=`echo "$QT_CXXFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_LFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt C flags)
+    fi
+
+    # Qt CFLAGS
+    QT_CFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CFLAGS.*= | awk '{sub(/^CFLAGS +=/, ""); print}'`
+    QT_CFLAGS=`echo "$QT_CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_CFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt C++ flags)
+    fi
+
+    LDFLAGS="$LDFLAGS $QT_LFLAGS -lstdc++"
+    AC_SUBST(QT_LIBS)
+    AC_SUBST(QT_MOC)
+    AC_SUBST(QT_RCC)
+    AC_SUBST(QT_INCPATH)
+    AC_SUBST(QT_CXXFLAGS)
+    AC_SUBST(QT_CFLAGS)
+    AC_LANG_POP(C++)
+
+    # Remove temp directory
+    rm $tmp/Makefile
+    rm $tmp/qttest.cpp
+    rm $tmp/test.pro
+    rm $tmp/makefile.dummy
+    rmdir $tmp
+fi
+
+if test -z "$SKIP_QT"; then
+  GUITYPE=QT
+  GUI_X_LIBS=
+fi
 
 if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
diff -urN vim-src/src/eval.c vim-qt-src/src/eval.c
--- vim-src/src/eval.c	2016-06-08 06:34:09.779884688 +0200
+++ vim-qt-src/src/eval.c	2016-06-08 06:40:09.608637185 +0200
@@ -14027,6 +14027,9 @@
 #ifdef FEAT_GUI_W32
 	"gui_win32",
 #endif
+#ifdef FEAT_GUI_QT
+	"gui_qt",
+#endif
 #ifdef FEAT_HANGULIN
 	"hangul_input",
 #endif
diff -urN vim-src/src/ex_docmd.c vim-qt-src/src/ex_docmd.c
--- vim-src/src/ex_docmd.c	2016-06-08 06:34:09.783884719 +0200
+++ vim-qt-src/src/ex_docmd.c	2016-06-08 06:40:09.611637208 +0200
@@ -7681,6 +7681,7 @@
 	|| (defined(FEAT_GUI_GTK) && defined(FEAT_DND)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 
 /*
diff -urN vim-src/src/feature.h vim-qt-src/src/feature.h
--- vim-src/src/feature.h	2016-06-08 06:41:04.521059846 +0200
+++ vim-qt-src/src/feature.h	2016-06-08 06:41:05.101064313 +0200
@@ -40,6 +40,10 @@
  * When +small is used, +tiny is also included.  +normal implies +small, etc.
  */
 
+#ifdef FEAT_GUI_QT
+#include <qt_features.h>
+#endif
+
 /*
  * Uncomment one of these to override the default.  For unix use a configure
  * argument, see Makefile.
@@ -616,7 +620,7 @@
  * Disabled for EBCDIC:
  * Multibyte support doesn't work on z/OS Unix currently.
  */
-#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_ARABIC)) \
+#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT) || defined(FEAT_ARABIC)) \
 	&& !defined(FEAT_MBYTE) && VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)
 # define FEAT_MBYTE
 #endif
@@ -791,7 +795,8 @@
 	|| defined(FEAT_GUI_GTK) \
 	|| defined(FEAT_GUI_PHOTON) \
 	|| defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_MAC)
+	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT)
 #  define FEAT_CON_DIALOG
 #  define FEAT_GUI_DIALOG
 # else
diff -urN vim-src/src/fileio.c vim-qt-src/src/fileio.c
--- vim-src/src/fileio.c	2016-06-08 06:34:09.786884741 +0200
+++ vim-qt-src/src/fileio.c	2016-06-08 06:40:09.614637231 +0200
@@ -6125,6 +6125,7 @@
 #if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 /*
  * Shorten all filenames in "fnames[count]" by current directory.
diff -urN vim-src/src/globals.h vim-qt-src/src/globals.h
--- vim-src/src/globals.h	2016-06-08 06:34:09.788884757 +0200
+++ vim-qt-src/src/globals.h	2016-06-08 06:40:09.616637246 +0200
@@ -518,7 +518,7 @@
 
 #ifdef FEAT_CLIPBOARD
 EXTERN VimClipboard clip_star;	/* PRIMARY selection in X11 */
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 EXTERN VimClipboard clip_plus;	/* CLIPBOARD selection in X11 */
 # else
 #  define clip_plus clip_star	/* there is only one clipboard */
@@ -1423,7 +1423,7 @@
 EXTERN char_u e_fontset[]	INIT(= N_("E234: Unknown fontset: %s"));
 #endif
 #if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(MACOS) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_QT)
 EXTERN char_u e_font[]		INIT(= N_("E235: Unknown font: %s"));
 #endif
 #if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)
diff -urN vim-src/src/gui.c vim-qt-src/src/gui.c
--- vim-src/src/gui.c	2016-06-08 06:34:09.791884779 +0200
+++ vim-qt-src/src/gui.c	2016-06-08 06:40:09.617637254 +0200
@@ -166,10 +166,10 @@
     termcapinit((char_u *)"builtin_gui");
     gui.starting = recursive - 1;
 
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_QT)
     if (gui.in_use)
     {
-# ifdef FEAT_EVAL
+# if defined(FEAT_EVAL) && !defined(FEAT_GUI_QT)
 	Window	x11_window;
 	Display	*x11_display;
 
@@ -797,7 +797,7 @@
 }
 
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(PROTO)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT) || defined(PROTO)
 # define NEED_GUI_UPDATE_SCREEN 1
 /*
  * Called when the GUI shell is closed by the user.  If there are no changed
@@ -1402,7 +1402,7 @@
     base_height = 2 * gui.border_offset;
     if (gui.which_scrollbars[SBAR_BOTTOM])
 	base_height += gui.scrollbar_height;
-#ifdef FEAT_GUI_GTK
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     /* We can't take the sizes properly into account until anything is
      * realized.  Therefore we recalculate all the values here just before
      * setting the size. (--mdcki) */
@@ -1561,7 +1561,7 @@
     if (!gui.shell_created)
 	return;
 
-#if defined(MSWIN) || defined(FEAT_GUI_GTK)
+#if (defined(MSWIN) || defined(FEAT_GUI_GTK)) && !defined(FEAT_GUI_QT)
     /* If not setting to a user specified size and maximized, calculate the
      * number of characters that fit in the maximized window. */
     if (!mustset && gui_mch_maximized())
@@ -2370,7 +2370,7 @@
     if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
 	return FAIL;
 
-#if defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     /* If there's no italic font, then fake it.
      * For GTK2, we don't need a different font for italic style. */
     if (hl_mask_todo & HL_ITALIC)
@@ -5043,7 +5043,7 @@
 # endif
 #endif
 
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO) || defined(FEAT_GUI_QT)
     void
 display_errors(void)
 {
@@ -5376,6 +5376,7 @@
 #if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 
 #ifdef FEAT_WINDOWS
diff -urN vim-src/src/gui.h vim-qt-src/src/gui.h
--- vim-src/src/gui.h	2016-03-27 19:08:37.186722538 +0200
+++ vim-qt-src/src/gui.h	2016-06-08 06:40:09.617637254 +0200
@@ -62,7 +62,7 @@
  * On some systems scrolling needs to be done right away instead of in the
  * main loop.
  */
-#if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 # define USE_ON_FLY_SCROLL
 #endif
 
@@ -138,7 +138,7 @@
 #define DRAW_BOLD		0x02	/* draw bold text */
 #define DRAW_UNDERL		0x04	/* draw underline text */
 #define DRAW_UNDERC		0x08	/* draw undercurl text */
-#if defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 # define DRAW_ITALIC		0x10	/* draw italic text */
 #endif
 #define DRAW_CURSOR		0x20	/* drawing block cursor (win32) */
@@ -164,6 +164,10 @@
 				   is no console input possible */
 #endif
 
+#ifdef FEAT_GUI_QT
+struct VimScrollBar;
+#endif
+
 typedef struct GuiScrollbar
 {
     long	ident;		/* Unique identifier for each scrollbar */
@@ -204,6 +208,9 @@
 #ifdef FEAT_GUI_PHOTON
     PtWidget_t	*id;
 #endif
+#ifdef FEAT_GUI_QT
+    struct VimScrollBar* wid;
+#endif
 } scrollbar_T;
 
 typedef long	    guicolor_T;	/* handle for a GUI color; for X11 this should
@@ -231,10 +238,19 @@
 #   define NOFONT	(GuiFont)0
 #   define NOFONTSET	(GuiFontset)0
 #  else
+
+#   ifdef FEAT_GUI_QT
+  struct QFont;
+  typedef struct QFont*	GuiFont;
+  typedef void*		GuiFontset;
+#  define NOFONT	(GuiFont)NULL
+#  define NOFONTSET	(GuiFontset)NULL
+#   else
   typedef long_u	GuiFont;	/* handle for a GUI font */
   typedef long_u	GuiFontset;	/* handle for a GUI fontset */
 #   define NOFONT	(GuiFont)0
 #   define NOFONTSET	(GuiFontset)0
+#   endif
 #  endif
 # endif
 #endif
@@ -298,6 +314,10 @@
 				     * The styled font variants are not used. */
 #endif
 
+#ifdef FEAT_GUI_QT
+    int		char_ul_pos;        /* underline position - distance from the baseline */
+#endif
+
 #if defined(FEAT_MENU) && !defined(FEAT_GUI_GTK)
 # ifdef FONTSET_ALWAYS
     GuiFontset	menu_fontset;	    /* set of fonts for multi-byte chars */
diff -urN vim-src/src/gui_qt.cpp vim-qt-src/src/gui_qt.cpp
--- vim-src/src/gui_qt.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/gui_qt.cpp	2016-06-08 06:40:09.624637308 +0200
@@ -0,0 +1,1770 @@
+#include <QApplication>
+#include <QMessageBox>
+#include <QDesktopWidget>
+#include <QSettings>
+#include <QFile>
+#include <QFileInfo>
+#include <QDir>
+#include <QClipboard>
+#include <QMenu>
+#include <QMenuBar>
+#include <QToolBar>
+#include <QFileDialog>
+#include <QPushButton>
+#include <QMimeData>
+
+#include "qvimshell.h"
+#include "mainwindow.h"
+#include "vimaction.h"
+#include "vimscrollbar.h"
+#include "fontdialog.h"
+
+extern "C" {
+
+#include "vim.h"
+#include "globals.h"
+
+static QVimShell *vimshell = NULL;
+static MainWindow *window = NULL;
+
+static QColor foregroundColor;
+static QColor backgroundColor;
+static QColor specialColor;
+
+
+/*
+ * We delay Qt initialization and pass
+ * QApplication a pair of fake arguments
+ */
+static int dummy_argc = 1;
+static char *dummy_argv[] = {"qvim", NULL};
+
+/**
+ * If vim calls for a fullscreen window
+ * before the window is created we have to
+ * store this state.
+ *
+ * This is checked in gui_mch_init when creaating the GUI
+ */
+static bool start_fullscreen = false;
+
+void gui_mch_enter_fullscreen()
+{
+	if (!window) {
+		start_fullscreen = true;
+		return;
+	}
+
+	window->setWindowState( window->windowState() | Qt::WindowFullScreen );
+}
+
+void gui_mch_leave_fullscreen()
+{
+	if (!window) {
+		return;
+	}
+
+	window->setWindowState( window->windowState() & ~Qt::WindowFullScreen );
+}
+
+void gui_mch_update_fuoptions(char_u *optstr)
+{
+	//
+	// FIXME: We don't support fuopts at this point
+	// set fuoptions=maxvert,maxhoriz
+
+}
+
+/**
+ * Raise application window
+ */
+void
+gui_mch_set_foreground()
+{
+	window->activateWindow();
+	window->raise();
+}
+
+/**
+ * Get the font with the given name
+ *
+ */
+GuiFont
+gui_mch_get_font(char_u *name, int giveErrorIfMissing)
+{
+	QString family = VimWrapper::convertFrom(name);
+	QFont font;
+	font.setStyleHint(QFont::TypeWriter);
+	font.setStyleStrategy(QFont::StyleStrategy(QFont::PreferDefault | QFont::ForceIntegerMetrics) );
+
+	if ( name == NULL ) { // Fallback font
+		font.setFamily("Monospace");
+		font.setFixedPitch(true);
+		font.setPointSize(10);
+		font.setKerning(false);
+		return new QFont(font);
+	}
+
+	bool ok;
+	int size = family.section(' ', -1).trimmed().toInt(&ok);
+	if ( ok ) {
+		QString realname = family.section(' ', 0, -2).trimmed();
+		font.setFamily(realname);
+		font.setPointSize(size);
+	} else if ( !font.fromString(family) ) {
+		font.setRawName(family);
+	}
+
+	font.setBold(false);
+	font.setItalic(false);
+	font.setKerning(false);
+
+	//
+	// When you ask for a font you may get a different font. This happens
+	// when the font system does some form of substitution (such as as virtual fonts).
+	// This bit of code checks if the font that is requested is the font that is returned.
+	//
+	// In a nutshell this is what is done:
+	// - If the font exists and has fixed width, load it
+	// - If the font does not exist or is not monospace, don't load the font
+	// + If giveErrorIfMissing is true, throw an error message, otherwise fail silently
+	// * We open an exception for the Monospace font, we ALWAYS load the monospace font
+	//
+	QFontInfo fi(font);
+
+	if ( fi.family().compare(font.family(), Qt::CaseInsensitive) != 0 &&
+		font.family().compare("Monospace", Qt::CaseInsensitive) != 0) {
+
+		if ( giveErrorIfMissing ) {
+			EMSG2(e_font, name);
+		}
+		return NOFONT;
+	}
+
+	if ( !fi.fixedPitch() ) {
+		if ( giveErrorIfMissing ) {
+			EMSG2(e_font, name);
+		}
+		return NOFONT;
+	}
+
+	return new QFont(font);
+}
+
+/**
+ * Get the name of the given font
+ */
+char_u *
+gui_mch_get_fontname(GuiFont font, char_u  *name)
+{
+	if (font == NULL || name == NULL) {
+		return NULL;
+	}
+
+	char_u *s = vim_strsave( name );
+	return s;
+}
+
+/**
+ * Free font object
+ */
+void
+gui_mch_free_font(GuiFont font)
+{
+	delete font;
+}
+
+/**
+ * Trigger the visual bell
+ */
+void
+gui_mch_flash(int msec)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QApplication::alert(window, msec);
+}
+
+/*
+ * GUI input routine called by gui_wait_for_chars().  Waits for a character
+ * from the keyboard.
+ *  wtime == -1	    Wait forever.
+ *  wtime == 0	    This should never happen.
+ *  wtime > 0	    Wait wtime milliseconds for a character.
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+int
+gui_mch_wait_for_chars(long wtime)
+{
+	if (!vim_is_input_buf_empty()) {
+		return OK;
+	}
+
+	return vimshell->processEvents(wtime, true);
+}
+
+/**
+ * Catch up with any queued X events.  This may put keyboard input into the
+ * input buffer, call resize call-backs, trigger timers etc.  If there is
+ * nothing in the X event queue (& no timers pending), then we return
+ * immediately.
+ */
+void
+gui_mch_update()
+{
+	vimshell->processEvents();
+}
+
+
+/**
+ * Flush any output to the screen
+ */
+void
+gui_mch_flush()
+{
+	vimshell->processEvents(0, true);
+}
+
+/**
+ * Set the foreground color
+ */
+void
+gui_mch_set_fg_color(guicolor_T	color)
+{
+	if ( color != INVALCOLOR ) {
+		foregroundColor = VimWrapper::fromColor(color);
+	}
+}
+
+/**
+ * Set the current text background color.
+ */
+void
+gui_mch_set_bg_color(guicolor_T color)
+{
+	// The shell needs a hint background color
+	// to paint the back when resizing
+	if ( color != INVALCOLOR ) {
+		backgroundColor = VimWrapper::fromColor(color);
+	}
+}
+
+
+/**
+ * Start the cursor blinking.  If it was already blinking, this restarts the
+ * waiting time and shows the cursor.
+ *
+ */
+void
+gui_mch_start_blink()
+{
+	vimshell->startBlinking();
+}
+
+/**
+ * Start the cursor blinking.
+ *
+ */
+void
+gui_mch_stop_blink()
+{
+	vimshell->stopBlinking();
+	gui_update_cursor(TRUE, FALSE);
+}
+
+/**
+ * Sound the bell
+ */
+void
+gui_mch_beep()
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QApplication::beep();
+}
+
+/**
+ * Clear the entire shell, i.e. paint it with the
+ * background color
+ */
+void
+gui_mch_clear_all()
+{
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::CLEARALL;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Update Vim metrics
+ */
+static void
+update_char_metrics(const QFontMetrics& metric)
+{
+	gui.char_width = metric.width("M");
+
+	// The actual linespace plus Vim's fake linespace
+	gui.char_height = metric.lineSpacing() + p_linespace;
+	if ( metric.underlinePos() >= metric.descent() ) {
+		gui.char_height += metric.underlinePos() - metric.descent() + metric.lineWidth();
+	}
+
+	gui.char_ascent = metric.ascent() + p_linespace/2 + metric.leading();
+	gui.char_ul_pos = metric.underlinePos();
+}
+
+/**
+ * Initialise vim to use the font "font_name".  If it's NULL, pick a default
+ * font.
+ * If "fontset" is TRUE, load the "font_name" as a fontset.
+ * Return FAIL if the font could not be loaded, OK otherwise.
+ */
+int
+gui_mch_init_font(char_u *font_name, int do_fontset)
+{
+	QFont *qf = gui_mch_get_font(font_name, FALSE);
+	if ( qf == NULL ) {
+		return FAIL;
+	}
+
+	QFontMetrics metric( *qf );
+
+	if ( VimWrapper::isFakeMonospace(*qf) || getenv("QVIM_DRAW_STRING_SLOW") ) {
+		vimshell->setSlowStringDrawing( true );
+	} else {
+		vimshell->setSlowStringDrawing( false );
+	}
+
+	gui.norm_font = qf;
+	update_char_metrics(metric);
+	vimshell->setCharWidth(gui.char_width);
+
+	return OK;
+}
+
+/**
+ * Get current mouse coordinates in text window.
+ */
+void
+gui_mch_getmouse(int *x, int *y)
+{
+	QPoint pos = vimshell->mapFromGlobal( QCursor::pos() );
+	*x = pos.x();
+	*y = pos.y();
+}
+
+/**
+ * Move the mouse pointer to the given position
+ */
+void
+gui_mch_setmouse(int x, int y)
+{
+	QPoint pos = vimshell->mapToGlobal(QPoint(x, y));
+	QCursor::setPos(pos.x(), pos.y());
+}
+
+/* Table for shape IDs.  Keep in sync with the mshape_names[] table in
+ * misc2.c! */
+static Qt::CursorShape mshape_ids[] =
+{
+    Qt::ArrowCursor,
+    Qt::BlankCursor,
+    Qt::IBeamCursor,
+    Qt::SizeVerCursor,
+    Qt::SizeFDiagCursor,
+    Qt::SizeHorCursor,
+    Qt::SizeFDiagCursor,
+    Qt::BusyCursor,
+    Qt::ForbiddenCursor,
+    Qt::CrossCursor,
+    Qt::OpenHandCursor,
+    Qt::ClosedHandCursor,
+    Qt::ArrowCursor,
+    Qt::WhatsThisCursor,
+    Qt::ArrowCursor,
+    Qt::UpArrowCursor
+};
+
+/**
+ * Set mouse pointer shape
+ */
+void
+mch_set_mouse_shape(int shape)
+{
+	vimshell->setCursor(QCursor(mshape_ids[shape]));
+}
+
+/**
+ * Return the RGB value of a pixel as a long.
+ */
+long_u
+gui_mch_get_rgb(guicolor_T pixel)
+{
+	return (long_u)pixel;
+}
+
+/**
+ * Clear the block with the given coordinates
+ */
+void
+gui_mch_clear_block(int row1, int col1, int row2, int col2)
+{
+	QRect rect = VimWrapper::mapBlock(row1, col1, row2, col2);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	op.rect = rect;
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Clear the shell margin
+ *
+ * The shell is a grid whose size is a multiple of its column/row size.
+ * Sometimes an extra margin is in place, this paints that margin.
+ */
+static void
+clear_shell_border()
+{
+	QPoint tl, br;
+
+	tl.setX(0);
+	tl.setY( vimshell->height() - (vimshell->height() % gui.char_height ));
+
+	br.setX(vimshell->width());
+	br.setY(vimshell->height());
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	op.rect = QRect(tl, br);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Insert the given number of lines before the given row, scrolling down any
+ * following text within the scroll region.
+ */
+void
+gui_mch_insert_lines(int row, int num_lines)
+{
+	QRect scrollRect = VimWrapper::mapBlock(row, gui.scroll_region_left,
+					gui.scroll_region_bot, gui.scroll_region_right);
+
+	QVimShell::PaintOperation op1;
+	op1.type = QVimShell::SCROLLRECT;
+	op1.rect = scrollRect;
+	op1.pos = QPoint(0, num_lines*gui.char_height);
+	op1.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op1);
+
+	clear_shell_border();
+}
+
+/*
+ * Delete the given number of lines from the given row, scrolling up any
+ * text further down within the scroll region.
+ */
+void
+gui_mch_delete_lines(int row, int num_lines)
+{
+	// This used to be Bottom+1 and right+1
+	QRect scrollRect = VimWrapper::mapBlock(row, gui.scroll_region_left,
+					gui.scroll_region_bot, gui.scroll_region_right);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::SCROLLRECT;
+	op.rect = scrollRect;
+	op.pos = QPoint(0, -num_lines*gui.char_height);
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Get the size of the screen where the application window is placed
+ */
+void
+gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
+{
+	QDesktopWidget *dw = QApplication::desktop();
+
+	QRect geo = dw->screenGeometry(window);
+	*screen_w = geo.width();
+	*screen_h = geo.height();
+}
+
+/**
+ * Initialize vim
+ *
+ * - Set default colors
+ * - Create window and shell
+ * - Read settings
+ */
+int
+gui_mch_init()
+{
+
+#ifdef Q_WS_X11
+	bool useGUI = getenv("DISPLAY") != 0;
+#else
+	bool useGUI = true;
+#endif
+	QApplication *app = new QApplication(dummy_argc, dummy_argv, useGUI);
+
+
+	window = new MainWindow(&gui);
+
+	// Load qVim settings
+	QSettings settings("Vim", "qVim");
+	settings.beginGroup("mainwindow");
+	window->restoreState( settings.value("state").toByteArray() );
+	settings.endGroup();
+
+	vimshell = window->vimShell();
+
+	// Load qVim style
+	QSettings ini(QSettings::IniFormat, QSettings::UserScope, "Vim", "qVim");
+	QFile styleFile( QFileInfo(ini.fileName()).absoluteDir().absoluteFilePath("qVim.style") );
+
+	if ( styleFile.open(QIODevice::ReadOnly) ) {
+		window->setStyleSheet( styleFile.readAll() );
+		styleFile.close();
+	}
+
+	//
+	// Hide the tab/menu/tool-bars, if needed they will become visible later.
+	// Otherwise the use might see these items when Vim is loading
+	//
+	window->showMenu(false);
+	window->showToolbar(false);
+	window->showTabline(false);
+
+	// Clipboard - order matters, for safety
+	clip_star.clipboardMode = QClipboard::Selection;
+	clip_plus.clipboardMode = QClipboard::Clipboard;
+
+    display_errors();
+
+	/* Colors */
+	gui.norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.back_pixel = VimWrapper::toColor(QColor(Qt::white));
+
+	set_normal_colors();
+	gui_check_colors();
+	highlight_gui_started();
+
+	gui.def_norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.def_back_pixel = VimWrapper::toColor(QColor(Qt::white));
+
+	// The Scrollbar manages the scrollbars
+	gui.scrollbar_width = 0;
+	gui.scrollbar_height = 0;
+
+	// Background color hint
+	vimshell->setBackground(VimWrapper::backgroundColor() );
+
+	if ( start_fullscreen ) {
+		gui_mch_enter_fullscreen();
+	}
+
+	return OK;
+}
+
+int
+gui_mch_is_blinking(void)
+{
+    return FALSE;
+}
+
+/**
+ * Set blinking time duration
+ *
+ */
+void
+gui_mch_set_blinking(long waittime, long on, long off)
+{
+	vimshell->setBlinkTime(waittime, on, off);
+}
+
+/**
+ * Initialise Qt, pass in command line arguments
+ */
+void
+gui_mch_prepare(int *argc, char **argv)
+{
+#ifdef Q_WS_X11
+	QColor::setAllowX11ColorNames(true);
+#endif
+}
+
+/**
+ * Resize the shell
+ */
+void
+gui_mch_set_shellsize(int width, int height, int min_width, int min_height,
+		    int base_width, int base_height, int direction)
+{
+	// We actually resize the window, not the shell, i.e. we resize the window
+	// to the new dimensions plus the difference between the window and the shell.
+	// This does not ensure the final size is what Vim requested.
+	//
+	// The actual resize size must take into consideration
+	// - The new shell widget size
+	// - The toolbar/menubar/etc size
+	//
+	// New size <= shell size - window size + new size
+	//
+
+	QDesktopWidget *dw = QApplication::desktop();
+	QSize desktopSize = dw->availableGeometry(window).size();
+
+	if ( !window->isVisible() ) {
+		// We can't resize properly if the window is not
+		// visible just resize the window to the intended size
+		if ( width > desktopSize.width() ) {
+			width = desktopSize.width();
+		}
+		if ( height > desktopSize.height() ) {
+			height = desktopSize.height();
+		}
+
+		window->resize(width, height);
+		return;
+	}
+
+	int decoWidth = (window->frameGeometry().width() - window->width());
+	int decoHeight = (window->frameGeometry().height() - window->height());
+	int frameWidth = (window->size().width() - vimshell->size().width());
+	int frameHeight = (window->size().height() - vimshell->size().height());
+
+	int new_width = frameWidth + width;
+	int new_height = frameHeight + height;
+
+	// If the given dimenstions are too large,
+	// cap them at available desktop dimensions minus the window decorations
+	if ( new_width + decoWidth > desktopSize.width() ) {
+		new_width = desktopSize.width() - decoWidth;
+	}
+	if ( new_height + decoWidth > desktopSize.height() ) {
+		new_height = desktopSize.height() - decoHeight;
+	}
+
+	if (window->windowState() & Qt::WindowFullScreen ) {
+		// In fullscreen mode, resize the widget
+		vimshell->setMaximumSize(width, height);
+	} else if ( window->isMaximized() ) {
+		// Nothing to do here - the windows is maximized
+	} else {
+		window->resize( new_width, new_height );
+	}
+
+	//
+	// Spin the loop to handle the resize event. This will
+	// cause gui_resize_shell() to be called
+	gui_mch_update();
+
+	// Seems redundant but there are cases were the shell might not
+	// call this - because its size is unchanged
+	gui_resize_shell(vimshell->width(), vimshell->height());
+
+	// SHOCKING: it seems gui_get_shellsize() updates the proper values for
+	// the columns and rows, after a resize.
+	gui_get_shellsize();
+}
+
+/**
+ * Called when the foreground or background color has been changed.
+ */
+void
+gui_mch_new_colors()
+{
+	vimshell->setBackground(VimWrapper::backgroundColor() );
+}
+
+/**
+ * Move the application window
+ */
+void
+gui_mch_set_winpos(int x, int y)
+{
+	window->move(x, y);
+}
+
+/**
+ * Set the window title and icon.
+ *
+ * FIXME: We don't use the icon argument
+ */
+void
+gui_mch_settitle(char_u *title, char_u *icon)
+{
+	if ( title != NULL ) {
+		window->setWindowTitle( VimWrapper::convertFrom(title) );
+	}
+}
+
+/**
+ * Show/Hide the mouse pointer
+ */
+void
+gui_mch_mousehide(int hide)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	if ( hide ) {
+		QApplication::setOverrideCursor(Qt::BlankCursor);
+	} else {
+		QApplication::restoreOverrideCursor();
+	}
+}
+
+/**
+ * Adjust gui.char_height (after 'linespace' was changed).
+ */
+int
+gui_mch_adjust_charheight()
+{
+	QFontMetrics metric( *gui.norm_font );
+	update_char_metrics(metric);
+	return OK;
+}
+
+/**
+ * Return OK if the key with the termcap name "name" is supported.
+ */
+int
+gui_mch_haskey(char_u *name)
+{
+	int i;
+	qDebug() << __func__;
+
+	for (i = 0; special_keys[i].code1 != NUL; i++) {
+		if (name[0] == special_keys[i].code0 &&
+					 name[1] == special_keys[i].code1) {
+			return OK;
+		}
+	}
+	return FAIL;
+}
+
+/**
+ * Iconify application window
+ */
+void
+gui_mch_iconify()
+{
+	window->showMinimized();
+}
+
+
+/**
+ * Invert a rectangle from row r, column c, for nr rows and nc columns.
+ */
+void
+gui_mch_invert_rectangle(int row, int col, int nr, int nc)
+{
+	QRect rect = VimWrapper::mapBlock(row, col, row+nr-1, col +nc-1);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::INVERTRECT;
+	op.rect = rect;
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Set the current text font.
+ */
+void
+gui_mch_set_font(GuiFont font)
+{
+	if (font == NULL) {
+		return;
+	}
+	vimshell->setFont(*font);
+}
+
+
+/**
+ * Close the application
+ */
+void
+gui_mch_exit(int rc)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QSettings settings("Vim", "qVim");
+	settings.beginGroup("mainwindow");
+	settings.setValue("state", window->saveState());
+	settings.endGroup();
+
+	QApplication::quit();
+}
+
+/**
+ * Check if the GUI can be started..
+ * Return OK or FAIL.
+ */
+int
+gui_mch_init_check()
+{
+#ifdef Q_WS_X11
+	return (getenv("DISPLAY") != 0);
+#else
+	return OK;
+#endif
+}
+
+/* Clipboard */
+
+/**
+ * Own the selection and return OK if it worked.
+ *
+ */
+int
+clip_mch_own_selection(VimClipboard *cbd)
+{
+	return OK;
+}
+
+/**
+ * Disown the selection.
+ */
+void
+clip_mch_lose_selection(VimClipboard *cbd)
+{
+}
+
+/**
+ * Send the current selection to the clipboard
+ */
+void
+clip_mch_set_selection(VimClipboard *cbd)
+{
+	long_u size;
+	char_u *str = NULL;
+
+	if (!cbd->owned) {
+		return;
+	}
+
+	cbd->owned = TRUE;
+	clip_get_selection(cbd);
+	cbd->owned = FALSE;
+
+	int type = clip_convert_selection(&str, (long_u *)&size, cbd);
+	if (type >= 0) {
+		// Serialize the motion type and store it into the clipboard
+		// with a mimetype application/x-vim-qt-selection-type
+		QByteArray payload;
+		QDataStream serialize(&payload, QIODevice::WriteOnly);
+		serialize << type;
+
+		QClipboard *clip = QApplication::clipboard();
+		QMimeData *clipData = new QMimeData();
+		clipData->setText(VimWrapper::convertFrom(str, size));
+		clipData->setData("application/x-vim-qt-selection-type", payload);
+
+		clip->setMimeData(clipData, (QClipboard::Mode)cbd->clipboardMode);
+	}
+	vim_free(str);
+}
+
+/**
+ * Get selection from clipboard
+ *
+ */
+void
+clip_mch_request_selection(VimClipboard *cbd)
+{
+	QClipboard *clip = QApplication::clipboard();
+	if ( clip->text((QClipboard::Mode)cbd->clipboardMode).size() == 0 ) {
+		return;
+	}
+
+	QByteArray text = VimWrapper::convertTo(clip->text( (QClipboard::Mode)cbd->clipboardMode));
+
+	if ( text.isEmpty() ) {
+		// This should not happen, but if it does vim
+		// behaves badly so lets be extra carefull
+		return;
+	}
+
+	char_u	*buffer;
+	buffer = lalloc( text.size(), TRUE);
+	if (buffer == NULL)
+		return;
+
+	for (int i = 0; i < text.size(); ++i) {
+		buffer[i] = text[i];
+	}
+
+	int type = MAUTO;
+	// If available, deserialize the motion type from the clipboard
+	if (clip->mimeData((QClipboard::Mode)cbd->clipboardMode)->hasFormat("application/x-vim-qt-selection-type")) {
+		QDataStream serialize(clip->mimeData((QClipboard::Mode)cbd->clipboardMode)->data("application/x-vim-qt-selection-type"));
+		serialize >> type;
+	}
+
+	clip_yank_selection(type, buffer, text.size(), cbd);
+	vim_free(buffer);
+}
+
+/**
+ * Open the GUI window which was created by a call to gui_mch_init().
+ */
+int
+gui_mch_open()
+{
+	if ( window == NULL ) {
+		return FAIL;
+	}
+
+	window->show();
+    	if (gui_win_x != -1 && gui_win_y != -1) {
+		gui_mch_set_winpos(gui_win_x, gui_win_y);
+	}
+
+	return OK;
+}
+
+/**
+ * Draw a cursor without focus.
+ */
+void
+gui_mch_draw_hollow_cursor(guicolor_T color)
+{
+	int w = gui.char_width;
+	int h = gui.char_height;
+
+	QPoint tl = QPoint(FILL_X(gui.col),
+			FILL_Y(gui.row) + gui.char_height-h );
+	QPoint br = QPoint(FILL_X(gui.col)+w-2,
+			FILL_Y(gui.row)+gui.char_height-2);
+	QRect rect(tl, br);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWRECT;
+	op.rect = rect;
+	op.color = VimWrapper::fromColor(color);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Draw part of a cursor, only w pixels wide, and h pixels high.
+ */
+void
+gui_mch_draw_part_cursor(int w, int h, guicolor_T color)
+{
+	int x, y;
+
+#ifdef FEAT_RIGHTLEFT
+	if ( CURSOR_BAR_RIGHT ) {
+		x = (gui.col+1)*gui.char_width- w;
+	} else
+#endif
+	{
+		x = gui.col*gui.char_width;
+	}
+	y = gui.row*gui.char_height + gui.char_height - h;
+
+	QRect rect( x, y, w, h);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.rect = rect;
+	op.color = VimWrapper::fromColor(color);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Set the current text special color.
+ */
+void
+gui_mch_set_sp_color(guicolor_T color)
+{
+	if ( color != INVALCOLOR ) {
+		specialColor = VimWrapper::fromColor(color);
+	}
+}
+
+/**
+ * Draw a string in the shell
+ */
+void
+gui_mch_draw_string(
+    int		row,
+    int		col,
+    char_u	*s,
+    int		len,
+    int		flags)
+{
+	QString str = VimWrapper::convertFrom(s, len);
+
+	// Font
+	QFont f = vimshell->font();
+	f.setBold( flags & DRAW_BOLD);
+	f.setUnderline( flags & DRAW_UNDERL);
+	f.setItalic( flags & DRAW_ITALIC);
+
+	QFontMetrics fm(f);
+
+	int cellwidth = VimWrapper::stringCellWidth(str);
+	QPoint pos = VimWrapper::mapText(row, col);
+	QRect rect( pos.x(), pos.y(), gui.char_width*cellwidth, gui.char_height);
+
+	if (flags & DRAW_TRANSP) {
+		// Do we need to do anything?
+	} else {
+		// Fill in the background
+		QVimShell::PaintOperation op;
+		op.type = QVimShell::FILLRECT;
+		op.rect = rect;
+		op.color = backgroundColor;
+		vimshell->queuePaintOp(op);
+	}
+
+	// Remove upper linespace from rect
+	QRect rect_text( pos.x(), pos.y() + p_linespace/2, gui.char_width*cellwidth, gui.char_height);
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWSTRING;
+	op.font = f;
+	op.rect = rect_text;
+	op.str = str;
+	op.color = foregroundColor;
+	op.undercurl = flags & DRAW_UNDERC;
+	if ( op.undercurl ) { // FIXME: Refactor QVimShell::PaintOperation
+		op.curlcolor = specialColor;
+	}
+
+	// op.pos is the text baseline
+	op.pos = rect.topLeft();
+	op.pos.setY( op.pos.y() + gui.char_ascent );
+
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Return the Pixel value (color) for the given color name.
+ * Return INVALCOLOR for error.
+ */
+guicolor_T
+gui_mch_get_color(char_u *reqname)
+{
+	if ( reqname == NULL ) {
+		return INVALCOLOR;
+	}
+	QColor c = vimshell->color(VimWrapper::convertFrom(reqname));
+	if ( c.isValid() ) {
+		return VimWrapper::toColor(c);
+	}
+
+	return INVALCOLOR;
+}
+
+/**
+ * Get the position of the top left corner of the window.
+ */
+int
+gui_mch_get_winpos(int *x, int *y)
+{
+	QPoint pos = window->pos();
+
+	*x = pos.x();
+	*y = pos.y();
+
+	return OK;
+}
+
+void
+gui_mch_set_text_area_pos(int x, int y, int w, int h)
+{
+	/* Do we need to do anything here? */
+}
+
+void
+gui_mch_new_tooltip_font()
+{
+	qDebug() << __func__;
+
+}
+
+void
+gui_mch_new_tooltip_colors()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Show/Hide toolbar
+ */
+void
+gui_mch_show_toolbar(int showit)
+{
+	if ( showit ) {
+		window->showToolbar(true);
+	} else {
+		window->showToolbar(false);
+	}
+}
+
+int
+gui_mch_compute_toolbar_height()
+{
+	/* Do nothing - the main window handles this */
+	return 0;
+}
+
+void
+gui_mch_set_toolbar_pos(int x, int y, int w, int h)
+{
+	/* Do nothing - the main window handles this */
+}
+
+//
+// MENU
+//
+///////////////////
+
+/**
+ * Disable/Enable tearoff for all menus - I'm kind of shocked there is no trivial way to do this
+ *
+ * Given a widget, recursively find all submenus an set tearoff
+ *
+ */
+static void
+toggle_tearoffs(QWidget *widget, bool enable)
+{
+	foreach (QAction *action, widget->actions()) {
+		if ( action->menu() ) {
+			action->menu()->setTearOffEnabled(enable);
+			toggle_tearoffs(action->menu(), enable);
+		}
+	}
+}
+
+/**
+ * Enable/Disable tearoff for all menus
+ */
+void
+gui_mch_toggle_tearoffs(int enable)
+{
+	QMenuBar *mb = window->menuBar();
+	toggle_tearoffs(mb, enable != 0);
+}
+
+/**
+ * Called after all menus are set,
+ */
+void
+gui_mch_draw_menubar()
+{
+}
+
+/**
+ * Disable a menu entry
+ */
+void
+gui_mch_menu_grey(vimmenu_T *menu, int grey)
+{
+	if ( menu == NULL || menu->qaction == NULL )  {
+		return;
+	}
+	menu->qaction->setEnabled( (grey == 0) );
+}
+
+void
+gui_mch_new_menu_colors()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Enable/Disable the application menubar
+ */
+void
+gui_mch_enable_menu(int flag)
+{
+	if (flag) {
+		window->showMenu(true);
+	} else {
+		window->showMenu(false);
+	}
+}
+
+/**
+ * Conceal menu entry
+ */
+void
+gui_mch_menu_hidden(vimmenu_T *menu, int hidden)
+{
+	if ( menu == NULL || menu->qaction == NULL ) {
+		return;
+	}
+	menu->qaction->setVisible( hidden == 0 );
+}
+
+/**
+ * Set the menubar position
+ *
+ * @warn We do nothing - The mainwindow handles this
+ */
+void
+gui_mch_set_menu_pos(int x, int y, int w, int h)
+{
+}
+
+/**
+ * Add a new ( menubar menu | toolbar action | )
+ */
+void
+gui_mch_add_menu(vimmenu_T *menu, int idx)
+{
+	menu->qmenu = NULL;
+	QAction *before=NULL;
+
+	if ( menu_is_popup(menu->name) ) {
+		menu->qmenu = new QMenu(VimWrapper::convertFrom(menu->name), vimshell);
+	} else if ( menu_is_toolbar(menu->name) ) {
+		menu->qmenu = window->toolBar();
+	} else if ( menu->parent == NULL ) {
+		QList<QAction*> actions = window->menuBar()->actions();
+		if ( idx < actions.size() ) {
+			before = actions.at(idx);
+		}
+
+		QMenu *m = new QMenu(VimWrapper::convertFrom(menu->name), window);
+		window->menuBar()->insertMenu( before, m);
+		menu->qmenu = m;
+	} else if ( menu->parent && menu->parent->qmenu ) {
+		QMenu *parent = (QMenu*)menu->parent->qmenu;
+		QList<QAction*> actions = parent->actions();
+		if ( idx < actions.size() ) {
+			before = actions.at(idx);
+		}
+
+		QMenu *m = new QMenu(VimWrapper::convertFrom(menu->name), window);
+		parent->insertMenu( before, m);
+		menu->qmenu = m;
+	}
+}
+
+/**
+ * Add menu item to menu
+ */
+void
+gui_mch_add_menu_item(vimmenu_T *menu, int idx)
+{
+	menu->qmenu = NULL;
+	if ( menu->parent == NULL || menu->parent->qmenu == NULL ) {
+		return;
+	}
+
+	QList<QAction*> actions = menu->parent->qmenu->actions();
+	QAction *before=NULL;
+	if ( idx < actions.size() ) {
+		before = actions.at(idx);
+	}
+
+	if ( menu_is_toolbar(menu->parent->name) ) {
+		// Toolbar
+		QToolBar *b = (QToolBar*)menu->parent->qmenu;
+		if (menu_is_separator(menu->name)) {
+			b->addSeparator();
+		} else {
+			QAction *action = new VimAction( menu, window );
+			b->insertAction(before, action);
+			menu->qaction = action;
+		}
+	} else {
+		// Menu entries
+		QMenu *m = (QMenu *)menu->parent->qmenu;
+		if (menu_is_separator(menu->name)) {
+			m->addSeparator();
+		} else {
+			QAction *action = new VimAction( menu, window );
+			m->insertAction(before, action);
+			menu->qaction = action;
+		}
+	}
+}
+
+void
+gui_mch_new_menu_font()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Destroy menu
+ *
+ * Remove menu from parent and delete it
+ */
+void
+gui_mch_destroy_menu(vimmenu_T *menu)
+{
+	QMenu *parent = NULL;
+	if ( menu->parent ) {
+		parent = (QMenu*)menu->parent->qmenu;
+	}
+
+	if ( menu->qmenu != NULL ) {
+		QMenu *m = (QMenu*)menu->qmenu;
+
+		if ( parent ) {
+			parent->removeAction(m->menuAction());
+		} else {
+			window->menuBar()->removeAction(m->menuAction());
+		}
+		menu->qmenu->deleteLater();
+	}
+
+	if ( menu->qaction != NULL ) {
+		QAction *a = (QAction*)menu->qaction;
+
+		if ( parent ) {
+			parent->removeAction(a);
+		}
+		menu->qaction->deleteLater();
+	}
+
+}
+
+void gui_mch_show_popupmenu(vimmenu_T *menu)
+{
+	if ( menu == NULL || menu->qmenu == NULL ) {
+		return;
+	}
+
+	QMenu *m = (QMenu*)menu->qmenu;
+	m->popup( QCursor::pos() );
+}
+
+/**
+ * Set the menu and scrollbar colors to their default values.
+ */
+void
+gui_mch_def_colors()
+{
+	gui.norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.back_pixel = VimWrapper::toColor(QColor(Qt::white));
+	gui.def_norm_pixel = gui.norm_pixel;
+	gui.def_back_pixel = gui.back_pixel;
+}
+
+//
+//
+// Scrollbar
+//
+
+void
+gui_mch_set_scrollbar_thumb(scrollbar_T *sb, long val, long size, long max)
+{
+	sb->wid->setValue(val);
+	sb->wid->setMaximum(max);
+	sb->wid->setPageStep(size);
+
+	sb->wid->setEnabled( !(size > max) );
+}
+
+/**
+ * Set scrollbar geometry
+ */
+void
+gui_mch_set_scrollbar_pos(scrollbar_T *sb, int x, int y, int width, int height)
+{
+	switch(sb->type) {
+	case SBAR_RIGHT:
+	case SBAR_LEFT:
+		sb->wid->setLength(height);
+		sb->wid->setIndex(y);
+		break;
+	default:
+		sb->wid->setLength(width);
+		sb->wid->setIndex(x);
+	}
+}
+
+/**
+ *
+ * Hide/Show scrollbar
+ *
+ */
+void
+gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)
+{
+	/*
+	sb->wid->setVisible(flag);
+	*/
+}
+
+/**
+ * Create a new scrollbar
+ */
+void
+gui_mch_create_scrollbar( scrollbar_T *sb, int orient)
+{
+	Qt::Orientation dir;
+	if ( orient == SBAR_HORIZ) {
+		dir = Qt::Horizontal;
+	} else {
+		dir = Qt::Vertical;
+	}
+
+	VimScrollBar *widget = new VimScrollBar( sb, dir, window);
+	widget->setVisible(false);
+	sb->wid = widget;
+
+	switch(sb->type) {
+	case SBAR_RIGHT:
+//		window->addScrollbarRight(widget);
+		break;
+	case SBAR_LEFT:
+//		window->addScrollbarLeft(widget);
+		break;
+	case SBAR_BOTTOM:
+//		window->addScrollbarBottom(widget);
+		break;
+	}
+}
+
+/**
+ * Destroy a scrollbar
+ */
+void
+gui_mch_destroy_scrollbar(scrollbar_T *sb)
+{
+	sb->wid->hide();
+	sb->wid->deleteLater();
+	sb->wid = NULL;
+}
+
+/**
+ *
+ * Pop open a file browser and return the file selected, in allocated memory,
+ * or NULL if Cancel is hit.
+ *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
+ *  title   - Title message for the file browser dialog.
+ *  dflt    - Default name of file.
+ *  ext     - Default extension to be added to files without extensions.
+ *  initdir - directory in which to open the browser (NULL = current dir)
+ *  filter  - Filter for matched files to choose from.
+ *
+ *  @see :h browsefilter
+ */
+char_u *
+gui_mch_browse(int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *vimfilter)
+{
+
+	QStringList res_filter ;
+	QString filters = VimWrapper::convertFrom(vimfilter);
+	filters.replace("(", "[").replace(")", "]");
+	QStringListIterator it(filters.split('\n', QString::SkipEmptyParts));
+	while (it.hasNext())
+	{
+		QString s = it.next();
+		int index = s.lastIndexOf('\t');
+		if (-1 != index)
+		{
+			QString new_str = s.mid(index+1).replace(";"," ");
+			res_filter << s.left(index) << "(" << new_str << ")" << ";;" ;
+		}
+	}
+	QString filterstr =  res_filter.join("") ;
+
+	QString dir;
+	if ( initdir == NULL ) {
+		dir = "";
+	} else {
+		dir = VimWrapper::convertFrom(initdir);
+	}
+
+	window->setEnabled(false);
+	QString file;
+	if ( saving ) {
+		file = QFileDialog::getSaveFileName(window, VimWrapper::convertFrom(title), dir, filterstr);
+	} else {
+		file = QFileDialog::getOpenFileName(window, VimWrapper::convertFrom(title), dir, filterstr);
+	}
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	if ( file.isEmpty() ) {
+		return NULL;
+	}
+
+	return vim_strsave((char_u *) VimWrapper::convertTo(file).data());
+}
+
+
+/**
+ * Open a dialog window
+ */
+int
+gui_mch_dialog(int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd)
+{
+	QMessageBox msgBox(window);
+	msgBox.setText( VimWrapper::convertFrom(message) );
+	msgBox.setWindowTitle( VimWrapper::convertFrom(title) );
+
+	// Set icon
+	QMessageBox::Icon icon;
+	switch (type)
+	{
+		case VIM_GENERIC:
+			icon = QMessageBox::NoIcon;
+			break;
+		case VIM_ERROR:
+			icon = QMessageBox::Critical;
+			break;
+		case VIM_WARNING:
+			icon = QMessageBox::Warning;
+			break;
+		case VIM_INFO:
+			icon = QMessageBox::Information;
+			break;
+		case VIM_QUESTION:
+			icon = QMessageBox::Question;
+			break;
+		default:
+			icon = QMessageBox::NoIcon;
+	};
+	msgBox.setIcon(icon);
+
+	// Add buttons
+	QList<QPushButton *> buttonList;
+	if ( buttons != NULL ) {
+		QStringList b_string;
+
+		b_string = VimWrapper::convertFrom(buttons).split(DLG_BUTTON_SEP);
+
+		QListIterator<QString> it(b_string);
+		int bt=1;
+		while(it.hasNext()) {
+			QPushButton *b = msgBox.addButton( it.next(), QMessageBox::ApplyRole);
+			buttonList.append(b);
+
+			if ( bt == dfltbutton ) {
+				b->setDefault(true);
+			}
+			bt++;
+		}
+	}
+
+	window->setEnabled(false);
+	msgBox.setEnabled(true);
+
+	msgBox.exec();
+
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	if ( msgBox.clickedButton() == 0 ) {
+		return 0;
+	}
+
+	int i=1;
+	QListIterator<QPushButton *> it(buttonList);
+	while( it.hasNext() ){
+		QPushButton *b = it.next();
+		if ( b == msgBox.clickedButton() ) {
+			return i;
+		}
+		i++;
+	}
+	return -1;
+}
+
+//
+// TabLine
+//
+
+/**
+ * Show or hide the tabline.
+ */
+void
+gui_mch_show_tabline(int showit)
+{
+	window->showTabline(showit != 0);
+}
+
+/**
+ * Return TRUE when tabline is displayed.
+ */
+int
+gui_mch_showing_tabline(void)
+{
+	if ( window->tablineVisible() ) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/**
+ * Update the labels of the tabline.
+ */
+void
+gui_mch_update_tabline(void)
+{
+	tabpage_T *tp;
+	int current = 0;
+	int nr = 0;
+
+	for (tp = first_tabpage; tp != NULL; tp = tp->tp_next, nr++)
+	{
+		if (tp == curtab) {
+			current = nr;
+		}
+
+		get_tabline_label(tp, FALSE);
+		char_u *labeltext = CONVERT_TO_UTF8(NameBuff);
+		window->setTab( nr, VimWrapper::convertFrom(labeltext));
+		CONVERT_TO_UTF8_FREE(labeltext);
+	}
+	window->removeTabs(nr);
+	window->setCurrentTab(current);
+}
+
+/**
+ * Change the current tab
+ */
+void
+gui_mch_set_curtab(int nr)
+{
+	window->setCurrentTab(nr-1);
+}
+
+/**
+ * Launch font selection dialog
+ * @oldval is the name of the current font
+ *
+ * @return The name of the font or NULL on cancel
+ */
+char_u *
+gui_mch_font_dialog(char_u *oldval)
+{
+	QFont *oldfont = gui_mch_get_font(oldval, 0);
+
+	char_u *rval = NULL;
+	bool ok;
+	static FontDialog *dialog = new FontDialog(window);
+	if ( oldfont != NULL ) {
+		dialog->selectCurrentFont(*oldfont);
+	}
+
+	window->setEnabled(false);
+	dialog->setEnabled(true);
+	if ( dialog->exec() == QDialog::Accepted ) {
+		QFont f =  dialog->selectedFont();
+		QByteArray text = VimWrapper::convertTo( QString("%1 %2").arg(f.family()).arg(f.pointSize()) );
+		if ( text.isEmpty() ) {
+			// This should not happen, but if it does vim
+			// behaves badly so lets be extra carefull
+			goto out;
+		}
+		text.append('\0');
+
+		char_u *buffer;
+		buffer = lalloc( text.size(), TRUE);
+		for (int i = 0; i < text.size(); ++i) {
+			buffer[i] = text[i];
+		}
+		rval = buffer;
+	}
+
+out:
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	return rval;
+}
+
+/**
+ * Draw an icon in the shell widget
+ *
+ */
+void
+gui_mch_drawsign(int row, int col, int typenr)
+{
+	QIcon *icon = (QIcon *)sign_get_image(typenr);
+	if ( !icon ) {
+		return;
+	}
+
+	QPoint pos = VimWrapper::mapText(row, col);
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWSIGN;
+	op.pos = pos;
+	op.sign = icon->pixmap( VimWrapper::charWidth()*2, VimWrapper::charHeight() );
+	op.rect = QRect(pos, QSize(VimWrapper::charWidth()*2, VimWrapper::charHeight()));
+
+	if (op.sign.isNull()) {
+		// FIXME: this should not happen
+		return;
+	}
+	vimshell->queuePaintOp(op);
+}
+
+
+/*
+ * Free memory associated with the sign
+ */
+void
+gui_mch_destroy_sign(void *sign)
+{
+	if ( sign ) {
+		delete (QIcon*)sign;
+	}
+}
+
+/**
+ * Register an icon with the given name
+ *
+ * The name can be:
+ *  1. A file path to an icon
+ *  1. A theme icon name
+ *
+ */
+void *
+gui_mch_register_sign(char_u *signfile)
+{
+	if ( !signfile || !signfile[0] ) {
+		return NULL;
+	}
+
+	QString name = VimWrapper::convertFrom(signfile);
+	QIcon icon(name);
+
+	//
+	// FIXME: QIcon::isNull may be false even the icon cannot
+	// provide a pixmap, so far this is the best alternative I
+	// have
+	if ( icon.availableSizes().isEmpty() ) {
+		icon = QIcon(QIcon::fromTheme(name));
+		if ( icon.availableSizes().isEmpty() ) {
+			EMSG(e_signdata);
+			return NULL;
+		}
+	}
+
+	if ( icon.availableSizes().isEmpty() ) {
+		return NULL;
+	}
+
+	return new QIcon(icon);
+}
+
+} // extern "C"
diff -urN vim-src/src/gui_w16.c vim-qt-src/src/gui_w16.c
--- vim-src/src/gui_w16.c	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/gui_w16.c	2016-06-08 06:39:27.723315165 +0200
@@ -0,0 +1,1564 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *				GUI support by Robert Webb
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+/*
+ * gui_w16.c
+ *
+ * GUI support for Microsoft Windows 3.1x
+ *
+ * George V. Reilly <george@reilly.org> wrote the original Win32 GUI.
+ * Robert Webb reworked it to use the existing GUI stuff and added menu,
+ * scrollbars, etc.
+ *
+ * Vince Negri then butchered the code to get it compiling for
+ * 16-bit windows.
+ *
+ */
+
+/* Win16 doesn't use the "W" methods. */
+#define pDispatchMessage DispatchMessage
+#define pGetMessage GetMessage
+#define pIsDialogMessage IsDialogMessage
+#define pPeekMessage PeekMessage
+
+/*
+ * Include the common stuff for MS-Windows GUI.
+ */
+#include "gui_w48.c"
+
+#include "guiw16rc.h"
+
+/* Undocumented Windows Message - not even defined in some SDK headers */
+#define WM_EXITSIZEMOVE			0x0232
+
+
+#ifdef FEAT_TOOLBAR
+# define CMD_TB_BASE (99)
+# include <vimtbar.h>
+#endif
+
+#ifdef PROTO
+# define WINAPI
+#endif
+
+#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (HDROP)(wParam)), 0L)
+
+
+/* Local variables: */
+
+#ifdef FEAT_MENU
+static UINT	s_menu_id = 100;
+#endif
+
+
+#define VIM_NAME	"vim"
+#define VIM_CLASS	"Vim"
+
+#define DLG_ALLOC_SIZE 16 * 1024
+
+/*
+ * stuff for dialogs, menus, tearoffs etc.
+ */
+#if defined(FEAT_GUI_DIALOG) || defined(PROTO)
+static BOOL CALLBACK dialog_callback(HWND, UINT, WPARAM, LPARAM);
+
+static LPWORD
+add_dialog_element(
+	LPWORD p,
+	DWORD lStyle,
+	WORD x,
+	WORD y,
+	WORD w,
+	WORD h,
+	WORD Id,
+	BYTE clss,
+	const char *caption);
+
+static int dialog_default_button = -1;
+#endif
+
+static void get_dialog_font_metrics(void);
+
+#ifdef FEAT_TOOLBAR
+static void initialise_toolbar(void);
+#endif
+
+
+#ifdef FEAT_MENU
+/*
+ * Figure out how high the menu bar is at the moment.
+ */
+    static int
+gui_mswin_get_menu_height(
+    int	    fix_window)	    /* If TRUE, resize window if menu height changed */
+{
+    static int	old_menu_height = -1;
+
+    int	    num;
+    int	    menu_height;
+
+    if (gui.menu_is_active)
+	num = GetMenuItemCount(s_menuBar);
+    else
+	num = 0;
+
+    if (num == 0)
+	menu_height = 0;
+    else if (gui.starting)
+	menu_height = GetSystemMetrics(SM_CYMENU);
+    else
+    {
+	RECT r1, r2;
+	int frameht = GetSystemMetrics(SM_CYFRAME);
+	int capht = GetSystemMetrics(SM_CYCAPTION);
+
+	/*	get window rect of s_hwnd
+		 * get client rect of s_hwnd
+		 * get cap height
+		 * subtract from window rect, the sum of client height,
+		 * (if not maximized)frame thickness, and caption height.
+	 */
+	GetWindowRect(s_hwnd, &r1);
+	GetClientRect(s_hwnd, &r2);
+	menu_height = r1.bottom - r1.top - (r2.bottom-r2.top +
+			       2 * frameht * (!IsZoomed(s_hwnd)) + capht);
+    }
+
+    if (fix_window && menu_height != old_menu_height)
+    {
+	old_menu_height = menu_height;
+	gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);
+    }
+
+    return menu_height;
+}
+#endif /*FEAT_MENU*/
+
+
+/*
+ * Even though we have _DuringSizing() which makes the rubber band a valid
+ * size, we need this for when the user maximises the window.
+ * TODO: Doesn't seem to adjust the width though for some reason.
+ */
+    static BOOL
+_OnWindowPosChanging(
+    HWND hwnd,
+    LPWINDOWPOS lpwpos)
+{
+
+    if (!IsIconic(hwnd) && !(lpwpos->flags & SWP_NOSIZE))
+    {
+	gui_mswin_get_valid_dimensions(lpwpos->cx, lpwpos->cy,
+				     &lpwpos->cx, &lpwpos->cy);
+    }
+    return 0;
+}
+
+
+
+
+
+    static LRESULT CALLBACK
+_WndProc(
+    HWND hwnd,
+    UINT uMsg,
+    WPARAM wParam,
+    LPARAM lParam)
+{
+    /*
+    TRACE("WndProc: hwnd = %08x, msg = %x, wParam = %x, lParam = %x\n",
+	  hwnd, uMsg, wParam, lParam);
+    */
+
+    HandleMouseHide(uMsg, lParam);
+
+    s_uMsg = uMsg;
+    s_wParam = wParam;
+    s_lParam = lParam;
+
+    switch (uMsg)
+    {
+	HANDLE_MSG(hwnd, WM_DEADCHAR,	_OnDeadChar);
+	HANDLE_MSG(hwnd, WM_SYSDEADCHAR, _OnDeadChar);
+	/* HANDLE_MSG(hwnd, WM_ACTIVATE,    _OnActivate); */
+	HANDLE_MSG(hwnd, WM_CHAR,	_OnChar);
+	HANDLE_MSG(hwnd, WM_CLOSE,	_OnClose);
+	/* HANDLE_MSG(hwnd, WM_COMMAND,	_OnCommand); */
+	HANDLE_MSG(hwnd, WM_DESTROY,	_OnDestroy);
+	HANDLE_MSG(hwnd, WM_DROPFILES,	_OnDropFiles);
+	HANDLE_MSG(hwnd, WM_HSCROLL,	_OnScroll);
+	HANDLE_MSG(hwnd, WM_KILLFOCUS,	_OnKillFocus);
+#ifdef FEAT_MENU
+	HANDLE_MSG(hwnd, WM_COMMAND,	_OnMenu);
+#endif
+	/* HANDLE_MSG(hwnd, WM_MOVE,	    _OnMove); */
+	/* HANDLE_MSG(hwnd, WM_NCACTIVATE,  _OnNCActivate); */
+	HANDLE_MSG(hwnd, WM_SETFOCUS,	_OnSetFocus);
+	HANDLE_MSG(hwnd, WM_SIZE,	_OnSize);
+	/* HANDLE_MSG(hwnd, WM_SYSCOMMAND,  _OnSysCommand); */
+	/* HANDLE_MSG(hwnd, WM_SYSKEYDOWN,  _OnAltKey); */
+	HANDLE_MSG(hwnd, WM_VSCROLL,	_OnScroll);
+	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGING,	_OnWindowPosChanging);
+	HANDLE_MSG(hwnd, WM_ACTIVATEAPP, _OnActivateApp);
+
+    case WM_QUERYENDSESSION:	/* System wants to go down. */
+	gui_shell_closed();	/* Will exit when no changed buffers. */
+	return FALSE;		/* Do NOT allow system to go down. */
+
+    case WM_ENDSESSION:
+	if (wParam)	/* system only really goes down when wParam is TRUE */
+	    _OnEndSession();
+	break;
+
+    case WM_SYSCHAR:
+	/*
+	 * if 'winaltkeys' is "no", or it's "menu" and it's not a menu
+	 * shortcut key, handle like a typed ALT key, otherwise call Windows
+	 * ALT key handling.
+	 */
+#ifdef FEAT_MENU
+	if (	!gui.menu_is_active
+		|| p_wak[0] == 'n'
+		|| (p_wak[0] == 'm' && !gui_is_menu_shortcut((int)wParam))
+		)
+#endif
+	    return HANDLE_WM_SYSCHAR((hwnd), (wParam), (lParam), (_OnSysChar));
+#ifdef FEAT_MENU
+	else
+	    return MyWindowProc(hwnd, uMsg, wParam, lParam);
+#endif
+
+    case WM_SYSKEYUP:
+#ifdef FEAT_MENU
+	/* Only when menu is active, ALT key is used for that. */
+	if (gui.menu_is_active)
+	{
+	    return MyWindowProc(hwnd, uMsg, wParam, lParam);
+	}
+	else
+#endif
+	    return 0;
+
+#if defined(MENUHINTS) && defined(FEAT_MENU)
+    case WM_MENUSELECT:
+	if (((UINT) LOWORD(lParam)
+		    & (0xffff ^ (MF_MOUSESELECT + MF_BITMAP + MF_POPUP)))
+		== MF_HILITE
+		&& (State & CMDLINE) == 0)
+	{
+	    UINT idButton;
+	    int	idx;
+	    vimmenu_T *pMenu;
+
+	    idButton = (UINT)LOWORD(wParam);
+	    pMenu = gui_mswin_find_menu(root_menu, idButton);
+	    if (pMenu)
+	    {
+		idx = MENU_INDEX_TIP;
+		msg_clr_cmdline();
+		if (pMenu->strings[idx])
+		    msg(pMenu->strings[idx]);
+		else
+		    msg("");
+		setcursor();
+		out_flush();
+	    }
+	}
+	break;
+#endif
+    case WM_NCHITTEST:
+	{
+	    LRESULT	result;
+	    int x, y;
+	    int xPos = GET_X_LPARAM(lParam);
+
+	    result = MyWindowProc(hwnd, uMsg, wParam, lParam);
+	    if (result == HTCLIENT)
+	    {
+		(void)gui_mch_get_winpos(&x, &y);
+		xPos -= x;
+
+		if (xPos < 48) /*<VN> TODO should use system metric?*/
+		    return HTBOTTOMLEFT;
+		else
+		    return HTBOTTOMRIGHT;
+		}
+	    else
+		return result;
+	}
+	/* break; */
+    default:
+#ifdef MSWIN_FIND_REPLACE
+	if (uMsg == s_findrep_msg && s_findrep_msg != 0)
+	{
+	    _OnFindRepl();
+	}
+#endif
+	return MyWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+
+    return 1;
+}
+
+
+
+/*
+ * End of call-back routines
+ */
+
+
+/*
+ * Parse the GUI related command-line arguments.  Any arguments used are
+ * deleted from argv, and *argc is decremented accordingly.  This is called
+ * when vim is started, whether or not the GUI has been started.
+ */
+    void
+gui_mch_prepare(int *argc, char **argv)
+{
+    /* No special args for win16 GUI at the moment. */
+
+}
+
+/*
+ * Initialise the GUI.	Create all the windows, set up all the call-backs
+ * etc.
+ */
+    int
+gui_mch_init(void)
+{
+    const char szVimWndClass[] = VIM_CLASS;
+    const char szTextAreaClass[] = "VimTextArea";
+    WNDCLASS wndclass;
+
+#ifdef WIN16_3DLOOK
+    Ctl3dRegister(s_hinst);
+    Ctl3dAutoSubclass(s_hinst);
+#endif
+
+    /* Display any pending error messages */
+    display_errors();
+
+    gui.scrollbar_width = GetSystemMetrics(SM_CXVSCROLL);
+    gui.scrollbar_height = GetSystemMetrics(SM_CYHSCROLL);
+#ifdef FEAT_MENU
+    gui.menu_height = 0;	/* Windows takes care of this */
+#endif
+    gui.border_width = 0;
+
+    gui.currBgColor = INVALCOLOR;
+
+    s_brush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
+
+    if (GetClassInfo(s_hinst, szVimWndClass, &wndclass) == 0) {
+	wndclass.style = 0;
+	wndclass.lpfnWndProc = _WndProc;
+	wndclass.cbClsExtra = 0;
+	wndclass.cbWndExtra = 0;
+	wndclass.hInstance = s_hinst;
+	wndclass.hIcon = LoadIcon(wndclass.hInstance, MAKEINTRESOURCE(IDR_VIM));
+	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
+	wndclass.hbrBackground = s_brush;
+	wndclass.lpszMenuName = NULL;
+	wndclass.lpszClassName = szVimWndClass;
+
+    if ((
+#ifdef GLOBAL_IME
+	atom =
+#endif
+		RegisterClass(&wndclass)) == 0)
+	    return FAIL;
+    }
+
+    s_hwnd = CreateWindow(
+	szVimWndClass, "Vim MSWindows GUI",
+	WS_OVERLAPPEDWINDOW,
+	gui_win_x == -1 ? CW_USEDEFAULT : gui_win_x,
+	gui_win_y == -1 ? CW_USEDEFAULT : gui_win_y,
+	100,				/* Any value will do */
+	100,				/* Any value will do */
+	NULL, NULL,
+	s_hinst, NULL);
+
+    if (s_hwnd == NULL)
+	return FAIL;
+
+#ifdef GLOBAL_IME
+    global_ime_init(atom, s_hwnd);
+#endif
+
+    /* Create the text area window */
+    if (GetClassInfo(s_hinst, szTextAreaClass, &wndclass) == 0) {
+	wndclass.style = CS_OWNDC;
+	wndclass.lpfnWndProc = _TextAreaWndProc;
+	wndclass.cbClsExtra = 0;
+	wndclass.cbWndExtra = 0;
+	wndclass.hInstance = s_hinst;
+	wndclass.hIcon = NULL;
+	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
+	wndclass.hbrBackground = NULL;
+	wndclass.lpszMenuName = NULL;
+	wndclass.lpszClassName = szTextAreaClass;
+
+	if (RegisterClass(&wndclass) == 0)
+	    return FAIL;
+    }
+    s_textArea = CreateWindow(
+	szTextAreaClass, "Vim text area",
+	WS_CHILD | WS_VISIBLE, 0, 0,
+	100,				/* Any value will do for now */
+	100,				/* Any value will do for now */
+	s_hwnd, NULL,
+	s_hinst, NULL);
+
+    if (s_textArea == NULL)
+	return FAIL;
+
+#ifdef FEAT_MENU
+    s_menuBar = CreateMenu();
+#endif
+    s_hdc = GetDC(s_textArea);
+
+#ifdef MSWIN16_FASTTEXT
+    SetBkMode(s_hdc, OPAQUE);
+#endif
+
+    DragAcceptFiles(s_hwnd, TRUE);
+
+    /* Do we need to bother with this? */
+    /* m_fMouseAvail = GetSystemMetrics(SM_MOUSEPRESENT); */
+
+    /* Get background/foreground colors from the system */
+    gui_mch_def_colors();
+
+    /* Get the colors from the "Normal" group (set in syntax.c or in a vimrc
+     * file) */
+    set_normal_colors();
+
+    /*
+     * Check that none of the colors are the same as the background color.
+     * Then store the current values as the defaults.
+     */
+    gui_check_colors();
+    gui.def_norm_pixel = gui.norm_pixel;
+    gui.def_back_pixel = gui.back_pixel;
+
+    /* Get the colors for the highlight groups (gui_check_colors() might have
+     * changed them) */
+    highlight_gui_started();
+
+    /*
+     * Start out by adding the configured border width into the border offset
+     */
+    gui.border_offset = gui.border_width;
+
+
+    /*
+     * compute a couple of metrics used for the dialogs
+     */
+    get_dialog_font_metrics();
+#ifdef FEAT_TOOLBAR
+    /*
+     * Create the toolbar
+     */
+    initialise_toolbar();
+#endif
+#ifdef MSWIN_FIND_REPLACE
+    /*
+     * Initialise the dialog box stuff
+     */
+    s_findrep_msg = RegisterWindowMessage(FINDMSGSTRING);
+
+    /* Initialise the struct */
+    s_findrep_struct.lStructSize = sizeof(s_findrep_struct);
+    s_findrep_struct.lpstrFindWhat = alloc(MSWIN_FR_BUFSIZE);
+    s_findrep_struct.lpstrFindWhat[0] = NUL;
+    s_findrep_struct.lpstrReplaceWith = alloc(MSWIN_FR_BUFSIZE);
+    s_findrep_struct.lpstrReplaceWith[0] = NUL;
+    s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
+    s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
+#endif
+
+    return OK;
+}
+
+
+/*
+ * Set the size of the window to the given width and height in pixels.
+ */
+    void
+gui_mch_set_shellsize(int width, int height,
+	int min_width, int min_height, int base_width, int base_height,
+	int direction)
+{
+    RECT	workarea_rect;
+    int		win_width, win_height;
+    int		win_xpos, win_ypos;
+    WINDOWPLACEMENT wndpl;
+
+    /* try to keep window completely on screen */
+    /* get size of the screen work area - use SM_CYFULLSCREEN
+     * instead of SM_CYSCREEN so that we don't overlap the
+     * taskbar if someone fires us up on Win95/NT */
+    workarea_rect.left = 0;
+    workarea_rect.top = 0;
+    workarea_rect.right = GetSystemMetrics(SM_CXSCREEN);
+    workarea_rect.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
+
+    /* get current position of our window */
+    wndpl.length = sizeof(WINDOWPLACEMENT);
+    GetWindowPlacement(s_hwnd, &wndpl);
+    if (wndpl.showCmd == SW_SHOWNORMAL)
+    {
+	win_xpos = wndpl.rcNormalPosition.left;
+	win_ypos = wndpl.rcNormalPosition.top;
+    }
+    else
+    {
+	win_xpos = workarea_rect.left;
+	win_ypos = workarea_rect.top;
+    }
+
+    /* compute the size of the outside of the window */
+    win_width = width + GetSystemMetrics(SM_CXFRAME) * 2;
+    win_height = height + GetSystemMetrics(SM_CYFRAME) * 2
+			+ GetSystemMetrics(SM_CYCAPTION)
+#ifdef FEAT_MENU
+			+ gui_mswin_get_menu_height(FALSE)
+#endif
+			;
+
+    /* if the window is going off the screen, move it on to the screen */
+    if ((direction & RESIZE_HOR) && win_xpos + win_width > workarea_rect.right)
+	win_xpos = workarea_rect.right - win_width;
+
+    if ((direction & RESIZE_HOR) && win_xpos < workarea_rect.left)
+	win_xpos = workarea_rect.left;
+
+    if ((direction & RESIZE_VERT)
+			       && win_ypos + win_height > workarea_rect.bottom)
+	win_ypos = workarea_rect.bottom - win_height;
+
+    if ((direction & RESIZE_VERT) && win_ypos < workarea_rect.top)
+	win_ypos = workarea_rect.top;
+
+    /* set window position */
+    SetWindowPos(s_hwnd, NULL, win_xpos, win_ypos, win_width, win_height,
+		 SWP_NOZORDER | SWP_NOACTIVATE);
+
+#ifdef FEAT_MENU
+    /* Menu may wrap differently now */
+    gui_mswin_get_menu_height(!gui.starting);
+#endif
+}
+
+    void
+gui_mch_set_scrollbar_thumb(
+    scrollbar_T     *sb,
+    long	    val,
+    long	    size,
+    long	    max)
+{
+    sb->scroll_shift = 0;
+    while (max > 32767)
+    {
+	max = (max + 1) >> 1;
+	val  >>= 1;
+	size >>= 1;
+	++sb->scroll_shift;
+    }
+
+    if (sb->scroll_shift > 0)
+	++size;
+
+    SetScrollRange(sb->id, SB_CTL, 0, (int) max, FALSE);
+    SetScrollPos(sb->id, SB_CTL, (int) val, TRUE);
+}
+
+
+/*
+ * Set the current text font.
+ */
+    void
+gui_mch_set_font(GuiFont font)
+{
+    gui.currFont = font;
+    SelectFont(s_hdc, gui.currFont);
+}
+
+/*
+ * Set the current text foreground color.
+ */
+    void
+gui_mch_set_fg_color(guicolor_T color)
+{
+    gui.currFgColor = color;
+    SetTextColor(s_hdc, gui.currFgColor);
+}
+
+/*
+ * Set the current text background color.
+ */
+    void
+gui_mch_set_bg_color(guicolor_T color)
+{
+    if (gui.currBgColor == color)
+	return;
+
+    gui.currBgColor = color;
+    SetBkColor(s_hdc, gui.currBgColor);
+}
+
+/*
+ * Set the current text special color.
+ */
+    void
+gui_mch_set_sp_color(guicolor_T color)
+{
+    /* TODO */
+}
+
+
+
+    void
+gui_mch_draw_string(
+    int		row,
+    int		col,
+    char_u	*text,
+    int		len,
+    int		flags)
+{
+#ifndef MSWIN16_FASTTEXT
+    static int	*padding = NULL;
+    static int	pad_size = 0;
+    int		i;
+#endif
+    HPEN	hpen, old_pen;
+    int		y;
+
+#ifndef MSWIN16_FASTTEXT
+    /*
+     * Italic and bold text seems to have an extra row of pixels at the bottom
+     * (below where the bottom of the character should be).  If we draw the
+     * characters with a solid background, the top row of pixels in the
+     * character below will be overwritten.  We can fix this by filling in the
+     * background ourselves, to the correct character proportions, and then
+     * writing the character in transparent mode.  Still have a problem when
+     * the character is "_", which gets written on to the character below.
+     * New fix: set gui.char_ascent to -1.  This shifts all characters up one
+     * pixel in their slots, which fixes the problem with the bottom row of
+     * pixels.	We still need this code because otherwise the top row of pixels
+     * becomes a problem. - webb.
+     */
+    HBRUSH	hbr;
+    RECT	rc;
+
+    if (!(flags & DRAW_TRANSP))
+    {
+	/*
+	 * Clear background first.
+	 * Note: FillRect() excludes right and bottom of rectangle.
+	 */
+	rc.left = FILL_X(col);
+	rc.top = FILL_Y(row);
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	{
+	    /* Compute the length in display cells. */
+	    rc.right = FILL_X(col + mb_string2cells(text, len));
+	}
+	else
+#endif
+	    rc.right = FILL_X(col + len);
+	rc.bottom = FILL_Y(row + 1);
+	hbr = CreateSolidBrush(gui.currBgColor);
+	FillRect(s_hdc, &rc, hbr);
+	DeleteBrush(hbr);
+
+	SetBkMode(s_hdc, TRANSPARENT);
+
+	/*
+	 * When drawing block cursor, prevent inverted character spilling
+	 * over character cell (can happen with bold/italic)
+	 */
+	if (flags & DRAW_CURSOR)
+	{
+	    pcliprect = &rc;
+	    foptions = ETO_CLIPPED;
+	}
+    }
+#else
+    /*
+     * Alternative: write the characters in opaque mode, since we have blocked
+     * bold or italic fonts.
+     */
+    /* The OPAQUE mode and backcolour have already been set */
+#endif
+    /* The forecolor and font have already been set */
+
+#ifndef MSWIN16_FASTTEXT
+
+    if (pad_size != Columns || padding == NULL || padding[0] != gui.char_width)
+    {
+	vim_free(padding);
+	pad_size = Columns;
+
+	padding = (int *)alloc(pad_size * sizeof(int));
+	if (padding != NULL)
+	    for (i = 0; i < pad_size; i++)
+		padding[i] = gui.char_width;
+    }
+#endif
+
+    /*
+     * We have to provide the padding argument because italic and bold versions
+     * of fixed-width fonts are often one pixel or so wider than their normal
+     * versions.
+     * No check for DRAW_BOLD, Windows will have done it already.
+     */
+#ifndef MSWIN16_FASTTEXT
+    ExtTextOut(s_hdc, TEXT_X(col), TEXT_Y(row), 0, NULL,
+						     (char *)text, len, padding);
+#else
+    TextOut(s_hdc, TEXT_X(col), TEXT_Y(row), (char *)text, len);
+#endif
+
+    if (flags & DRAW_UNDERL)
+    {
+	hpen = CreatePen(PS_SOLID, 1, gui.currFgColor);
+	old_pen = SelectObject(s_hdc, hpen);
+	/* When p_linespace is 0, overwrite the bottom row of pixels.
+	 * Otherwise put the line just below the character. */
+	y = FILL_Y(row + 1) - 1;
+#ifndef MSWIN16_FASTTEXT
+	if (p_linespace > 1)
+	    y -= p_linespace - 1;
+#endif
+	MoveToEx(s_hdc, FILL_X(col), y, NULL);
+	/* Note: LineTo() excludes the last pixel in the line. */
+	LineTo(s_hdc, FILL_X(col + len), y);
+	DeleteObject(SelectObject(s_hdc, old_pen));
+    }
+}
+
+
+/*
+ * Output routines.
+ */
+
+/* Flush any output to the screen */
+    void
+gui_mch_flush(void)
+{
+    /* Is anything needed here? */
+}
+
+    static void
+clear_rect(RECT *rcp)
+{
+    /* Use trick for fast rect clear */
+    gui_mch_set_bg_color(gui.back_pixel);
+    ExtTextOut(s_hdc, 0, 0, ETO_CLIPPED | ETO_OPAQUE, rcp, NULL, 0, NULL);
+}
+
+
+    void
+gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
+{
+
+    *screen_w = GetSystemMetrics(SM_CXFULLSCREEN)
+	      - GetSystemMetrics(SM_CXFRAME) * 2;
+    /* FIXME: dirty trick: Because the gui_get_base_height() doesn't include
+     * the menubar for MSwin, we subtract it from the screen height, so that
+     * the window size can be made to fit on the screen. */
+    *screen_h = GetSystemMetrics(SM_CYFULLSCREEN)
+	      - GetSystemMetrics(SM_CYFRAME) * 2
+#ifdef FEAT_MENU
+	      - gui_mswin_get_menu_height(FALSE)
+#endif
+	      ;
+}
+
+
+#if defined(FEAT_MENU) || defined(PROTO)
+/*
+ * Add a sub menu to the menu bar.
+ */
+    void
+gui_mch_add_menu(
+    vimmenu_T	*menu,
+    int		pos)
+{
+    vimmenu_T	*parent = menu->parent;
+
+    menu->submenu_id = CreatePopupMenu();
+    menu->id = s_menu_id++;
+
+    if (menu_is_menubar(menu->name))
+    {
+	InsertMenu((parent == NULL) ? s_menuBar : parent->submenu_id,
+		(UINT)pos, MF_POPUP | MF_STRING | MF_BYPOSITION,
+		(UINT)menu->submenu_id,  menu->name);
+    }
+
+    /* Fix window size if menu may have wrapped */
+    if (parent == NULL)
+	gui_mswin_get_menu_height(!gui.starting);
+}
+
+    void
+gui_mch_show_popupmenu(vimmenu_T *menu)
+{
+    POINT mp;
+
+    (void)GetCursorPos((LPPOINT)&mp);
+    gui_mch_show_popupmenu_at(menu, (int)mp.x, (int)mp.y);
+}
+
+    void
+gui_make_popup(char_u *path_name, int mouse_pos)
+{
+    vimmenu_T	*menu = gui_find_menu(path_name);
+
+    if (menu != NULL)
+    {
+	/* Find the position of the current cursor */
+	DWORD	temp_p;
+	POINT	p;
+	temp_p = GetDCOrg(s_hdc);
+	p.x = LOWORD(temp_p);
+	p.y = HIWORD(temp_p);
+	if (mouse_pos)
+	{
+	    int	mx, my;
+
+	    gui_mch_getmouse(&mx, &my);
+	    p.x += mx;
+	    p.y += my;
+	}
+	else if (curwin != NULL)
+	{
+	    p.x += TEXT_X(W_WINCOL(curwin) + curwin->w_wcol + 1);
+	    p.y += TEXT_Y(W_WINROW(curwin) + curwin->w_wrow + 1);
+	}
+	msg_scroll = FALSE;
+	gui_mch_show_popupmenu_at(menu, (int)p.x, (int)p.y);
+    }
+}
+
+/*
+ * Add a menu item to a menu
+ */
+    void
+gui_mch_add_menu_item(
+    vimmenu_T	*menu,
+    int		idx)
+{
+    vimmenu_T	*parent = menu->parent;
+
+    menu->id = s_menu_id++;
+    menu->submenu_id = NULL;
+
+#ifdef FEAT_TOOLBAR
+    if (menu_is_toolbar(parent->name))
+    {
+	TBBUTTON newtb;
+
+	vim_memset(&newtb, 0, sizeof(newtb));
+	if (menu_is_separator(menu->name))
+	{
+	    newtb.iBitmap = 0;
+	    newtb.fsStyle = TBSTYLE_SEP;
+	}
+	else
+	{
+	    if (menu->iconidx >= TOOLBAR_BITMAP_COUNT)
+		newtb.iBitmap = -1;
+	    else
+		newtb.iBitmap = menu->iconidx;
+	    newtb.fsStyle = TBSTYLE_BUTTON;
+	}
+	newtb.idCommand = menu->id;
+	newtb.fsState = TBSTATE_ENABLED;
+	SendMessage(s_toolbarhwnd, TB_INSERTBUTTON, (WPARAM)idx,
+							     (LPARAM)&newtb);
+	menu->submenu_id = (HMENU)-1;
+    }
+    else
+#endif
+    {
+	InsertMenu(parent->submenu_id, (UINT)idx,
+		(menu_is_separator(menu->name) ? MF_SEPARATOR : MF_STRING)
+							      | MF_BYPOSITION,
+		(UINT)menu->id, menu->name);
+    }
+}
+
+/*
+ * Destroy the machine specific menu widget.
+ */
+    void
+gui_mch_destroy_menu(vimmenu_T *menu)
+{
+    UINT i, j;
+    char pants[80]; /*<VN> hack*/
+#ifdef FEAT_TOOLBAR
+    /*
+     * is this a toolbar button?
+     */
+    if (menu->submenu_id == (HMENU)-1)
+    {
+	int iButton;
+
+	iButton = SendMessage(s_toolbarhwnd, TB_COMMANDTOINDEX, (WPARAM)menu->id, 0);
+	SendMessage(s_toolbarhwnd, TB_DELETEBUTTON, (WPARAM)iButton, 0);
+    }
+    else
+#endif
+    {
+	/*
+	 * negri: horrible API bug when running 16-bit programs under Win9x or
+	 * NT means that we can't use MF_BYCOMMAND for menu items which have
+	 * submenus, including the top-level headings. We have to find the menu
+	 * item and use MF_BYPOSITION instead. :-p
+	 */
+    if (menu->parent != NULL
+	    && menu_is_popup(menu->parent->dname)
+	    && menu->parent->submenu_id != NULL)
+	RemoveMenu(menu->parent->submenu_id, menu->id, MF_BYCOMMAND);
+    else if (menu->submenu_id == NULL)
+	RemoveMenu(s_menuBar, menu->id, MF_BYCOMMAND);
+    else if (menu->parent != NULL)
+    {
+	i = GetMenuItemCount(menu->parent->submenu_id);
+	for (j = 0; j < i; ++j)
+	{
+	    GetMenuString(menu->parent->submenu_id, j,
+		    pants, 80, MF_BYPOSITION);
+	    if (strcmp(pants, menu->name) == 0)
+	    {
+		RemoveMenu(menu->parent->submenu_id, j, MF_BYPOSITION);
+		break;
+	    }
+	}
+    }
+    else
+    {
+	i = GetMenuItemCount(s_menuBar);
+	for (j = 0; j < i; ++j)
+	{
+	    GetMenuString(s_menuBar, j, pants, 80, MF_BYPOSITION);
+	    if (strcmp(pants, menu->name) == 0)
+	    {
+		RemoveMenu(s_menuBar, j, MF_BYPOSITION);
+		break;
+	    }
+	}
+    }
+
+    if (menu->submenu_id != NULL)
+	DestroyMenu(menu->submenu_id);
+    }
+    DrawMenuBar(s_hwnd);
+}
+
+
+/*
+ * Make a menu either grey or not grey.
+ */
+    void
+gui_mch_menu_grey(
+    vimmenu_T *menu,
+    int	    grey)
+{
+#ifdef FEAT_TOOLBAR
+    /*
+     * is this a toolbar button?
+     */
+    if (menu->submenu_id == (HMENU)-1)
+    {
+	SendMessage(s_toolbarhwnd, TB_ENABLEBUTTON,
+	    (WPARAM)menu->id, (LPARAM) MAKELONG((grey ? FALSE : TRUE), 0) );
+    }
+    else
+#endif
+    if (grey)
+	EnableMenuItem(s_menuBar, menu->id, MF_BYCOMMAND | MF_GRAYED);
+    else
+	EnableMenuItem(s_menuBar, menu->id, MF_BYCOMMAND | MF_ENABLED);
+
+}
+
+
+#endif /*FEAT_MENU*/
+
+
+/* define some macros used to make the dialogue creation more readable */
+
+#define add_string(s) strcpy((LPSTR)p, s); (LPSTR)p += (strlen((LPSTR)p) + 1)
+#define add_word(x)		*p++ = (x)
+#define add_byte(x)		*((LPSTR)p)++ = (x)
+#define add_long(x)		*((LPDWORD)p)++ = (x)
+
+#if defined(FEAT_GUI_DIALOG) || defined(PROTO)
+/*
+ * stuff for dialogs
+ */
+
+/*
+ * The callback routine used by all the dialogs.  Very simple.  First,
+ * acknowledges the INITDIALOG message so that Windows knows to do standard
+ * dialog stuff (Return = default, Esc = cancel....) Second, if a button is
+ * pressed, return that button's ID - IDCANCEL (2), which is the button's
+ * number.
+ */
+	 static BOOL CALLBACK
+dialog_callback(
+	 HWND hwnd,
+	 UINT message,
+	 WPARAM wParam,
+	 LPARAM lParam)
+{
+    if (message == WM_INITDIALOG)
+    {
+	CenterWindow(hwnd, GetWindow(hwnd, GW_OWNER));
+	/* Set focus to the dialog.  Set the default button, if specified. */
+	(void)SetFocus(hwnd);
+	if (dialog_default_button > IDCANCEL)
+	    (void)SetFocus(GetDlgItem(hwnd, dialog_default_button));
+//	if (dialog_default_button > 0)
+//	    (void)SetFocus(GetDlgItem(hwnd, dialog_default_button + IDCANCEL));
+	return FALSE;
+    }
+
+    if (message == WM_COMMAND)
+    {
+	int	button = LOWORD(wParam);
+
+	/* Don't end the dialog if something was selected that was
+	 * not a button.
+	 */
+	if (button >= DLG_NONBUTTON_CONTROL)
+	    return TRUE;
+
+	/* If the edit box exists, copy the string. */
+	if (s_textfield != NULL)
+	    GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
+							 s_textfield, IOSIZE);
+
+	/*
+	 * Need to check for IDOK because if the user just hits Return to
+	 * accept the default value, some reason this is what we get.
+	 */
+	if (button == IDOK)
+	    EndDialog(hwnd, dialog_default_button);
+	else
+	    EndDialog(hwnd, button - IDCANCEL);
+	return TRUE;
+    }
+
+    if ((message == WM_SYSCOMMAND) && (wParam == SC_CLOSE))
+    {
+	EndDialog(hwnd, 0);
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Create a dialog dynamically from the parameter strings.
+ * type		= type of dialog (question, alert, etc.)
+ * title	= dialog title. may be NULL for default title.
+ * message	= text to display. Dialog sizes to accommodate it.
+ * buttons	= '\n' separated list of button captions, default first.
+ * dfltbutton	= number of default button.
+ *
+ * This routine returns 1 if the first button is pressed,
+ *			2 for the second, etc.
+ *
+ *			0 indicates Esc was pressed.
+ *			-1 for unexpected error
+ *
+ * If stubbing out this fn, return 1.
+ */
+
+static const char_u dlg_icons[] = /* must match names in resource file */
+{
+    IDR_VIM,
+    IDR_VIM_ERROR,
+    IDR_VIM_ALERT,
+    IDR_VIM_INFO,
+    IDR_VIM_QUESTION
+};
+
+    int
+gui_mch_dialog(
+    int		 type,
+    char_u	*title,
+    char_u	*message,
+    char_u	*buttons,
+    int		 dfltbutton,
+    char_u	*textfield,
+    int		ex_cmd)
+{
+    FARPROC	dp;
+    LPWORD	p, pnumitems;
+    int		numButtons;
+    int		*buttonWidths, *buttonPositions;
+    int		buttonYpos;
+    int		nchar, i;
+    DWORD	lStyle;
+    int		dlgwidth = 0;
+    int		dlgheight;
+    int		editboxheight;
+    int		horizWidth;
+    int		msgheight;
+    char_u	*pstart;
+    char_u	*pend;
+    char_u	*tbuffer;
+    RECT	rect;
+    HWND	hwnd;
+    HDC		hdc;
+    HFONT	oldFont;
+    TEXTMETRIC	fontInfo;
+    int		fontHeight;
+    int		textWidth, minButtonWidth, messageWidth;
+    int		maxDialogWidth;
+    int		vertical;
+    int		dlgPaddingX;
+    int		dlgPaddingY;
+    HGLOBAL	hglbDlgTemp;
+
+#ifndef NO_CONSOLE
+    /* Don't output anything in silent mode ("ex -s") */
+    if (silent_mode)
+	return dfltbutton;   /* return default option */
+#endif
+
+    /* If there is no window yet, open it. */
+    if (s_hwnd == NULL && gui_mch_init() == FAIL)
+	return dfltbutton;
+
+    if ((type < 0) || (type > VIM_LAST_TYPE))
+	type = 0;
+
+    /* allocate some memory for dialog template */
+    /* TODO should compute this really*/
+
+    hglbDlgTemp = GlobalAlloc(GHND,  DLG_ALLOC_SIZE);
+    if (hglbDlgTemp == NULL)
+	return -1;
+
+    p = (LPWORD) GlobalLock(hglbDlgTemp);
+
+    if (p == NULL)
+	return -1;
+
+    /*
+     * make a copy of 'buttons' to fiddle with it.  compiler grizzles because
+     * vim_strsave() doesn't take a const arg (why not?), so cast away the
+     * const.
+     */
+    tbuffer = vim_strsave(buttons);
+    if (tbuffer == NULL)
+	return -1;
+
+    --dfltbutton;   /* Change from one-based to zero-based */
+
+    /* Count buttons */
+    numButtons = 1;
+    for (i = 0; tbuffer[i] != '\0'; i++)
+    {
+	if (tbuffer[i] == DLG_BUTTON_SEP)
+	    numButtons++;
+    }
+    if (dfltbutton >= numButtons)
+	dfltbutton = 0;
+
+    /* Allocate array to hold the width of each button */
+    buttonWidths = (int *) lalloc(numButtons * sizeof(int), TRUE);
+    if (buttonWidths == NULL)
+	return -1;
+
+    /* Allocate array to hold the X position of each button */
+    buttonPositions = (int *) lalloc(numButtons * sizeof(int), TRUE);
+    if (buttonPositions == NULL)
+	return -1;
+
+    /*
+     * Calculate how big the dialog must be.
+     */
+    hwnd = GetDesktopWindow();
+    hdc = GetWindowDC(hwnd);
+    oldFont = SelectFont(hdc, GetStockObject(SYSTEM_FONT));
+    dlgPaddingX = DLG_OLD_STYLE_PADDING_X;
+    dlgPaddingY = DLG_OLD_STYLE_PADDING_Y;
+
+    GetTextMetrics(hdc, &fontInfo);
+    fontHeight = fontInfo.tmHeight;
+
+    /* Minimum width for horizontal button */
+    minButtonWidth = GetTextWidth(hdc, "Cancel", 6);
+
+    /* Maximum width of a dialog, if possible */
+    GetWindowRect(s_hwnd, &rect);
+    maxDialogWidth = rect.right - rect.left
+		     - GetSystemMetrics(SM_CXFRAME) * 2;
+    if (maxDialogWidth < DLG_MIN_MAX_WIDTH)
+	maxDialogWidth = DLG_MIN_MAX_WIDTH;
+
+    /* Set dlgwidth to width of message */
+    pstart = message;
+    messageWidth = 0;
+    msgheight = 0;
+    do
+    {
+	pend = vim_strchr(pstart, DLG_BUTTON_SEP);
+	if (pend == NULL)
+	    pend = pstart + STRLEN(pstart);	/* Last line of message. */
+	msgheight += fontHeight;
+	textWidth = GetTextWidth(hdc, pstart, pend - pstart);
+	if (textWidth > messageWidth)
+	    messageWidth = textWidth;
+	pstart = pend + 1;
+    } while (*pend != NUL);
+    dlgwidth = messageWidth;
+
+    /* Add width of icon to dlgwidth, and some space */
+    dlgwidth += DLG_ICON_WIDTH + 3 * dlgPaddingX;
+
+    if (msgheight < DLG_ICON_HEIGHT)
+	msgheight = DLG_ICON_HEIGHT;
+
+    /*
+     * Check button names.  A long one will make the dialog wider.
+     */
+	 vertical = (vim_strchr(p_go, GO_VERTICAL) != NULL);
+    if (!vertical)
+    {
+	// Place buttons horizontally if they fit.
+	horizWidth = dlgPaddingX;
+	pstart = tbuffer;
+	i = 0;
+	do
+	{
+	    pend = vim_strchr(pstart, DLG_BUTTON_SEP);
+	    if (pend == NULL)
+		pend = pstart + STRLEN(pstart);	// Last button name.
+	    textWidth = GetTextWidth(hdc, pstart, pend - pstart);
+	    if (textWidth < minButtonWidth)
+		textWidth = minButtonWidth;
+	    textWidth += dlgPaddingX;	    /* Padding within button */
+	    buttonWidths[i] = textWidth;
+	    buttonPositions[i++] = horizWidth;
+	    horizWidth += textWidth + dlgPaddingX; /* Pad between buttons */
+	    pstart = pend + 1;
+	} while (*pend != NUL);
+
+	if (horizWidth > maxDialogWidth)
+	    vertical = TRUE;	// Too wide to fit on the screen.
+	else if (horizWidth > dlgwidth)
+	    dlgwidth = horizWidth;
+    }
+
+    if (vertical)
+    {
+	// Stack buttons vertically.
+	pstart = tbuffer;
+	do
+	{
+	    pend = vim_strchr(pstart, DLG_BUTTON_SEP);
+	    if (pend == NULL)
+		pend = pstart + STRLEN(pstart);	// Last button name.
+	    textWidth = GetTextWidth(hdc, pstart, pend - pstart);
+	    textWidth += dlgPaddingX;		/* Padding within button */
+	    textWidth += DLG_VERT_PADDING_X * 2; /* Padding around button */
+	    if (textWidth > dlgwidth)
+		dlgwidth = textWidth;
+	    pstart = pend + 1;
+	} while (*pend != NUL);
+    }
+
+    if (dlgwidth < DLG_MIN_WIDTH)
+	dlgwidth = DLG_MIN_WIDTH;	/* Don't allow a really thin dialog!*/
+
+    /* start to fill in the dlgtemplate information.  addressing by WORDs */
+    lStyle = DS_MODALFRAME | WS_CAPTION | WS_VISIBLE ;
+
+    add_long(lStyle);
+    pnumitems = p;	/*save where the number of items must be stored*/
+    add_byte(0);	// NumberOfItems(will change later)
+    add_word(10);	// x
+    add_word(10);	// y
+    add_word(PixelToDialogX(dlgwidth));
+
+    // Dialog height.
+    if (vertical)
+	dlgheight = msgheight + 2 * dlgPaddingY +
+			      DLG_VERT_PADDING_Y + 2 * fontHeight * numButtons;
+    else
+	dlgheight = msgheight + 3 * dlgPaddingY + 2 * fontHeight;
+
+    // Dialog needs to be taller if contains an edit box.
+    editboxheight = fontHeight + dlgPaddingY + 4 * DLG_VERT_PADDING_Y;
+    if (textfield != NULL)
+	dlgheight += editboxheight;
+
+    add_word(PixelToDialogY(dlgheight));
+
+    add_byte(0);	//menu
+    add_byte(0);	//class
+
+    /* copy the title of the dialog */
+    add_string(title ? title : ("Vim"VIM_VERSION_MEDIUM));
+
+    buttonYpos = msgheight + 2 * dlgPaddingY;
+
+    if (textfield != NULL)
+	buttonYpos += editboxheight;
+
+    pstart = tbuffer; //dflt_text
+    horizWidth = (dlgwidth - horizWidth) / 2;	/* Now it's X offset */
+    for (i = 0; i < numButtons; i++)
+    {
+	/* get end of this button. */
+	for (	pend = pstart;
+		*pend && (*pend != DLG_BUTTON_SEP);
+		pend++)
+	    ;
+
+	if (*pend)
+	    *pend = '\0';
+
+	/*
+	 * NOTE:
+	 * setting the BS_DEFPUSHBUTTON style doesn't work because Windows sets
+	 * the focus to the first tab-able button and in so doing makes that
+	 * the default!! Grrr.  Workaround: Make the default button the only
+	 * one with WS_TABSTOP style. Means user can't tab between buttons, but
+	 * he/she can use arrow keys.
+	 *
+	 * NOTE (Thore): Setting BS_DEFPUSHBUTTON works fine when it's the
+	 * first one, so I changed the correct button to be this style. This
+	 * is necessary because when an edit box is added, we need a button to
+	 * be default.  The edit box will be the default control, and when the
+	 * user presses enter from the edit box we want the default button to
+	 * be pressed.
+	 */
+	if (vertical)
+	{
+	    p = add_dialog_element(p,
+		    ((i == dfltbutton || dfltbutton < 0) && textfield != NULL
+			    ?  BS_DEFPUSHBUTTON : BS_PUSHBUTTON) | WS_TABSTOP,
+		    PixelToDialogX(DLG_VERT_PADDING_X),
+		    PixelToDialogY(buttonYpos /* TBK */
+				   + 2 * fontHeight * i),
+		    PixelToDialogX(dlgwidth - 2 * DLG_VERT_PADDING_X),
+		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
+		    (WORD)(IDCANCEL + 1 + i), (BYTE)0x80, pstart);
+	}
+	else
+	{
+	    p = add_dialog_element(p,
+		    ((i == dfltbutton || dfltbutton < 0) && textfield != NULL
+			     ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON) | WS_TABSTOP,
+		    PixelToDialogX(horizWidth + buttonPositions[i]),
+		    PixelToDialogY(buttonYpos), /* TBK */
+		    PixelToDialogX(buttonWidths[i]),
+		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
+		    (WORD)(IDCANCEL + 1 + i), (BYTE)0x80, pstart);
+	}
+
+	pstart = pend + 1;	/*next button*/
+
+    }
+    *pnumitems += numButtons;
+
+    /* Vim icon */
+    p = add_dialog_element(p, SS_ICON,
+	    PixelToDialogX(dlgPaddingX),
+	    PixelToDialogY(dlgPaddingY),
+	    PixelToDialogX(DLG_ICON_WIDTH),
+	    PixelToDialogY(DLG_ICON_HEIGHT),
+	    DLG_NONBUTTON_CONTROL + 0, (BYTE)0x82,
+	    &dlg_icons[type]);
+
+
+    /* Dialog message */
+    p = add_dialog_element(p, SS_LEFT,
+	    PixelToDialogX(2 * dlgPaddingX + DLG_ICON_WIDTH),
+	    PixelToDialogY(dlgPaddingY),
+	    (WORD)(PixelToDialogX(messageWidth) + 1),
+	    PixelToDialogY(msgheight),
+	    DLG_NONBUTTON_CONTROL + 1, (BYTE)0x82, message);
+
+    /* Edit box */
+    if (textfield != NULL)
+    {
+	p = add_dialog_element(p, ES_LEFT | ES_AUTOHSCROLL | WS_TABSTOP | WS_BORDER,
+		PixelToDialogX(2 * dlgPaddingX),
+		PixelToDialogY(2 * dlgPaddingY + msgheight),
+		PixelToDialogX(dlgwidth - 4 * dlgPaddingX),
+		PixelToDialogY(fontHeight + dlgPaddingY),
+		DLG_NONBUTTON_CONTROL + 2, (BYTE)0x81, textfield);
+	*pnumitems += 1;
+    }
+
+    *pnumitems += 2;
+
+    SelectFont(hdc, oldFont);
+    ReleaseDC(hwnd, hdc);
+    dp = MakeProcInstance((FARPROC)dialog_callback, s_hinst);
+
+
+    /* Let the dialog_callback() function know which button to make default
+     * If we have an edit box, make that the default. We also need to tell
+     * dialog_callback() if this dialog contains an edit box or not. We do
+     * this by setting s_textfield if it does.
+     */
+    if (textfield != NULL)
+    {
+	dialog_default_button = DLG_NONBUTTON_CONTROL + 2;
+	s_textfield = textfield;
+    }
+    else
+    {
+	dialog_default_button = IDCANCEL + 1 + dfltbutton;
+	s_textfield = NULL;
+    }
+
+    /*show the dialog box modally and get a return value*/
+    nchar = DialogBoxIndirect(
+	    s_hinst,
+	    (HGLOBAL) hglbDlgTemp,
+	    s_hwnd,
+	    (DLGPROC)dp);
+
+    FreeProcInstance( dp );
+    GlobalUnlock(hglbDlgTemp);
+    GlobalFree(hglbDlgTemp);
+    vim_free(tbuffer);
+    vim_free(buttonWidths);
+    vim_free(buttonPositions);
+
+
+    return nchar;
+}
+
+/*
+ * Put a simple element (basic class) onto a dialog template in memory.
+ * return a pointer to where the next item should be added.
+ *
+ * parameters:
+ *  lStyle = additional style flags
+ *  x,y = x & y positions IN DIALOG UNITS
+ *  w,h = width and height IN DIALOG UNITS
+ *  Id	= ID used in messages
+ *  clss  = class ID, e.g 0x80 for a button, 0x82 for a static
+ *  caption = usually text or resource name
+ *
+ *  TODO: use the length information noted here to enable the dialog creation
+ *  routines to work out more exactly how much memory they need to alloc.
+ */
+    static LPWORD
+add_dialog_element(
+    LPWORD p,
+    DWORD lStyle,
+    WORD x,
+    WORD y,
+    WORD w,
+    WORD h,
+    WORD Id,
+    BYTE clss,
+    const char *caption)
+{
+
+    lStyle = lStyle | WS_VISIBLE | WS_CHILD;
+
+    add_word(x);
+    add_word(y);
+    add_word(w);
+    add_word(h);
+    add_word(Id);
+    add_long(lStyle);
+    add_byte(clss);
+    if (((lStyle & SS_ICON) != 0) && (clss == 0x82))
+    {
+	/* Use resource ID */
+	add_byte(0xff);
+	add_byte(*caption);
+    }
+    else
+	add_string(caption);
+
+    add_byte(0);    //# of extra bytes following
+
+
+    return p;
+}
+
+#undef add_byte
+#undef add_string
+#undef add_long
+#undef add_word
+
+#endif /* FEAT_GUI_DIALOG */
+
+    static void
+get_dialog_font_metrics(void)
+{
+    DWORD	    dlgFontSize;
+	dlgFontSize = GetDialogBaseUnits();	/* fall back to big old system*/
+	s_dlgfntwidth = LOWORD(dlgFontSize);
+	s_dlgfntheight = HIWORD(dlgFontSize);
+}
+
+
+#if defined(FEAT_TOOLBAR) || defined(PROTO)
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+# include "gui_w3~1.h"
+#endif
+
+/*
+ * Create the toolbar, initially unpopulated.
+ *  (just like the menu, there are no defaults, it's all
+ *  set up through menu.vim)
+ */
+    static void
+initialise_toolbar(void)
+{
+    s_toolbarhwnd = CreateToolbar(
+		    s_hwnd,
+		    WS_CHILD | WS_VISIBLE,
+		    CMD_TB_BASE, /*<vn>*/
+		    31,			//number of images in initial bitmap
+		    s_hinst,
+		    IDR_TOOLBAR1,	// id of initial bitmap
+		    NULL,
+		    0			// initial number of buttons
+		    );
+
+    gui_mch_show_toolbar(vim_strchr(p_go, GO_TOOLBAR) != NULL);
+}
+#endif
+
+#if defined(FEAT_OLE) || defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Make the GUI window come to the foreground.
+ */
+    void
+gui_mch_set_foreground(void)
+{
+    if (IsIconic(s_hwnd))
+	 SendMessage(s_hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
+    SetActiveWindow(s_hwnd);
+}
+#endif
diff -urN vim-src/src/gui_w48.c vim-qt-src/src/gui_w48.c
--- vim-src/src/gui_w48.c	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/gui_w48.c	2016-06-08 06:39:27.724315173 +0200
@@ -0,0 +1,4073 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *				GUI support by Robert Webb
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+/*
+ * gui_w48.c:  This file is included in gui_w16.c and gui_w32.c.
+ *
+ * GUI support for Microsoft Windows (Win16 + Win32 = Win48 :-)
+ *
+ * The combined efforts of:
+ * George V. Reilly <george@reilly.org>
+ * Robert Webb
+ * Vince Negri
+ * ...and contributions from many others
+ *
+ */
+
+#include "vim.h"
+#include "version.h"	/* used by dialog box routine for default title */
+#ifdef DEBUG
+# include <tchar.h>
+#endif
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+
+#ifndef __MINGW32__
+# include <shellapi.h>
+#endif
+#if defined(FEAT_TOOLBAR) || defined(FEAT_BEVAL) || defined(FEAT_GUI_TABLINE)
+# include <commctrl.h>
+#endif
+#ifdef WIN16
+# include <commdlg.h>
+# include <shellapi.h>
+# ifdef WIN16_3DLOOK
+#  include <ctl3d.h>
+# endif
+#endif
+#include <windowsx.h>
+
+#ifdef GLOBAL_IME
+# include "glbl_ime.h"
+#endif
+
+#endif /* PROTO */
+
+#ifdef FEAT_MENU
+# define MENUHINTS		/* show menu hints in command line */
+#endif
+
+/* Some parameters for dialog boxes.  All in pixels. */
+#define DLG_PADDING_X		10
+#define DLG_PADDING_Y		10
+#define DLG_OLD_STYLE_PADDING_X	5
+#define DLG_OLD_STYLE_PADDING_Y	5
+#define DLG_VERT_PADDING_X	4	/* For vertical buttons */
+#define DLG_VERT_PADDING_Y	4
+#define DLG_ICON_WIDTH		34
+#define DLG_ICON_HEIGHT		34
+#define DLG_MIN_WIDTH		150
+#define DLG_FONT_NAME		"MS Sans Serif"
+#define DLG_FONT_POINT_SIZE	8
+#define DLG_MIN_MAX_WIDTH	400
+#define DLG_MIN_MAX_HEIGHT	400
+
+#define DLG_NONBUTTON_CONTROL	5000	/* First ID of non-button controls */
+
+#ifndef WM_XBUTTONDOWN /* For Win2K / winME ONLY */
+# define WM_XBUTTONDOWN		0x020B
+# define WM_XBUTTONUP		0x020C
+# define WM_XBUTTONDBLCLK	0x020D
+# define MK_XBUTTON1		0x0020
+# define MK_XBUTTON2		0x0040
+#endif
+
+#ifdef PROTO
+/*
+ * Define a few things for generating prototypes.  This is just to avoid
+ * syntax errors, the defines do not need to be correct.
+ */
+# define APIENTRY
+# define CALLBACK
+# define CONST
+# define FAR
+# define NEAR
+# define _cdecl
+typedef int BOOL;
+typedef int BYTE;
+typedef int DWORD;
+typedef int WCHAR;
+typedef int ENUMLOGFONT;
+typedef int FINDREPLACE;
+typedef int HANDLE;
+typedef int HBITMAP;
+typedef int HBRUSH;
+typedef int HDROP;
+typedef int INT;
+typedef int LOGFONT[];
+typedef int LPARAM;
+typedef int LPCREATESTRUCT;
+typedef int LPCSTR;
+typedef int LPCTSTR;
+typedef int LPRECT;
+typedef int LPSTR;
+typedef int LPWINDOWPOS;
+typedef int LPWORD;
+typedef int LRESULT;
+typedef int HRESULT;
+# undef MSG
+typedef int MSG;
+typedef int NEWTEXTMETRIC;
+typedef int OSVERSIONINFO;
+typedef int PWORD;
+typedef int RECT;
+typedef int UINT;
+typedef int WORD;
+typedef int WPARAM;
+typedef int POINT;
+typedef void *HINSTANCE;
+typedef void *HMENU;
+typedef void *HWND;
+typedef void *HDC;
+typedef void VOID;
+typedef int LPNMHDR;
+typedef int LONG;
+typedef int WNDPROC;
+#endif
+
+#ifndef GET_X_LPARAM
+# define GET_X_LPARAM(lp) ((int)(short)LOWORD(lp))
+#endif
+
+static void _OnPaint( HWND hwnd);
+static void clear_rect(RECT *rcp);
+static int gui_mswin_get_menu_height(int fix_window);
+
+static WORD		s_dlgfntheight;		/* height of the dialog font */
+static WORD		s_dlgfntwidth;		/* width of the dialog font */
+
+#ifdef FEAT_MENU
+static HMENU		s_menuBar = NULL;
+#endif
+#ifdef FEAT_TEAROFF
+static void rebuild_tearoff(vimmenu_T *menu);
+static HBITMAP	s_htearbitmap;	    /* bitmap used to indicate tearoff */
+#endif
+
+/* Flag that is set while processing a message that must not be interrupted by
+ * processing another message. */
+static int		s_busy_processing = FALSE;
+
+static int		destroying = FALSE;	/* call DestroyWindow() ourselves */
+
+#ifdef MSWIN_FIND_REPLACE
+static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
+static FINDREPLACE	s_findrep_struct;
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+static FINDREPLACEW	s_findrep_struct_w;
+# endif
+static HWND		s_findrep_hwnd = NULL;
+static int		s_findrep_is_find;	/* TRUE for find dialog, FALSE
+						   for find/replace dialog */
+#endif
+
+static HINSTANCE	s_hinst = NULL;
+#if !defined(FEAT_SNIFF) && !defined(FEAT_GUI)
+static
+#endif
+HWND			s_hwnd = NULL;
+static HDC		s_hdc = NULL;
+static HBRUSH	s_brush = NULL;
+
+#ifdef FEAT_TOOLBAR
+static HWND		s_toolbarhwnd = NULL;
+static WNDPROC		s_toolbar_wndproc = NULL;
+#endif
+
+#ifdef FEAT_GUI_TABLINE
+static HWND		s_tabhwnd = NULL;
+static WNDPROC		s_tabline_wndproc = NULL;
+static int		showing_tabline = 0;
+#endif
+
+static WPARAM		s_wParam = 0;
+static LPARAM		s_lParam = 0;
+
+static HWND		s_textArea = NULL;
+static UINT		s_uMsg = 0;
+
+static char_u		*s_textfield; /* Used by dialogs to pass back strings */
+
+static int		s_need_activate = FALSE;
+
+/* This variable is set when waiting for an event, which is the only moment
+ * scrollbar dragging can be done directly.  It's not allowed while commands
+ * are executed, because it may move the cursor and that may cause unexpected
+ * problems (e.g., while ":s" is working).
+ */
+static int allow_scrollbar = FALSE;
+
+#ifdef GLOBAL_IME
+# define MyTranslateMessage(x) global_ime_TranslateMessage(x)
+#else
+# define MyTranslateMessage(x) TranslateMessage(x)
+#endif
+
+#if (defined(WIN3264) && defined(FEAT_MBYTE)) || defined(GLOBAL_IME)
+  /* use of WindowProc depends on wide_WindowProc */
+# define MyWindowProc vim_WindowProc
+#else
+  /* use ordinary WindowProc */
+# define MyWindowProc DefWindowProc
+#endif
+
+extern int current_font_height;	    /* this is in os_mswin.c */
+
+static struct
+{
+    UINT    key_sym;
+    char_u  vim_code0;
+    char_u  vim_code1;
+} special_keys[] =
+{
+    {VK_UP,		'k', 'u'},
+    {VK_DOWN,		'k', 'd'},
+    {VK_LEFT,		'k', 'l'},
+    {VK_RIGHT,		'k', 'r'},
+
+    {VK_F1,		'k', '1'},
+    {VK_F2,		'k', '2'},
+    {VK_F3,		'k', '3'},
+    {VK_F4,		'k', '4'},
+    {VK_F5,		'k', '5'},
+    {VK_F6,		'k', '6'},
+    {VK_F7,		'k', '7'},
+    {VK_F8,		'k', '8'},
+    {VK_F9,		'k', '9'},
+    {VK_F10,		'k', ';'},
+
+    {VK_F11,		'F', '1'},
+    {VK_F12,		'F', '2'},
+    {VK_F13,		'F', '3'},
+    {VK_F14,		'F', '4'},
+    {VK_F15,		'F', '5'},
+    {VK_F16,		'F', '6'},
+    {VK_F17,		'F', '7'},
+    {VK_F18,		'F', '8'},
+    {VK_F19,		'F', '9'},
+    {VK_F20,		'F', 'A'},
+
+    {VK_F21,		'F', 'B'},
+#ifdef FEAT_NETBEANS_INTG
+    {VK_PAUSE,		'F', 'B'},	/* Pause == F21 (see gui_gtk_x11.c) */
+#endif
+    {VK_F22,		'F', 'C'},
+    {VK_F23,		'F', 'D'},
+    {VK_F24,		'F', 'E'},	/* winuser.h defines up to F24 */
+
+    {VK_HELP,		'%', '1'},
+    {VK_BACK,		'k', 'b'},
+    {VK_INSERT,		'k', 'I'},
+    {VK_DELETE,		'k', 'D'},
+    {VK_HOME,		'k', 'h'},
+    {VK_END,		'@', '7'},
+    {VK_PRIOR,		'k', 'P'},
+    {VK_NEXT,		'k', 'N'},
+    {VK_PRINT,		'%', '9'},
+    {VK_ADD,		'K', '6'},
+    {VK_SUBTRACT,	'K', '7'},
+    {VK_DIVIDE,		'K', '8'},
+    {VK_MULTIPLY,	'K', '9'},
+    {VK_SEPARATOR,	'K', 'A'},	/* Keypad Enter */
+    {VK_DECIMAL,	'K', 'B'},
+
+    {VK_NUMPAD0,	'K', 'C'},
+    {VK_NUMPAD1,	'K', 'D'},
+    {VK_NUMPAD2,	'K', 'E'},
+    {VK_NUMPAD3,	'K', 'F'},
+    {VK_NUMPAD4,	'K', 'G'},
+    {VK_NUMPAD5,	'K', 'H'},
+    {VK_NUMPAD6,	'K', 'I'},
+    {VK_NUMPAD7,	'K', 'J'},
+    {VK_NUMPAD8,	'K', 'K'},
+    {VK_NUMPAD9,	'K', 'L'},
+
+    /* Keys that we want to be able to use any modifier with: */
+    {VK_SPACE,		' ', NUL},
+    {VK_TAB,		TAB, NUL},
+    {VK_ESCAPE,		ESC, NUL},
+    {NL,		NL, NUL},
+    {CAR,		CAR, NUL},
+
+    /* End of list marker: */
+    {0,			0, 0}
+};
+
+/* Local variables */
+static int		s_button_pending = -1;
+
+/* s_getting_focus is set when we got focus but didn't see mouse-up event yet,
+ * so don't reset s_button_pending. */
+static int		s_getting_focus = FALSE;
+
+static int		s_x_pending;
+static int		s_y_pending;
+static UINT		s_kFlags_pending;
+static UINT		s_wait_timer = 0;   /* Timer for get char from user */
+static int		s_timed_out = FALSE;
+static int		dead_key = 0;	/* 0 - no dead key, 1 - dead key pressed */
+
+#ifdef WIN3264
+static OSVERSIONINFO os_version;    /* like it says.  Init in gui_mch_init() */
+#endif
+
+#ifdef FEAT_BEVAL
+/* balloon-eval WM_NOTIFY_HANDLER */
+static void Handle_WM_Notify __ARGS((HWND hwnd, LPNMHDR pnmh));
+static void TrackUserActivity __ARGS((UINT uMsg));
+#endif
+
+/*
+ * For control IME.
+ *
+ * These LOGFONT used for IME.
+ */
+#ifdef FEAT_MBYTE
+# ifdef USE_IM_CONTROL
+/* holds LOGFONT for 'guifontwide' if available, otherwise 'guifont' */
+static LOGFONT norm_logfont;
+/* holds LOGFONT for 'guifont' always. */
+static LOGFONT sub_logfont;
+# endif
+#endif
+
+#ifdef FEAT_MBYTE_IME
+static LRESULT _OnImeNotify(HWND hWnd, DWORD dwCommand, DWORD dwData);
+#endif
+
+#if defined(FEAT_MBYTE) && defined(WIN3264)
+static char_u *convert_filter(char_u *s);
+#endif
+
+#ifdef DEBUG_PRINT_ERROR
+/*
+ * Print out the last Windows error message
+ */
+    static void
+print_windows_error(void)
+{
+    LPVOID  lpMsgBuf;
+
+    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+		  NULL, GetLastError(),
+		  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+		  (LPTSTR) &lpMsgBuf, 0, NULL);
+    TRACE1("Error: %s\n", lpMsgBuf);
+    LocalFree(lpMsgBuf);
+}
+#endif
+
+/*
+ * Cursor blink functions.
+ *
+ * This is a simple state machine:
+ * BLINK_NONE	not blinking at all
+ * BLINK_OFF	blinking, cursor is not shown
+ * BLINK_ON	blinking, cursor is shown
+ */
+
+#define BLINK_NONE  0
+#define BLINK_OFF   1
+#define BLINK_ON    2
+
+static int		blink_state = BLINK_NONE;
+static long_u		blink_waittime = 700;
+static long_u		blink_ontime = 400;
+static long_u		blink_offtime = 250;
+static UINT		blink_timer = 0;
+
+    void
+gui_mch_set_blinking(long wait, long on, long off)
+{
+    blink_waittime = wait;
+    blink_ontime = on;
+    blink_offtime = off;
+}
+
+/* ARGSUSED */
+    static VOID CALLBACK
+_OnBlinkTimer(
+    HWND hwnd,
+    UINT uMsg,
+    UINT idEvent,
+    DWORD dwTime)
+{
+    MSG msg;
+
+    /*
+    TRACE2("Got timer event, id %d, blink_timer %d\n", idEvent, blink_timer);
+    */
+
+    KillTimer(NULL, idEvent);
+
+    /* Eat spurious WM_TIMER messages */
+    while (pPeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
+	;
+
+    if (blink_state == BLINK_ON)
+    {
+	gui_undraw_cursor();
+	blink_state = BLINK_OFF;
+	blink_timer = (UINT) SetTimer(NULL, 0, (UINT)blink_offtime,
+						    (TIMERPROC)_OnBlinkTimer);
+    }
+    else
+    {
+	gui_update_cursor(TRUE, FALSE);
+	blink_state = BLINK_ON;
+	blink_timer = (UINT) SetTimer(NULL, 0, (UINT)blink_ontime,
+							 (TIMERPROC)_OnBlinkTimer);
+    }
+}
+
+    static void
+gui_mswin_rm_blink_timer(void)
+{
+    MSG msg;
+
+    if (blink_timer != 0)
+    {
+	KillTimer(NULL, blink_timer);
+	/* Eat spurious WM_TIMER messages */
+	while (pPeekMessage(&msg, s_hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
+	    ;
+	blink_timer = 0;
+    }
+}
+
+/*
+ * Stop the cursor blinking.  Show the cursor if it wasn't shown.
+ */
+    void
+gui_mch_stop_blink(void)
+{
+    gui_mswin_rm_blink_timer();
+    if (blink_state == BLINK_OFF)
+	gui_update_cursor(TRUE, FALSE);
+    blink_state = BLINK_NONE;
+}
+
+/*
+ * Start the cursor blinking.  If it was already blinking, this restarts the
+ * waiting time and shows the cursor.
+ */
+    void
+gui_mch_start_blink(void)
+{
+    gui_mswin_rm_blink_timer();
+
+    /* Only switch blinking on if none of the times is zero */
+    if (blink_waittime && blink_ontime && blink_offtime && gui.in_focus)
+    {
+	blink_timer = (UINT)SetTimer(NULL, 0, (UINT)blink_waittime,
+						    (TIMERPROC)_OnBlinkTimer);
+	blink_state = BLINK_ON;
+	gui_update_cursor(TRUE, FALSE);
+    }
+}
+
+/*
+ * Call-back routines.
+ */
+
+/*ARGSUSED*/
+    static VOID CALLBACK
+_OnTimer(
+    HWND hwnd,
+    UINT uMsg,
+    UINT idEvent,
+    DWORD dwTime)
+{
+    MSG msg;
+
+    /*
+    TRACE2("Got timer event, id %d, s_wait_timer %d\n", idEvent, s_wait_timer);
+    */
+    KillTimer(NULL, idEvent);
+    s_timed_out = TRUE;
+
+    /* Eat spurious WM_TIMER messages */
+    while (pPeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
+	;
+    if (idEvent == s_wait_timer)
+	s_wait_timer = 0;
+}
+
+/*ARGSUSED*/
+    static void
+_OnDeadChar(
+    HWND hwnd,
+    UINT ch,
+    int cRepeat)
+{
+    dead_key = 1;
+}
+
+/*
+ * Convert Unicode character "ch" to bytes in "string[slen]".
+ * When "had_alt" is TRUE the ALT key was included in "ch".
+ * Return the length.
+ */
+    static int
+char_to_string(int ch, char_u *string, int slen, int had_alt)
+{
+    int		len;
+    int		i;
+#ifdef FEAT_MBYTE
+    WCHAR	wstring[2];
+    char_u	*ws = NULL;;
+
+    if (os_version.dwPlatformId != VER_PLATFORM_WIN32_NT)
+    {
+	/* On Windows 95/98 we apparently get the character in the active
+	 * codepage, not in UCS-2.  If conversion is needed convert it to
+	 * UCS-2 first. */
+	if ((int)GetACP() == enc_codepage)
+	    len = 0;	    /* no conversion required */
+	else
+	{
+	    string[0] = ch;
+	    len = MultiByteToWideChar(GetACP(), 0, string, 1, wstring, 2);
+	}
+    }
+    else
+    {
+	wstring[0] = ch;
+	len = 1;
+    }
+
+    if (len > 0)
+    {
+	/* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
+	 * "enc_codepage" is non-zero use the standard Win32 function,
+	 * otherwise use our own conversion function (e.g., for UTF-8). */
+	if (enc_codepage > 0)
+	{
+	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
+						       string, slen, 0, NULL);
+	    /* If we had included the ALT key into the character but now the
+	     * upper bit is no longer set, that probably means the conversion
+	     * failed.  Convert the original character and set the upper bit
+	     * afterwards. */
+	    if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
+	    {
+		wstring[0] = ch & 0x7f;
+		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
+						       string, slen, 0, NULL);
+		if (len == 1) /* safety check */
+		    string[0] |= 0x80;
+	    }
+	}
+	else
+	{
+	    len = 1;
+	    ws = utf16_to_enc(wstring, &len);
+	    if (ws == NULL)
+		len = 0;
+	    else
+	    {
+		if (len > slen)	/* just in case */
+		    len = slen;
+		mch_memmove(string, ws, len);
+		vim_free(ws);
+	    }
+	}
+    }
+
+    if (len == 0)
+#endif
+    {
+	string[0] = ch;
+	len = 1;
+    }
+
+    for (i = 0; i < len; ++i)
+	if (string[i] == CSI && len <= slen - 2)
+	{
+	    /* Insert CSI as K_CSI. */
+	    mch_memmove(string + i + 3, string + i + 1, len - i - 1);
+	    string[++i] = KS_EXTRA;
+	    string[++i] = (int)KE_CSI;
+	    len += 2;
+	}
+
+    return len;
+}
+
+/*
+ * Key hit, add it to the input buffer.
+ */
+/*ARGSUSED*/
+    static void
+_OnChar(
+    HWND hwnd,
+    UINT ch,
+    int cRepeat)
+{
+    char_u	string[40];
+    int		len = 0;
+
+    dead_key = 0;
+
+    len = char_to_string(ch, string, 40, FALSE);
+    if (len == 1 && string[0] == Ctrl_C && ctrl_c_interrupts)
+    {
+	trash_input_buf();
+	got_int = TRUE;
+    }
+
+    add_to_input_buf(string, len);
+}
+
+/*
+ * Alt-Key hit, add it to the input buffer.
+ */
+/*ARGSUSED*/
+    static void
+_OnSysChar(
+    HWND hwnd,
+    UINT cch,
+    int cRepeat)
+{
+    char_u	string[40]; /* Enough for multibyte character */
+    int		len;
+    int		modifiers;
+    int		ch = cch;   /* special keys are negative */
+
+    /* TRACE("OnSysChar(%d, %c)\n", ch, ch); */
+
+    /* OK, we have a character key (given by ch) which was entered with the
+     * ALT key pressed. Eg, if the user presses Alt-A, then ch == 'A'. Note
+     * that the system distinguishes Alt-a and Alt-A (Alt-Shift-a unless
+     * CAPSLOCK is pressed) at this point.
+     */
+    modifiers = MOD_MASK_ALT;
+    if (GetKeyState(VK_SHIFT) & 0x8000)
+	modifiers |= MOD_MASK_SHIFT;
+    if (GetKeyState(VK_CONTROL) & 0x8000)
+	modifiers |= MOD_MASK_CTRL;
+
+    ch = simplify_key(ch, &modifiers);
+    /* remove the SHIFT modifier for keys where it's already included, e.g.,
+     * '(' and '*' */
+    if (ch < 0x100 && !isalpha(ch) && isprint(ch))
+	modifiers &= ~MOD_MASK_SHIFT;
+
+    /* Interpret the ALT key as making the key META, include SHIFT, etc. */
+    ch = extract_modifiers(ch, &modifiers);
+    if (ch == CSI)
+	ch = K_CSI;
+
+    len = 0;
+    if (modifiers)
+    {
+	string[len++] = CSI;
+	string[len++] = KS_MODIFIER;
+	string[len++] = modifiers;
+    }
+
+    if (IS_SPECIAL((int)ch))
+    {
+	string[len++] = CSI;
+	string[len++] = K_SECOND((int)ch);
+	string[len++] = K_THIRD((int)ch);
+    }
+    else
+    {
+	/* Although the documentation isn't clear about it, we assume "ch" is
+	 * a Unicode character. */
+	len += char_to_string(ch, string + len, 40 - len, TRUE);
+    }
+
+    add_to_input_buf(string, len);
+}
+
+    static void
+_OnMouseEvent(
+    int button,
+    int x,
+    int y,
+    int repeated_click,
+    UINT keyFlags)
+{
+    int vim_modifiers = 0x0;
+
+    s_getting_focus = FALSE;
+
+    if (keyFlags & MK_SHIFT)
+	vim_modifiers |= MOUSE_SHIFT;
+    if (keyFlags & MK_CONTROL)
+	vim_modifiers |= MOUSE_CTRL;
+    if (GetKeyState(VK_MENU) & 0x8000)
+	vim_modifiers |= MOUSE_ALT;
+
+    gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
+}
+
+/*ARGSUSED*/
+    static void
+_OnMouseButtonDown(
+    HWND hwnd,
+    BOOL fDoubleClick,
+    int x,
+    int y,
+    UINT keyFlags)
+{
+    static LONG	s_prevTime = 0;
+
+    LONG    currentTime = GetMessageTime();
+    int	    button = -1;
+    int	    repeated_click;
+
+    /* Give main window the focus: this is so the cursor isn't hollow. */
+    (void)SetFocus(s_hwnd);
+
+    if (s_uMsg == WM_LBUTTONDOWN || s_uMsg == WM_LBUTTONDBLCLK)
+	button = MOUSE_LEFT;
+    else if (s_uMsg == WM_MBUTTONDOWN || s_uMsg == WM_MBUTTONDBLCLK)
+	button = MOUSE_MIDDLE;
+    else if (s_uMsg == WM_RBUTTONDOWN || s_uMsg == WM_RBUTTONDBLCLK)
+	button = MOUSE_RIGHT;
+#ifndef WIN16 /*<VN>*/
+    else if (s_uMsg == WM_XBUTTONDOWN || s_uMsg == WM_XBUTTONDBLCLK)
+    {
+#ifndef GET_XBUTTON_WPARAM
+# define GET_XBUTTON_WPARAM(wParam)	(HIWORD(wParam))
+#endif
+	button = ((GET_XBUTTON_WPARAM(s_wParam) == 1) ? MOUSE_X1 : MOUSE_X2);
+    }
+    else if (s_uMsg == WM_CAPTURECHANGED)
+    {
+	/* on W95/NT4, somehow you get in here with an odd Msg
+	 * if you press one button while holding down the other..*/
+	if (s_button_pending == MOUSE_LEFT)
+	    button = MOUSE_RIGHT;
+	else
+	    button = MOUSE_LEFT;
+    }
+#endif
+    if (button >= 0)
+    {
+	repeated_click = ((int)(currentTime - s_prevTime) < p_mouset);
+
+	/*
+	 * Holding down the left and right buttons simulates pushing the middle
+	 * button.
+	 */
+	if (repeated_click
+		&& ((button == MOUSE_LEFT && s_button_pending == MOUSE_RIGHT)
+		    || (button == MOUSE_RIGHT
+					  && s_button_pending == MOUSE_LEFT)))
+	{
+	    /*
+	     * Hmm, gui.c will ignore more than one button down at a time, so
+	     * pretend we let go of it first.
+	     */
+	    gui_send_mouse_event(MOUSE_RELEASE, x, y, FALSE, 0x0);
+	    button = MOUSE_MIDDLE;
+	    repeated_click = FALSE;
+	    s_button_pending = -1;
+	    _OnMouseEvent(button, x, y, repeated_click, keyFlags);
+	}
+	else if ((repeated_click)
+		|| (mouse_model_popup() && (button == MOUSE_RIGHT)))
+	{
+	    if (s_button_pending > -1)
+	    {
+		    _OnMouseEvent(s_button_pending, x, y, FALSE, keyFlags);
+		    s_button_pending = -1;
+	    }
+	    /* TRACE("Button down at x %d, y %d\n", x, y); */
+	    _OnMouseEvent(button, x, y, repeated_click, keyFlags);
+	}
+	else
+	{
+	    /*
+	     * If this is the first press (i.e. not a multiple click) don't
+	     * action immediately, but store and wait for:
+	     * i) button-up
+	     * ii) mouse move
+	     * iii) another button press
+	     * before using it.
+	     * This enables us to make left+right simulate middle button,
+	     * without left or right being actioned first.  The side-effect is
+	     * that if you click and hold the mouse without dragging, the
+	     * cursor doesn't move until you release the button. In practice
+	     * this is hardly a problem.
+	     */
+	    s_button_pending = button;
+	    s_x_pending = x;
+	    s_y_pending = y;
+	    s_kFlags_pending = keyFlags;
+	}
+
+	s_prevTime = currentTime;
+    }
+}
+
+/*ARGSUSED*/
+    static void
+_OnMouseMoveOrRelease(
+    HWND hwnd,
+    int x,
+    int y,
+    UINT keyFlags)
+{
+    int button;
+
+    s_getting_focus = FALSE;
+    if (s_button_pending > -1)
+    {
+	/* Delayed action for mouse down event */
+	_OnMouseEvent(s_button_pending, s_x_pending,
+					s_y_pending, FALSE, s_kFlags_pending);
+	s_button_pending = -1;
+    }
+    if (s_uMsg == WM_MOUSEMOVE)
+    {
+	/*
+	 * It's only a MOUSE_DRAG if one or more mouse buttons are being held
+	 * down.
+	 */
+	if (!(keyFlags & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON
+						| MK_XBUTTON1 | MK_XBUTTON2)))
+	{
+	    gui_mouse_moved(x, y);
+	    return;
+	}
+
+	/*
+	 * While button is down, keep grabbing mouse move events when
+	 * the mouse goes outside the window
+	 */
+	SetCapture(s_textArea);
+	button = MOUSE_DRAG;
+	/* TRACE("  move at x %d, y %d\n", x, y); */
+    }
+    else
+    {
+	ReleaseCapture();
+	button = MOUSE_RELEASE;
+	/* TRACE("  up at x %d, y %d\n", x, y); */
+    }
+
+    _OnMouseEvent(button, x, y, FALSE, keyFlags);
+}
+
+#ifdef FEAT_MENU
+/*
+ * Find the vimmenu_T with the given id
+ */
+    static vimmenu_T *
+gui_mswin_find_menu(
+    vimmenu_T	*pMenu,
+    int		id)
+{
+    vimmenu_T	*pChildMenu;
+
+    while (pMenu)
+    {
+	if (pMenu->id == (UINT)id)
+	    break;
+	if (pMenu->children != NULL)
+	{
+	    pChildMenu = gui_mswin_find_menu(pMenu->children, id);
+	    if (pChildMenu)
+	    {
+		pMenu = pChildMenu;
+		break;
+	    }
+	}
+	pMenu = pMenu->next;
+    }
+    return pMenu;
+}
+
+/*ARGSUSED*/
+    static void
+_OnMenu(
+    HWND	hwnd,
+    int		id,
+    HWND	hwndCtl,
+    UINT	codeNotify)
+{
+    vimmenu_T	*pMenu;
+
+    pMenu = gui_mswin_find_menu(root_menu, id);
+    if (pMenu)
+	gui_menu_cb(pMenu);
+}
+#endif
+
+#ifdef MSWIN_FIND_REPLACE
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+/*
+ * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
+ */
+    static void
+findrep_atow(LPFINDREPLACEW lpfrw, LPFINDREPLACE lpfr)
+{
+    WCHAR *wp;
+
+    lpfrw->hwndOwner = lpfr->hwndOwner;
+    lpfrw->Flags = lpfr->Flags;
+
+    wp = enc_to_utf16(lpfr->lpstrFindWhat, NULL);
+    wcsncpy(lpfrw->lpstrFindWhat, wp, lpfrw->wFindWhatLen - 1);
+    vim_free(wp);
+
+    /* the field "lpstrReplaceWith" doesn't need to be copied */
+}
+
+/*
+ * copy useful data from structure LPFINDREPLACEW to structure LPFINDREPLACE
+ */
+    static void
+findrep_wtoa(LPFINDREPLACE lpfr, LPFINDREPLACEW lpfrw)
+{
+    char_u *p;
+
+    lpfr->Flags = lpfrw->Flags;
+
+    p = utf16_to_enc(lpfrw->lpstrFindWhat, NULL);
+    vim_strncpy(lpfr->lpstrFindWhat, p, lpfr->wFindWhatLen - 1);
+    vim_free(p);
+
+    p = utf16_to_enc(lpfrw->lpstrReplaceWith, NULL);
+    vim_strncpy(lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
+    vim_free(p);
+}
+# endif
+
+/*
+ * Handle a Find/Replace window message.
+ */
+    static void
+_OnFindRepl(void)
+{
+    int	    flags = 0;
+    int	    down;
+
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+    /* If the OS is Windows NT, and 'encoding' differs from active codepage:
+     * convert text from wide string. */
+    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
+    }
+# endif
+
+    if (s_findrep_struct.Flags & FR_DIALOGTERM)
+	/* Give main window the focus back. */
+	(void)SetFocus(s_hwnd);
+
+    if (s_findrep_struct.Flags & FR_FINDNEXT)
+    {
+	flags = FRD_FINDNEXT;
+
+	/* Give main window the focus back: this is so the cursor isn't
+	 * hollow. */
+	(void)SetFocus(s_hwnd);
+    }
+    else if (s_findrep_struct.Flags & FR_REPLACE)
+    {
+	flags = FRD_REPLACE;
+
+	/* Give main window the focus back: this is so the cursor isn't
+	 * hollow. */
+	(void)SetFocus(s_hwnd);
+    }
+    else if (s_findrep_struct.Flags & FR_REPLACEALL)
+    {
+	flags = FRD_REPLACEALL;
+    }
+
+    if (flags != 0)
+    {
+	/* Call the generic GUI function to do the actual work. */
+	if (s_findrep_struct.Flags & FR_WHOLEWORD)
+	    flags |= FRD_WHOLE_WORD;
+	if (s_findrep_struct.Flags & FR_MATCHCASE)
+	    flags |= FRD_MATCH_CASE;
+	down = (s_findrep_struct.Flags & FR_DOWN) != 0;
+	gui_do_findrepl(flags, s_findrep_struct.lpstrFindWhat,
+				     s_findrep_struct.lpstrReplaceWith, down);
+    }
+}
+#endif
+
+    static void
+HandleMouseHide(UINT uMsg, LPARAM lParam)
+{
+    static LPARAM last_lParam = 0L;
+
+    /* We sometimes get a mousemove when the mouse didn't move... */
+    if (uMsg == WM_MOUSEMOVE || uMsg == WM_NCMOUSEMOVE)
+    {
+	if (lParam == last_lParam)
+	    return;
+	last_lParam = lParam;
+    }
+
+    /* Handle specially, to centralise coding. We need to be sure we catch all
+     * possible events which should cause us to restore the cursor (as it is a
+     * shared resource, we take full responsibility for it).
+     */
+    switch (uMsg)
+    {
+    case WM_KEYUP:
+    case WM_CHAR:
+	/*
+	 * blank out the pointer if necessary
+	 */
+	if (p_mh)
+	    gui_mch_mousehide(TRUE);
+	break;
+
+    case WM_SYSKEYUP:	 /* show the pointer when a system-key is pressed */
+    case WM_SYSCHAR:
+    case WM_MOUSEMOVE:	 /* show the pointer on any mouse action */
+    case WM_LBUTTONDOWN:
+    case WM_LBUTTONUP:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_RBUTTONDOWN:
+    case WM_RBUTTONUP:
+    case WM_XBUTTONDOWN:
+    case WM_XBUTTONUP:
+    case WM_NCMOUSEMOVE:
+    case WM_NCLBUTTONDOWN:
+    case WM_NCLBUTTONUP:
+    case WM_NCMBUTTONDOWN:
+    case WM_NCMBUTTONUP:
+    case WM_NCRBUTTONDOWN:
+    case WM_NCRBUTTONUP:
+    case WM_KILLFOCUS:
+	/*
+	 * if the pointer is currently hidden, then we should show it.
+	 */
+	gui_mch_mousehide(FALSE);
+	break;
+    }
+}
+
+    static LRESULT CALLBACK
+_TextAreaWndProc(
+    HWND hwnd,
+    UINT uMsg,
+    WPARAM wParam,
+    LPARAM lParam)
+{
+    /*
+    TRACE("TextAreaWndProc: hwnd = %08x, msg = %x, wParam = %x, lParam = %x\n",
+	  hwnd, uMsg, wParam, lParam);
+    */
+
+    HandleMouseHide(uMsg, lParam);
+
+    s_uMsg = uMsg;
+    s_wParam = wParam;
+    s_lParam = lParam;
+
+#ifdef FEAT_BEVAL
+    TrackUserActivity(uMsg);
+#endif
+
+    switch (uMsg)
+    {
+	HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_LBUTTONDOWN,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_LBUTTONUP,	_OnMouseMoveOrRelease);
+	HANDLE_MSG(hwnd, WM_MBUTTONDBLCLK,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_MBUTTONDOWN,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_MBUTTONUP,	_OnMouseMoveOrRelease);
+	HANDLE_MSG(hwnd, WM_MOUSEMOVE,	_OnMouseMoveOrRelease);
+	HANDLE_MSG(hwnd, WM_PAINT,	_OnPaint);
+	HANDLE_MSG(hwnd, WM_RBUTTONDBLCLK,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_RBUTTONDOWN,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_RBUTTONUP,	_OnMouseMoveOrRelease);
+#ifndef WIN16 /*<VN>*/
+	HANDLE_MSG(hwnd, WM_XBUTTONDBLCLK,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_XBUTTONDOWN,_OnMouseButtonDown);
+	HANDLE_MSG(hwnd, WM_XBUTTONUP,	_OnMouseMoveOrRelease);
+#endif
+
+#ifdef FEAT_BEVAL
+	case WM_NOTIFY: Handle_WM_Notify(hwnd, (LPNMHDR)lParam);
+	    return TRUE;
+#endif
+	default:
+	    return MyWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+}
+
+#if (defined(WIN3264) && defined(FEAT_MBYTE)) \
+	|| defined(GLOBAL_IME) \
+	|| defined(PROTO)
+# ifdef PROTO
+typedef int WINAPI;
+# endif
+
+    LRESULT WINAPI
+vim_WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
+{
+# ifdef GLOBAL_IME
+    return global_ime_DefWindowProc(hwnd, message, wParam, lParam);
+# else
+    if (wide_WindowProc)
+	return DefWindowProcW(hwnd, message, wParam, lParam);
+    return DefWindowProc(hwnd, message, wParam, lParam);
+#endif
+}
+#endif
+
+/*
+ * Called when the foreground or background color has been changed.
+ */
+    void
+gui_mch_new_colors(void)
+{
+    /* nothing to do? */
+}
+
+/*
+ * Set the colors to their default values.
+ */
+    void
+gui_mch_def_colors()
+{
+    gui.norm_pixel = GetSysColor(COLOR_WINDOWTEXT);
+    gui.back_pixel = GetSysColor(COLOR_WINDOW);
+    gui.def_norm_pixel = gui.norm_pixel;
+    gui.def_back_pixel = gui.back_pixel;
+}
+
+/*
+ * Open the GUI window which was created by a call to gui_mch_init().
+ */
+    int
+gui_mch_open(void)
+{
+#ifndef SW_SHOWDEFAULT
+# define SW_SHOWDEFAULT 10	/* Borland 5.0 doesn't have it */
+#endif
+    /* Actually open the window, if not already visible
+     * (may be done already in gui_mch_set_shellsize) */
+    if (!IsWindowVisible(s_hwnd))
+	ShowWindow(s_hwnd, SW_SHOWDEFAULT);
+
+#ifdef MSWIN_FIND_REPLACE
+    /* Init replace string here, so that we keep it when re-opening the
+     * dialog. */
+    s_findrep_struct.lpstrReplaceWith[0] = NUL;
+#endif
+
+    return OK;
+}
+
+/*
+ * Get the position of the top left corner of the window.
+ */
+    int
+gui_mch_get_winpos(int *x, int *y)
+{
+    RECT    rect;
+
+    GetWindowRect(s_hwnd, &rect);
+    *x = rect.left;
+    *y = rect.top;
+    return OK;
+}
+
+/*
+ * Set the position of the top left corner of the window to the given
+ * coordinates.
+ */
+    void
+gui_mch_set_winpos(int x, int y)
+{
+    SetWindowPos(s_hwnd, NULL, x, y, 0, 0,
+		 SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
+}
+    void
+gui_mch_set_text_area_pos(int x, int y, int w, int h)
+{
+    static int oldx = 0;
+    static int oldy = 0;
+
+    SetWindowPos(s_textArea, NULL, x, y, w, h, SWP_NOZORDER | SWP_NOACTIVATE);
+
+#ifdef FEAT_TOOLBAR
+    if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+	SendMessage(s_toolbarhwnd, WM_SIZE,
+	      (WPARAM)0, (LPARAM)(w + ((long)(TOOLBAR_BUTTON_HEIGHT+8)<<16)));
+#endif
+#if defined(FEAT_GUI_TABLINE)
+    if (showing_tabline)
+    {
+	int	top = 0;
+	RECT	rect;
+
+# ifdef FEAT_TOOLBAR
+	if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
+	    top = TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
+# endif
+	GetClientRect(s_hwnd, &rect);
+	MoveWindow(s_tabhwnd, 0, top, rect.right, gui.tabline_height, TRUE);
+    }
+#endif
+
+    /* When side scroll bar is unshown, the size of window will change.
+     * then, the text area move left or right. thus client rect should be
+     * forcedly redrawn. (Yasuhiro Matsumoto) */
+    if (oldx != x || oldy != y)
+    {
+	InvalidateRect(s_hwnd, NULL, FALSE);
+	oldx = x;
+	oldy = y;
+    }
+}
+
+
+/*
+ * Scrollbar stuff:
+ */
+
+    void
+gui_mch_enable_scrollbar(
+    scrollbar_T     *sb,
+    int		    flag)
+{
+    ShowScrollBar(sb->id, SB_CTL, flag);
+
+    /* TODO: When the window is maximized, the size of the window stays the
+     * same, thus the size of the text area changes.  On Win98 it's OK, on Win
+     * NT 4.0 it's not... */
+}
+
+    void
+gui_mch_set_scrollbar_pos(
+    scrollbar_T *sb,
+    int		x,
+    int		y,
+    int		w,
+    int		h)
+{
+    SetWindowPos(sb->id, NULL, x, y, w, h,
+			      SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
+}
+
+    void
+gui_mch_create_scrollbar(
+    scrollbar_T *sb,
+    int		orient)	/* SBAR_VERT or SBAR_HORIZ */
+{
+    sb->id = CreateWindow(
+	"SCROLLBAR", "Scrollbar",
+	WS_CHILD | ((orient == SBAR_VERT) ? SBS_VERT : SBS_HORZ), 0, 0,
+	10,				/* Any value will do for now */
+	10,				/* Any value will do for now */
+	s_hwnd, NULL,
+	s_hinst, NULL);
+}
+
+/*
+ * Find the scrollbar with the given hwnd.
+ */
+	 static scrollbar_T *
+gui_mswin_find_scrollbar(HWND hwnd)
+{
+    win_T	*wp;
+
+    if (gui.bottom_sbar.id == hwnd)
+	return &gui.bottom_sbar;
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp->w_scrollbars[SBAR_LEFT].id == hwnd)
+	    return &wp->w_scrollbars[SBAR_LEFT];
+	if (wp->w_scrollbars[SBAR_RIGHT].id == hwnd)
+	    return &wp->w_scrollbars[SBAR_RIGHT];
+    }
+    return NULL;
+}
+
+/*
+ * Get the character size of a font.
+ */
+    static void
+GetFontSize(GuiFont font)
+{
+    HWND    hwnd = GetDesktopWindow();
+    HDC	    hdc = GetWindowDC(hwnd);
+    HFONT   hfntOld = SelectFont(hdc, (HFONT)font);
+    TEXTMETRIC tm;
+
+    GetTextMetrics(hdc, &tm);
+    gui.char_width = tm.tmAveCharWidth + tm.tmOverhang;
+
+    gui.char_height = tm.tmHeight
+#ifndef MSWIN16_FASTTEXT
+				+ p_linespace
+#endif
+				;
+
+    SelectFont(hdc, hfntOld);
+
+    ReleaseDC(hwnd, hdc);
+}
+
+/*
+ * Adjust gui.char_height (after 'linespace' was changed).
+ */
+    int
+gui_mch_adjust_charheight(void)
+{
+    GetFontSize(gui.norm_font);
+    return OK;
+}
+
+    static GuiFont
+get_font_handle(LOGFONT *lf)
+{
+    HFONT   font = NULL;
+
+    /* Load the font */
+    font = CreateFontIndirect(lf);
+
+    if (font == NULL)
+	return NOFONT;
+
+    return (GuiFont)font;
+}
+
+    static int
+pixels_to_points(int pixels, int vertical)
+{
+    int		points;
+    HWND	hwnd;
+    HDC		hdc;
+
+    hwnd = GetDesktopWindow();
+    hdc = GetWindowDC(hwnd);
+
+    points = MulDiv(pixels, 72,
+		    GetDeviceCaps(hdc, vertical ? LOGPIXELSY : LOGPIXELSX));
+
+    ReleaseDC(hwnd, hdc);
+
+    return points;
+}
+
+    GuiFont
+gui_mch_get_font(
+    char_u	*name,
+    int		giveErrorIfMissing)
+{
+    LOGFONT	lf;
+    GuiFont	font = NOFONT;
+
+    if (get_logfont(&lf, name, NULL, giveErrorIfMissing) == OK)
+	font = get_font_handle(&lf);
+    if (font == NOFONT && giveErrorIfMissing)
+	EMSG2(_(e_font), name);
+    return font;
+}
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Return the name of font "font" in allocated memory.
+ * Don't know how to get the actual name, thus use the provided name.
+ */
+/*ARGSUSED*/
+    char_u *
+gui_mch_get_fontname(font, name)
+    GuiFont font;
+    char_u  *name;
+{
+    if (name == NULL)
+	return NULL;
+    return vim_strsave(name);
+}
+#endif
+
+    void
+gui_mch_free_font(GuiFont font)
+{
+    if (font)
+	DeleteObject((HFONT)font);
+}
+
+    static int
+hex_digit(int c)
+{
+    if (VIM_ISDIGIT(c))
+	return c - '0';
+    c = TOLOWER_ASC(c);
+    if (c >= 'a' && c <= 'f')
+	return c - 'a' + 10;
+    return -1000;
+}
+/*
+ * Return the Pixel value (color) for the given color name.
+ * Return INVALCOLOR for error.
+ */
+    guicolor_T
+gui_mch_get_color(char_u *name)
+{
+    typedef struct guicolor_tTable
+    {
+	char	    *name;
+	COLORREF    color;
+    } guicolor_tTable;
+
+    static guicolor_tTable table[] =
+    {
+	{"Black",		RGB(0x00, 0x00, 0x00)},
+	{"DarkGray",		RGB(0xA9, 0xA9, 0xA9)},
+	{"DarkGrey",		RGB(0xA9, 0xA9, 0xA9)},
+	{"Gray",		RGB(0xC0, 0xC0, 0xC0)},
+	{"Grey",		RGB(0xC0, 0xC0, 0xC0)},
+	{"LightGray",		RGB(0xD3, 0xD3, 0xD3)},
+	{"LightGrey",		RGB(0xD3, 0xD3, 0xD3)},
+	{"Gray10",		RGB(0x1A, 0x1A, 0x1A)},
+	{"Grey10",		RGB(0x1A, 0x1A, 0x1A)},
+	{"Gray20",		RGB(0x33, 0x33, 0x33)},
+	{"Grey20",		RGB(0x33, 0x33, 0x33)},
+	{"Gray30",		RGB(0x4D, 0x4D, 0x4D)},
+	{"Grey30",		RGB(0x4D, 0x4D, 0x4D)},
+	{"Gray40",		RGB(0x66, 0x66, 0x66)},
+	{"Grey40",		RGB(0x66, 0x66, 0x66)},
+	{"Gray50",		RGB(0x7F, 0x7F, 0x7F)},
+	{"Grey50",		RGB(0x7F, 0x7F, 0x7F)},
+	{"Gray60",		RGB(0x99, 0x99, 0x99)},
+	{"Grey60",		RGB(0x99, 0x99, 0x99)},
+	{"Gray70",		RGB(0xB3, 0xB3, 0xB3)},
+	{"Grey70",		RGB(0xB3, 0xB3, 0xB3)},
+	{"Gray80",		RGB(0xCC, 0xCC, 0xCC)},
+	{"Grey80",		RGB(0xCC, 0xCC, 0xCC)},
+	{"Gray90",		RGB(0xE5, 0xE5, 0xE5)},
+	{"Grey90",		RGB(0xE5, 0xE5, 0xE5)},
+	{"White",		RGB(0xFF, 0xFF, 0xFF)},
+	{"DarkRed",		RGB(0x80, 0x00, 0x00)},
+	{"Red",			RGB(0xFF, 0x00, 0x00)},
+	{"LightRed",		RGB(0xFF, 0xA0, 0xA0)},
+	{"DarkBlue",		RGB(0x00, 0x00, 0x80)},
+	{"Blue",		RGB(0x00, 0x00, 0xFF)},
+	{"LightBlue",		RGB(0xAD, 0xD8, 0xE6)},
+	{"DarkGreen",		RGB(0x00, 0x80, 0x00)},
+	{"Green",		RGB(0x00, 0xFF, 0x00)},
+	{"LightGreen",		RGB(0x90, 0xEE, 0x90)},
+	{"DarkCyan",		RGB(0x00, 0x80, 0x80)},
+	{"Cyan",		RGB(0x00, 0xFF, 0xFF)},
+	{"LightCyan",		RGB(0xE0, 0xFF, 0xFF)},
+	{"DarkMagenta",		RGB(0x80, 0x00, 0x80)},
+	{"Magenta",		RGB(0xFF, 0x00, 0xFF)},
+	{"LightMagenta",	RGB(0xFF, 0xA0, 0xFF)},
+	{"Brown",		RGB(0x80, 0x40, 0x40)},
+	{"Yellow",		RGB(0xFF, 0xFF, 0x00)},
+	{"LightYellow",		RGB(0xFF, 0xFF, 0xE0)},
+	{"DarkYellow",		RGB(0xBB, 0xBB, 0x00)},
+	{"SeaGreen",		RGB(0x2E, 0x8B, 0x57)},
+	{"Orange",		RGB(0xFF, 0xA5, 0x00)},
+	{"Purple",		RGB(0xA0, 0x20, 0xF0)},
+	{"SlateBlue",		RGB(0x6A, 0x5A, 0xCD)},
+	{"Violet",		RGB(0xEE, 0x82, 0xEE)},
+    };
+
+    typedef struct SysColorTable
+    {
+	char	    *name;
+	int	    color;
+    } SysColorTable;
+
+    static SysColorTable sys_table[] =
+    {
+#ifdef WIN3264
+	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
+	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
+#ifndef __MINGW32__
+	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
+#endif
+	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
+	{"SYS_BTNHIGHLIGHT", COLOR_BTNHIGHLIGHT},
+	{"SYS_3DLIGHT", COLOR_3DLIGHT},
+	{"SYS_3DSHADOW", COLOR_3DSHADOW},
+	{"SYS_DESKTOP", COLOR_DESKTOP},
+	{"SYS_INFOBK", COLOR_INFOBK},
+	{"SYS_INFOTEXT", COLOR_INFOTEXT},
+	{"SYS_3DFACE", COLOR_3DFACE},
+#endif
+	{"SYS_BTNFACE", COLOR_BTNFACE},
+	{"SYS_BTNSHADOW", COLOR_BTNSHADOW},
+	{"SYS_ACTIVEBORDER", COLOR_ACTIVEBORDER},
+	{"SYS_ACTIVECAPTION", COLOR_ACTIVECAPTION},
+	{"SYS_APPWORKSPACE", COLOR_APPWORKSPACE},
+	{"SYS_BACKGROUND", COLOR_BACKGROUND},
+	{"SYS_BTNTEXT", COLOR_BTNTEXT},
+	{"SYS_CAPTIONTEXT", COLOR_CAPTIONTEXT},
+	{"SYS_GRAYTEXT", COLOR_GRAYTEXT},
+	{"SYS_HIGHLIGHT", COLOR_HIGHLIGHT},
+	{"SYS_HIGHLIGHTTEXT", COLOR_HIGHLIGHTTEXT},
+	{"SYS_INACTIVEBORDER", COLOR_INACTIVEBORDER},
+	{"SYS_INACTIVECAPTION", COLOR_INACTIVECAPTION},
+	{"SYS_INACTIVECAPTIONTEXT", COLOR_INACTIVECAPTIONTEXT},
+	{"SYS_MENU", COLOR_MENU},
+	{"SYS_MENUTEXT", COLOR_MENUTEXT},
+	{"SYS_SCROLLBAR", COLOR_SCROLLBAR},
+	{"SYS_WINDOW", COLOR_WINDOW},
+	{"SYS_WINDOWFRAME", COLOR_WINDOWFRAME},
+	{"SYS_WINDOWTEXT", COLOR_WINDOWTEXT}
+    };
+
+    int		    r, g, b;
+    int		    i;
+
+    if (name[0] == '#' && strlen(name) == 7)
+    {
+	/* Name is in "#rrggbb" format */
+	r = hex_digit(name[1]) * 16 + hex_digit(name[2]);
+	g = hex_digit(name[3]) * 16 + hex_digit(name[4]);
+	b = hex_digit(name[5]) * 16 + hex_digit(name[6]);
+	if (r < 0 || g < 0 || b < 0)
+	    return INVALCOLOR;
+	return RGB(r, g, b);
+    }
+    else
+    {
+	/* Check if the name is one of the colors we know */
+	for (i = 0; i < sizeof(table) / sizeof(table[0]); i++)
+	    if (STRICMP(name, table[i].name) == 0)
+		return table[i].color;
+    }
+
+    /*
+     * Try to look up a system colour.
+     */
+    for (i = 0; i < sizeof(sys_table) / sizeof(sys_table[0]); i++)
+	if (STRICMP(name, sys_table[i].name) == 0)
+	    return GetSysColor(sys_table[i].color);
+
+    /*
+     * Last attempt. Look in the file "$VIMRUNTIME/rgb.txt".
+     */
+    {
+#define LINE_LEN 100
+	FILE	*fd;
+	char	line[LINE_LEN];
+	char_u	*fname;
+
+	fname = expand_env_save((char_u *)"$VIMRUNTIME/rgb.txt");
+	if (fname == NULL)
+	    return INVALCOLOR;
+
+	fd = mch_fopen((char *)fname, "rt");
+	vim_free(fname);
+	if (fd == NULL)
+	    return INVALCOLOR;
+
+	while (!feof(fd))
+	{
+	    int	    len;
+	    int	    pos;
+	    char    *color;
+
+	    fgets(line, LINE_LEN, fd);
+	    len = (int)STRLEN(line);
+
+	    if (len <= 1 || line[len-1] != '\n')
+		continue;
+
+	    line[len-1] = '\0';
+
+	    i = sscanf(line, "%d %d %d %n", &r, &g, &b, &pos);
+	    if (i != 3)
+		continue;
+
+	    color = line + pos;
+
+	    if (STRICMP(color, name) == 0)
+	    {
+		fclose(fd);
+		return (guicolor_T) RGB(r, g, b);
+	    }
+	}
+
+	fclose(fd);
+    }
+
+    return INVALCOLOR;
+}
+/*
+ * Return OK if the key with the termcap name "name" is supported.
+ */
+    int
+gui_mch_haskey(char_u *name)
+{
+    int i;
+
+    for (i = 0; special_keys[i].vim_code1 != NUL; i++)
+	if (name[0] == special_keys[i].vim_code0 &&
+					 name[1] == special_keys[i].vim_code1)
+	    return OK;
+    return FAIL;
+}
+
+    void
+gui_mch_beep(void)
+{
+    MessageBeep(MB_OK);
+}
+/*
+ * Invert a rectangle from row r, column c, for nr rows and nc columns.
+ */
+    void
+gui_mch_invert_rectangle(
+    int	    r,
+    int	    c,
+    int	    nr,
+    int	    nc)
+{
+    RECT    rc;
+
+    /*
+     * Note: InvertRect() excludes right and bottom of rectangle.
+     */
+    rc.left = FILL_X(c);
+    rc.top = FILL_Y(r);
+    rc.right = rc.left + nc * gui.char_width;
+    rc.bottom = rc.top + nr * gui.char_height;
+    InvertRect(s_hdc, &rc);
+}
+
+/*
+ * Iconify the GUI window.
+ */
+    void
+gui_mch_iconify(void)
+{
+    ShowWindow(s_hwnd, SW_MINIMIZE);
+}
+
+/*
+ * Draw a cursor without focus.
+ */
+    void
+gui_mch_draw_hollow_cursor(guicolor_T color)
+{
+    HBRUSH  hbr;
+    RECT    rc;
+
+    /*
+     * Note: FrameRect() excludes right and bottom of rectangle.
+     */
+    rc.left = FILL_X(gui.col);
+    rc.top = FILL_Y(gui.row);
+    rc.right = rc.left + gui.char_width;
+#ifdef FEAT_MBYTE
+    if (mb_lefthalve(gui.row, gui.col))
+	rc.right += gui.char_width;
+#endif
+    rc.bottom = rc.top + gui.char_height;
+    hbr = CreateSolidBrush(color);
+    FrameRect(s_hdc, &rc, hbr);
+    DeleteBrush(hbr);
+}
+/*
+ * Draw part of a cursor, "w" pixels wide, and "h" pixels high, using
+ * color "color".
+ */
+    void
+gui_mch_draw_part_cursor(
+    int		w,
+    int		h,
+    guicolor_T	color)
+{
+    HBRUSH	hbr;
+    RECT	rc;
+
+    /*
+     * Note: FillRect() excludes right and bottom of rectangle.
+     */
+    rc.left =
+#ifdef FEAT_RIGHTLEFT
+		/* vertical line should be on the right of current point */
+		CURSOR_BAR_RIGHT ? FILL_X(gui.col + 1) - w :
+#endif
+		    FILL_X(gui.col);
+    rc.top = FILL_Y(gui.row) + gui.char_height - h;
+    rc.right = rc.left + w;
+    rc.bottom = rc.top + h;
+    hbr = CreateSolidBrush(color);
+    FillRect(s_hdc, &rc, hbr);
+    DeleteBrush(hbr);
+}
+
+/*
+ * Process a single Windows message.
+ * If one is not available we hang until one is.
+ */
+    static void
+process_message(void)
+{
+    MSG		msg;
+    UINT	vk = 0;		/* Virtual key */
+    char_u	string[40];
+    int		i;
+    int		modifiers = 0;
+    int		key;
+#ifdef FEAT_MENU
+    static char_u k10[] = {K_SPECIAL, 'k', ';', 0};
+#endif
+
+    pGetMessage(&msg, NULL, 0, 0);
+
+#ifdef FEAT_OLE
+    /* Look after OLE Automation commands */
+    if (msg.message == WM_OLE)
+    {
+	char_u *str = (char_u *)msg.lParam;
+	if (str == NULL || *str == NUL)
+	{
+	    /* Message can't be ours, forward it.  Fixes problem with Ultramon
+	     * 3.0.4 */
+	    pDispatchMessage(&msg);
+	}
+	else
+	{
+	    add_to_input_buf(str, (int)STRLEN(str));
+	    vim_free(str);  /* was allocated in CVim::SendKeys() */
+	}
+	return;
+    }
+#endif
+
+#ifdef FEAT_NETBEANS_INTG
+    if (msg.message == WM_NETBEANS)
+    {
+	netbeans_read();
+	return;
+    }
+#endif
+
+#ifdef FEAT_SNIFF
+    if (sniff_request_waiting && want_sniff_request)
+    {
+	static char_u bytes[3] = {CSI, (char_u)KS_EXTRA, (char_u)KE_SNIFF};
+	add_to_input_buf(bytes, 3); /* K_SNIFF */
+	sniff_request_waiting = 0;
+	want_sniff_request = 0;
+	/* request is handled in normal.c */
+    }
+    if (msg.message == WM_USER)
+    {
+	MyTranslateMessage(&msg);
+	pDispatchMessage(&msg);
+	return;
+    }
+#endif
+
+#ifdef MSWIN_FIND_REPLACE
+    /* Don't process messages used by the dialog */
+    if (s_findrep_hwnd != NULL && pIsDialogMessage(s_findrep_hwnd, &msg))
+    {
+	HandleMouseHide(msg.message, msg.lParam);
+	return;
+    }
+#endif
+
+    /*
+     * Check if it's a special key that we recognise.  If not, call
+     * TranslateMessage().
+     */
+    if (msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN)
+    {
+	vk = (int) msg.wParam;
+	/*
+	 * If a dead key was pressed and the user presses VK_SPACE, VK_BACK, or
+	 * VK_ESCAPE it means that he actually wants to deal with the dead char
+	 * now, so do nothing special and let Windows handle it.
+	 *
+	 * Note that VK_SPACE combines with the dead_key's character and only
+	 * one WM_CHAR will be generated by TranslateMessage(), in the two
+	 * other cases two WM_CHAR will be generated: the dead char and VK_BACK
+	 * or VK_ESCAPE.  That is most likely what the user expects.
+	 */
+	if (dead_key && (vk == VK_SPACE || vk == VK_BACK || vk == VK_ESCAPE))
+	{
+	    dead_key = 0;
+	    MyTranslateMessage(&msg);
+	    return;
+	}
+
+	/* Check for CTRL-BREAK */
+	if (vk == VK_CANCEL)
+	{
+	    trash_input_buf();
+	    got_int = TRUE;
+	    string[0] = Ctrl_C;
+	    add_to_input_buf(string, 1);
+	}
+
+	for (i = 0; special_keys[i].key_sym != 0; i++)
+	{
+	    /* ignore VK_SPACE when ALT key pressed: system menu */
+	    if (special_keys[i].key_sym == vk
+		    && (vk != VK_SPACE || !(GetKeyState(VK_MENU) & 0x8000)))
+	    {
+#ifdef FEAT_MENU
+		/* Check for <F10>: Windows selects the menu.  When <F10> is
+		 * mapped we want to use the mapping instead. */
+		if (vk == VK_F10
+			&& gui.menu_is_active
+			&& check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
+		    break;
+#endif
+		if (GetKeyState(VK_SHIFT) & 0x8000)
+		    modifiers |= MOD_MASK_SHIFT;
+		/*
+		 * Don't use caps-lock as shift, because these are special keys
+		 * being considered here, and we only want letters to get
+		 * shifted -- webb
+		 */
+		/*
+		if (GetKeyState(VK_CAPITAL) & 0x0001)
+		    modifiers ^= MOD_MASK_SHIFT;
+		*/
+		if (GetKeyState(VK_CONTROL) & 0x8000)
+		    modifiers |= MOD_MASK_CTRL;
+		if (GetKeyState(VK_MENU) & 0x8000)
+		    modifiers |= MOD_MASK_ALT;
+
+		if (special_keys[i].vim_code1 == NUL)
+		    key = special_keys[i].vim_code0;
+		else
+		    key = TO_SPECIAL(special_keys[i].vim_code0,
+						   special_keys[i].vim_code1);
+		key = simplify_key(key, &modifiers);
+		if (key == CSI)
+		    key = K_CSI;
+
+		if (modifiers)
+		{
+		    string[0] = CSI;
+		    string[1] = KS_MODIFIER;
+		    string[2] = modifiers;
+		    add_to_input_buf(string, 3);
+		}
+
+		if (IS_SPECIAL(key))
+		{
+		    string[0] = CSI;
+		    string[1] = K_SECOND(key);
+		    string[2] = K_THIRD(key);
+		    add_to_input_buf(string, 3);
+		}
+		else
+		{
+		    int	len;
+
+		    /* Handle "key" as a Unicode character. */
+		    len = char_to_string(key, string, 40, FALSE);
+		    add_to_input_buf(string, len);
+		}
+		break;
+	    }
+	}
+	if (special_keys[i].key_sym == 0)
+	{
+	    /* Some keys need C-S- where they should only need C-.
+	     * Ignore 0xff, Windows XP sends it when NUMLOCK has changed since
+	     * system startup (Helmut Stiegler, 2003 Oct 3). */
+	    if (vk != 0xff
+		    && (GetKeyState(VK_CONTROL) & 0x8000)
+		    && !(GetKeyState(VK_SHIFT) & 0x8000)
+		    && !(GetKeyState(VK_MENU) & 0x8000))
+	    {
+		/* CTRL-6 is '^'; Japanese keyboard maps '^' to vk == 0xDE */
+		if (vk == '6' || MapVirtualKey(vk, 2) == (UINT)'^')
+		{
+		    string[0] = Ctrl_HAT;
+		    add_to_input_buf(string, 1);
+		}
+		/* vk == 0xBD AZERTY for CTRL-'-', but CTRL-[ for * QWERTY! */
+		else if (vk == 0xBD)	/* QWERTY for CTRL-'-' */
+		{
+		    string[0] = Ctrl__;
+		    add_to_input_buf(string, 1);
+		}
+		/* CTRL-2 is '@'; Japanese keyboard maps '@' to vk == 0xC0 */
+		else if (vk == '2' || MapVirtualKey(vk, 2) == (UINT)'@')
+		{
+		    string[0] = Ctrl_AT;
+		    add_to_input_buf(string, 1);
+		}
+		else
+		    MyTranslateMessage(&msg);
+	    }
+	    else
+		MyTranslateMessage(&msg);
+	}
+    }
+#ifdef FEAT_MBYTE_IME
+    else if (msg.message == WM_IME_NOTIFY)
+	_OnImeNotify(msg.hwnd, (DWORD)msg.wParam, (DWORD)msg.lParam);
+    else if (msg.message == WM_KEYUP && im_get_status())
+	/* added for non-MS IME (Yasuhiro Matsumoto) */
+	MyTranslateMessage(&msg);
+#endif
+#if !defined(FEAT_MBYTE_IME) && defined(GLOBAL_IME)
+/* GIME_TEST */
+    else if (msg.message == WM_IME_STARTCOMPOSITION)
+    {
+	POINT point;
+
+	global_ime_set_font(&norm_logfont);
+	point.x = FILL_X(gui.col);
+	point.y = FILL_Y(gui.row);
+	MapWindowPoints(s_textArea, s_hwnd, &point, 1);
+	global_ime_set_position(&point);
+    }
+#endif
+
+#ifdef FEAT_MENU
+    /* Check for <F10>: Default effect is to select the menu.  When <F10> is
+     * mapped we need to stop it here to avoid strange effects (e.g., for the
+     * key-up event) */
+    if (vk != VK_F10 || check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
+#endif
+	pDispatchMessage(&msg);
+}
+
+/*
+ * Catch up with any queued events.  This may put keyboard input into the
+ * input buffer, call resize call-backs, trigger timers etc.  If there is
+ * nothing in the event queue (& no timers pending), then we return
+ * immediately.
+ */
+    void
+gui_mch_update(void)
+{
+    MSG	    msg;
+
+    if (!s_busy_processing)
+	while (pPeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)
+						  && !vim_is_input_buf_full())
+	    process_message();
+}
+
+/*
+ * GUI input routine called by gui_wait_for_chars().  Waits for a character
+ * from the keyboard.
+ *  wtime == -1	    Wait forever.
+ *  wtime == 0	    This should never happen.
+ *  wtime > 0	    Wait wtime milliseconds for a character.
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+    int
+gui_mch_wait_for_chars(int wtime)
+{
+    MSG		msg;
+    int		focus;
+
+    s_timed_out = FALSE;
+
+    if (wtime > 0)
+    {
+	/* Don't do anything while processing a (scroll) message. */
+	if (s_busy_processing)
+	    return FAIL;
+	s_wait_timer = (UINT)SetTimer(NULL, 0, (UINT)wtime,
+							 (TIMERPROC)_OnTimer);
+    }
+
+    allow_scrollbar = TRUE;
+
+    focus = gui.in_focus;
+    while (!s_timed_out)
+    {
+	/* Stop or start blinking when focus changes */
+	if (gui.in_focus != focus)
+	{
+	    if (gui.in_focus)
+		gui_mch_start_blink();
+	    else
+		gui_mch_stop_blink();
+	    focus = gui.in_focus;
+	}
+
+	if (s_need_activate)
+	{
+#ifdef WIN32
+	    (void)SetForegroundWindow(s_hwnd);
+#else
+	    (void)SetActiveWindow(s_hwnd);
+#endif
+	    s_need_activate = FALSE;
+	}
+
+#ifdef MESSAGE_QUEUE
+	parse_queued_messages();
+#endif
+
+	/*
+	 * Don't use gui_mch_update() because then we will spin-lock until a
+	 * char arrives, instead we use GetMessage() to hang until an
+	 * event arrives.  No need to check for input_buf_full because we are
+	 * returning as soon as it contains a single char -- webb
+	 */
+	process_message();
+
+	if (input_available())
+	{
+	    if (s_wait_timer != 0 && !s_timed_out)
+	    {
+		KillTimer(NULL, s_wait_timer);
+
+		/* Eat spurious WM_TIMER messages */
+		while (pPeekMessage(&msg, s_hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
+		    ;
+		s_wait_timer = 0;
+	    }
+	    allow_scrollbar = FALSE;
+
+	    /* Clear pending mouse button, the release event may have been
+	     * taken by the dialog window.  But don't do this when getting
+	     * focus, we need the mouse-up event then. */
+	    if (!s_getting_focus)
+		s_button_pending = -1;
+
+	    return OK;
+	}
+    }
+    allow_scrollbar = FALSE;
+    return FAIL;
+}
+
+/*
+ * Clear a rectangular region of the screen from text pos (row1, col1) to
+ * (row2, col2) inclusive.
+ */
+    void
+gui_mch_clear_block(
+    int		row1,
+    int		col1,
+    int		row2,
+    int		col2)
+{
+    RECT	rc;
+
+    /*
+     * Clear one extra pixel at the far right, for when bold characters have
+     * spilled over to the window border.
+     * Note: FillRect() excludes right and bottom of rectangle.
+     */
+    rc.left = FILL_X(col1);
+    rc.top = FILL_Y(row1);
+    rc.right = FILL_X(col2 + 1) + (col2 == Columns - 1);
+    rc.bottom = FILL_Y(row2 + 1);
+    clear_rect(&rc);
+}
+
+/*
+ * Clear the whole text window.
+ */
+    void
+gui_mch_clear_all(void)
+{
+    RECT    rc;
+
+    rc.left = 0;
+    rc.top = 0;
+    rc.right = Columns * gui.char_width + 2 * gui.border_width;
+    rc.bottom = Rows * gui.char_height + 2 * gui.border_width;
+    clear_rect(&rc);
+}
+/*
+ * Menu stuff.
+ */
+
+    void
+gui_mch_enable_menu(int flag)
+{
+#ifdef FEAT_MENU
+    SetMenu(s_hwnd, flag ? s_menuBar : NULL);
+#endif
+}
+
+/*ARGSUSED*/
+    void
+gui_mch_set_menu_pos(
+    int	    x,
+    int	    y,
+    int	    w,
+    int	    h)
+{
+    /* It will be in the right place anyway */
+}
+
+#if defined(FEAT_MENU) || defined(PROTO)
+/*
+ * Make menu item hidden or not hidden
+ */
+    void
+gui_mch_menu_hidden(
+    vimmenu_T	*menu,
+    int		hidden)
+{
+    /*
+     * This doesn't do what we want.  Hmm, just grey the menu items for now.
+     */
+    /*
+    if (hidden)
+	EnableMenuItem(s_menuBar, menu->id, MF_BYCOMMAND | MF_DISABLED);
+    else
+	EnableMenuItem(s_menuBar, menu->id, MF_BYCOMMAND | MF_ENABLED);
+    */
+    gui_mch_menu_grey(menu, hidden);
+}
+
+/*
+ * This is called after setting all the menus to grey/hidden or not.
+ */
+    void
+gui_mch_draw_menubar(void)
+{
+    DrawMenuBar(s_hwnd);
+}
+#endif /*FEAT_MENU*/
+
+#ifndef PROTO
+void
+#ifdef VIMDLL
+_export
+#endif
+_cdecl
+SaveInst(HINSTANCE hInst)
+{
+    s_hinst = hInst;
+}
+#endif
+
+/*
+ * Return the RGB value of a pixel as a long.
+ */
+    long_u
+gui_mch_get_rgb(guicolor_T pixel)
+{
+    return (GetRValue(pixel) << 16) + (GetGValue(pixel) << 8)
+							   + GetBValue(pixel);
+}
+
+#if defined(FEAT_GUI_DIALOG) || defined(PROTO)
+/* Convert pixels in X to dialog units */
+    static WORD
+PixelToDialogX(int numPixels)
+{
+    return (WORD)((numPixels * 4) / s_dlgfntwidth);
+}
+
+/* Convert pixels in Y to dialog units */
+    static WORD
+PixelToDialogY(int numPixels)
+{
+    return (WORD)((numPixels * 8) / s_dlgfntheight);
+}
+
+/* Return the width in pixels of the given text in the given DC. */
+    static int
+GetTextWidth(HDC hdc, char_u *str, int len)
+{
+    SIZE    size;
+
+    GetTextExtentPoint(hdc, str, len, &size);
+    return size.cx;
+}
+
+#ifdef FEAT_MBYTE
+/*
+ * Return the width in pixels of the given text in the given DC, taking care
+ * of 'encoding' to active codepage conversion.
+ */
+    static int
+GetTextWidthEnc(HDC hdc, char_u *str, int len)
+{
+    SIZE	size;
+    WCHAR	*wstr;
+    int		n;
+    int		wlen = len;
+
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	/* 'encoding' differs from active codepage: convert text and use wide
+	 * function */
+	wstr = enc_to_utf16(str, &wlen);
+	if (wstr != NULL)
+	{
+	    n = GetTextExtentPointW(hdc, wstr, wlen, &size);
+	    vim_free(wstr);
+	    if (n)
+		return size.cx;
+	}
+    }
+
+    return GetTextWidth(hdc, str, len);
+}
+#else
+# define GetTextWidthEnc(h, s, l) GetTextWidth((h), (s), (l))
+#endif
+
+/*
+ * A quick little routine that will center one window over another, handy for
+ * dialog boxes.  Taken from the Win32SDK samples.
+ */
+    static BOOL
+CenterWindow(
+    HWND hwndChild,
+    HWND hwndParent)
+{
+    RECT    rChild, rParent;
+    int     wChild, hChild, wParent, hParent;
+    int     wScreen, hScreen, xNew, yNew;
+    HDC     hdc;
+
+    GetWindowRect(hwndChild, &rChild);
+    wChild = rChild.right - rChild.left;
+    hChild = rChild.bottom - rChild.top;
+
+    /* If Vim is minimized put the window in the middle of the screen. */
+    if (hwndParent == NULL || IsMinimized(hwndParent))
+    {
+#ifdef WIN16
+	rParent.left = 0;
+	rParent.top = 0;
+	rParent.right = GetSystemMetrics(SM_CXSCREEN);
+	rParent.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
+#else
+	SystemParametersInfo(SPI_GETWORKAREA, 0, &rParent, 0);
+#endif
+    }
+    else
+	GetWindowRect(hwndParent, &rParent);
+    wParent = rParent.right - rParent.left;
+    hParent = rParent.bottom - rParent.top;
+
+    hdc = GetDC(hwndChild);
+    wScreen = GetDeviceCaps (hdc, HORZRES);
+    hScreen = GetDeviceCaps (hdc, VERTRES);
+    ReleaseDC(hwndChild, hdc);
+
+    xNew = rParent.left + ((wParent - wChild) /2);
+    if (xNew < 0)
+    {
+	xNew = 0;
+    }
+    else if ((xNew+wChild) > wScreen)
+    {
+	xNew = wScreen - wChild;
+    }
+
+    yNew = rParent.top	+ ((hParent - hChild) /2);
+    if (yNew < 0)
+	yNew = 0;
+    else if ((yNew+hChild) > hScreen)
+	yNew = hScreen - hChild;
+
+    return SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0,
+						   SWP_NOSIZE | SWP_NOZORDER);
+}
+#endif /* FEAT_GUI_DIALOG */
+
+void
+gui_mch_activate_window(void)
+{
+    (void)SetActiveWindow(s_hwnd);
+}
+
+#if defined(FEAT_TOOLBAR) || defined(PROTO)
+    void
+gui_mch_show_toolbar(int showit)
+{
+    if (s_toolbarhwnd == NULL)
+	return;
+
+    if (showit)
+    {
+# ifdef FEAT_MBYTE
+#  ifndef TB_SETUNICODEFORMAT
+    /* For older compilers.  We assume this never changes. */
+#   define TB_SETUNICODEFORMAT 0x2005
+#  endif
+	/* Enable/disable unicode support */
+	int uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
+	SendMessage(s_toolbarhwnd, TB_SETUNICODEFORMAT, (WPARAM)uu, (LPARAM)0);
+# endif
+	ShowWindow(s_toolbarhwnd, SW_SHOW);
+    }
+    else
+	ShowWindow(s_toolbarhwnd, SW_HIDE);
+}
+
+/* Then number of bitmaps is fixed.  Exit is missing! */
+#define TOOLBAR_BITMAP_COUNT 31
+
+#endif
+
+#if defined(FEAT_GUI_TABLINE) || defined(PROTO)
+    static void
+add_tabline_popup_menu_entry(HMENU pmenu, UINT item_id, char_u *item_text)
+{
+#ifdef FEAT_MBYTE
+    WCHAR	*wn = NULL;
+    int		n;
+
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	/* 'encoding' differs from active codepage: convert menu name
+	 * and use wide function */
+	wn = enc_to_utf16(item_text, NULL);
+	if (wn != NULL)
+	{
+	    MENUITEMINFOW	infow;
+
+	    infow.cbSize = sizeof(infow);
+	    infow.fMask = MIIM_TYPE | MIIM_ID;
+	    infow.wID = item_id;
+	    infow.fType = MFT_STRING;
+	    infow.dwTypeData = wn;
+	    infow.cch = (UINT)wcslen(wn);
+	    n = InsertMenuItemW(pmenu, item_id, FALSE, &infow);
+	    vim_free(wn);
+	    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
+		/* Failed, try using non-wide function. */
+		wn = NULL;
+	}
+    }
+
+    if (wn == NULL)
+#endif
+    {
+	MENUITEMINFO	info;
+
+	info.cbSize = sizeof(info);
+	info.fMask = MIIM_TYPE | MIIM_ID;
+	info.wID = item_id;
+	info.fType = MFT_STRING;
+	info.dwTypeData = item_text;
+	info.cch = (UINT)STRLEN(item_text);
+	InsertMenuItem(pmenu, item_id, FALSE, &info);
+    }
+}
+
+    static void
+show_tabline_popup_menu(void)
+{
+    HMENU	    tab_pmenu;
+    long	    rval;
+    POINT	    pt;
+
+    /* When ignoring events don't show the menu. */
+    if (hold_gui_events
+# ifdef FEAT_CMDWIN
+	    || cmdwin_type != 0
+# endif
+       )
+	return;
+
+    tab_pmenu = CreatePopupMenu();
+    if (tab_pmenu == NULL)
+	return;
+
+    if (first_tabpage->tp_next != NULL)
+	add_tabline_popup_menu_entry(tab_pmenu,
+					  TABLINE_MENU_CLOSE, _("Close tab"));
+    add_tabline_popup_menu_entry(tab_pmenu, TABLINE_MENU_NEW, _("New tab"));
+    add_tabline_popup_menu_entry(tab_pmenu, TABLINE_MENU_OPEN,
+				 _("Open tab..."));
+
+    GetCursorPos(&pt);
+    rval = TrackPopupMenuEx(tab_pmenu, TPM_RETURNCMD, pt.x, pt.y, s_tabhwnd,
+									NULL);
+
+    DestroyMenu(tab_pmenu);
+
+    /* Add the string cmd into input buffer */
+    if (rval > 0)
+    {
+	TCHITTESTINFO htinfo;
+	int idx;
+
+	if (ScreenToClient(s_tabhwnd, &pt) == 0)
+	    return;
+
+	htinfo.pt.x = pt.x;
+	htinfo.pt.y = pt.y;
+	idx = TabCtrl_HitTest(s_tabhwnd, &htinfo);
+	if (idx == -1)
+	    idx = 0;
+	else
+	    idx += 1;
+
+	send_tabline_menu_event(idx, (int)rval);
+    }
+}
+
+/*
+ * Show or hide the tabline.
+ */
+    void
+gui_mch_show_tabline(int showit)
+{
+    if (s_tabhwnd == NULL)
+	return;
+
+    if (!showit != !showing_tabline)
+    {
+	if (showit)
+	    ShowWindow(s_tabhwnd, SW_SHOW);
+	else
+	    ShowWindow(s_tabhwnd, SW_HIDE);
+	showing_tabline = showit;
+    }
+}
+
+/*
+ * Return TRUE when tabline is displayed.
+ */
+    int
+gui_mch_showing_tabline(void)
+{
+    return s_tabhwnd != NULL && showing_tabline;
+}
+
+/*
+ * Update the labels of the tabline.
+ */
+    void
+gui_mch_update_tabline(void)
+{
+    tabpage_T	*tp;
+    TCITEM	tie;
+    int		nr = 0;
+    int		curtabidx = 0;
+    int		tabadded = 0;
+#ifdef FEAT_MBYTE
+    static int	use_unicode = FALSE;
+    int		uu;
+    WCHAR	*wstr = NULL;
+#endif
+
+    if (s_tabhwnd == NULL)
+	return;
+
+#if defined(FEAT_MBYTE)
+# ifndef CCM_SETUNICODEFORMAT
+    /* For older compilers.  We assume this never changes. */
+#  define CCM_SETUNICODEFORMAT 0x2005
+# endif
+    uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
+    if (uu != use_unicode)
+    {
+	/* Enable/disable unicode support */
+	SendMessage(s_tabhwnd, CCM_SETUNICODEFORMAT, (WPARAM)uu, (LPARAM)0);
+	use_unicode = uu;
+    }
+#endif
+
+    tie.mask = TCIF_TEXT;
+    tie.iImage = -1;
+
+    /* Disable redraw for tab updates to eliminate O(N^2) draws. */
+    SendMessage(s_tabhwnd, WM_SETREDRAW, (WPARAM)FALSE, 0);
+
+    /* Add a label for each tab page.  They all contain the same text area. */
+    for (tp = first_tabpage; tp != NULL; tp = tp->tp_next, ++nr)
+    {
+	if (tp == curtab)
+	    curtabidx = nr;
+
+	if (nr >= TabCtrl_GetItemCount(s_tabhwnd))
+	{
+	    /* Add the tab */
+	    tie.pszText = "-Empty-";
+	    TabCtrl_InsertItem(s_tabhwnd, nr, &tie);
+	    tabadded = 1;
+	}
+
+	get_tabline_label(tp, FALSE);
+	tie.pszText = NameBuff;
+#ifdef FEAT_MBYTE
+	wstr = NULL;
+	if (use_unicode)
+	{
+	    /* Need to go through Unicode. */
+	    wstr = enc_to_utf16(NameBuff, NULL);
+	    if (wstr != NULL)
+	    {
+		TCITEMW		tiw;
+
+		tiw.mask = TCIF_TEXT;
+		tiw.iImage = -1;
+		tiw.pszText = wstr;
+		SendMessage(s_tabhwnd, TCM_SETITEMW, (WPARAM)nr, (LPARAM)&tiw);
+		vim_free(wstr);
+	    }
+	}
+	if (wstr == NULL)
+#endif
+	{
+	    TabCtrl_SetItem(s_tabhwnd, nr, &tie);
+	}
+    }
+
+    /* Remove any old labels. */
+    while (nr < TabCtrl_GetItemCount(s_tabhwnd))
+	TabCtrl_DeleteItem(s_tabhwnd, nr);
+
+    if (!tabadded && TabCtrl_GetCurSel(s_tabhwnd) != curtabidx)
+	TabCtrl_SetCurSel(s_tabhwnd, curtabidx);
+
+    /* Re-enable redraw and redraw. */
+    SendMessage(s_tabhwnd, WM_SETREDRAW, (WPARAM)TRUE, 0);
+    RedrawWindow(s_tabhwnd, NULL, NULL,
+		    RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
+
+    if (tabadded && TabCtrl_GetCurSel(s_tabhwnd) != curtabidx)
+	TabCtrl_SetCurSel(s_tabhwnd, curtabidx);
+}
+
+/*
+ * Set the current tab to "nr".  First tab is 1.
+ */
+    void
+gui_mch_set_curtab(nr)
+    int		nr;
+{
+    if (s_tabhwnd == NULL)
+	return;
+
+    if (TabCtrl_GetCurSel(s_tabhwnd) != nr - 1)
+	TabCtrl_SetCurSel(s_tabhwnd, nr - 1);
+}
+
+#endif
+
+/*
+ * ":simalt" command.
+ */
+    void
+ex_simalt(exarg_T *eap)
+{
+    char_u *keys = eap->arg;
+
+    PostMessage(s_hwnd, WM_SYSCOMMAND, (WPARAM)SC_KEYMENU, (LPARAM)0);
+    while (*keys)
+    {
+	if (*keys == '~')
+	    *keys = ' ';	    /* for showing system menu */
+	PostMessage(s_hwnd, WM_CHAR, (WPARAM)*keys, (LPARAM)0);
+	keys++;
+    }
+}
+
+/*
+ * Create the find & replace dialogs.
+ * You can't have both at once: ":find" when replace is showing, destroys
+ * the replace dialog first, and the other way around.
+ */
+#ifdef MSWIN_FIND_REPLACE
+    static void
+initialise_findrep(char_u *initial_string)
+{
+    int		wword = FALSE;
+    int		mcase = !p_ic;
+    char_u	*entry_text;
+
+    /* Get the search string to use. */
+    entry_text = get_find_dialog_text(initial_string, &wword, &mcase);
+
+    s_findrep_struct.hwndOwner = s_hwnd;
+    s_findrep_struct.Flags = FR_DOWN;
+    if (mcase)
+	s_findrep_struct.Flags |= FR_MATCHCASE;
+    if (wword)
+	s_findrep_struct.Flags |= FR_WHOLEWORD;
+    if (entry_text != NULL && *entry_text != NUL)
+	vim_strncpy(s_findrep_struct.lpstrFindWhat, entry_text,
+					   s_findrep_struct.wFindWhatLen - 1);
+    vim_free(entry_text);
+}
+#endif
+
+    static void
+set_window_title(HWND hwnd, char *title)
+{
+#ifdef FEAT_MBYTE
+    if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
+    {
+	WCHAR	*wbuf;
+	int	n;
+
+	/* Convert the title from 'encoding' to UTF-16. */
+	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
+	if (wbuf != NULL)
+	{
+	    n = SetWindowTextW(hwnd, wbuf);
+	    vim_free(wbuf);
+	    if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+		return;
+	    /* Retry with non-wide function (for Windows 98). */
+	}
+    }
+#endif
+    (void)SetWindowText(hwnd, (LPCSTR)title);
+}
+
+    void
+gui_mch_find_dialog(exarg_T *eap)
+{
+#ifdef MSWIN_FIND_REPLACE
+    if (s_findrep_msg != 0)
+    {
+	if (IsWindow(s_findrep_hwnd) && !s_findrep_is_find)
+	    DestroyWindow(s_findrep_hwnd);
+
+	if (!IsWindow(s_findrep_hwnd))
+	{
+	    initialise_findrep(eap->arg);
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+	    /* If the OS is Windows NT, and 'encoding' differs from active
+	     * codepage: convert text and use wide function. */
+	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+	    {
+		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
+		s_findrep_hwnd = FindTextW(
+					(LPFINDREPLACEW) &s_findrep_struct_w);
+	    }
+	    else
+# endif
+		s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
+	}
+
+	set_window_title(s_findrep_hwnd,
+			       _("Find string (use '\\\\' to find  a '\\')"));
+	(void)SetFocus(s_findrep_hwnd);
+
+	s_findrep_is_find = TRUE;
+    }
+#endif
+}
+
+
+    void
+gui_mch_replace_dialog(exarg_T *eap)
+{
+#ifdef MSWIN_FIND_REPLACE
+    if (s_findrep_msg != 0)
+    {
+	if (IsWindow(s_findrep_hwnd) && s_findrep_is_find)
+	    DestroyWindow(s_findrep_hwnd);
+
+	if (!IsWindow(s_findrep_hwnd))
+	{
+	    initialise_findrep(eap->arg);
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
+		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+	    {
+		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
+		s_findrep_hwnd = ReplaceTextW(
+					(LPFINDREPLACEW) &s_findrep_struct_w);
+	    }
+	    else
+# endif
+		s_findrep_hwnd = ReplaceText(
+					   (LPFINDREPLACE) &s_findrep_struct);
+	}
+
+	set_window_title(s_findrep_hwnd,
+			    _("Find & Replace (use '\\\\' to find  a '\\')"));
+	(void)SetFocus(s_findrep_hwnd);
+
+	s_findrep_is_find = FALSE;
+    }
+#endif
+}
+
+
+/*
+ * Set visibility of the pointer.
+ */
+    void
+gui_mch_mousehide(int hide)
+{
+    if (hide != gui.pointer_hidden)
+    {
+	ShowCursor(!hide);
+	gui.pointer_hidden = hide;
+    }
+}
+
+#ifdef FEAT_MENU
+    static void
+gui_mch_show_popupmenu_at(vimmenu_T *menu, int x, int y)
+{
+    /* Unhide the mouse, we don't get move events here. */
+    gui_mch_mousehide(FALSE);
+
+    (void)TrackPopupMenu(
+	(HMENU)menu->submenu_id,
+	TPM_LEFTALIGN | TPM_LEFTBUTTON,
+	x, y,
+	(int)0,	    /*reserved param*/
+	s_hwnd,
+	NULL);
+    /*
+     * NOTE: The pop-up menu can eat the mouse up event.
+     * We deal with this in normal.c.
+     */
+}
+#endif
+
+/*
+ * Got a message when the system will go down.
+ */
+    static void
+_OnEndSession(void)
+{
+    getout_preserve_modified(1);
+}
+
+/*
+ * Get this message when the user clicks on the cross in the top right corner
+ * of a Windows95 window.
+ */
+/*ARGSUSED*/
+    static void
+_OnClose(
+    HWND hwnd)
+{
+    gui_shell_closed();
+}
+
+/*
+ * Get a message when the window is being destroyed.
+ */
+    static void
+_OnDestroy(
+    HWND hwnd)
+{
+#ifdef WIN16_3DLOOK
+    Ctl3dUnregister(s_hinst);
+#endif
+    if (!destroying)
+	_OnClose(hwnd);
+}
+
+    static void
+_OnPaint(
+    HWND hwnd)
+{
+    if (!IsMinimized(hwnd))
+    {
+	PAINTSTRUCT ps;
+
+	out_flush();	    /* make sure all output has been processed */
+	(void)BeginPaint(hwnd, &ps);
+#if defined(FEAT_DIRECTX)
+	if (IS_ENABLE_DIRECTX())
+	    DWriteContext_BeginDraw(s_dwc);
+#endif
+
+#ifdef FEAT_MBYTE
+	/* prevent multi-byte characters from misprinting on an invalid
+	 * rectangle */
+	if (has_mbyte)
+	{
+	    RECT rect;
+
+	    GetClientRect(hwnd, &rect);
+	    ps.rcPaint.left = rect.left;
+	    ps.rcPaint.right = rect.right;
+	}
+#endif
+
+	if (!IsRectEmpty(&ps.rcPaint))
+	{
+#if defined(FEAT_DIRECTX)
+	    if (IS_ENABLE_DIRECTX())
+		DWriteContext_BindDC(s_dwc, s_hdc, &ps.rcPaint);
+#endif
+	    gui_redraw(ps.rcPaint.left, ps.rcPaint.top,
+		    ps.rcPaint.right - ps.rcPaint.left + 1,
+		    ps.rcPaint.bottom - ps.rcPaint.top + 1);
+	}
+
+#if defined(FEAT_DIRECTX)
+	if (IS_ENABLE_DIRECTX())
+	    DWriteContext_EndDraw(s_dwc);
+#endif
+	EndPaint(hwnd, &ps);
+    }
+}
+
+/*ARGSUSED*/
+    static void
+_OnSize(
+    HWND hwnd,
+    UINT state,
+    int cx,
+    int cy)
+{
+    if (!IsMinimized(hwnd))
+    {
+	gui_resize_shell(cx, cy);
+
+#ifdef FEAT_MENU
+	/* Menu bar may wrap differently now */
+	gui_mswin_get_menu_height(TRUE);
+#endif
+    }
+}
+
+    static void
+_OnSetFocus(
+    HWND hwnd,
+    HWND hwndOldFocus)
+{
+    gui_focus_change(TRUE);
+    s_getting_focus = TRUE;
+    (void)MyWindowProc(hwnd, WM_SETFOCUS, (WPARAM)hwndOldFocus, 0);
+}
+
+    static void
+_OnKillFocus(
+    HWND hwnd,
+    HWND hwndNewFocus)
+{
+    gui_focus_change(FALSE);
+    s_getting_focus = FALSE;
+    (void)MyWindowProc(hwnd, WM_KILLFOCUS, (WPARAM)hwndNewFocus, 0);
+}
+
+/*
+ * Get a message when the user switches back to vim
+ */
+#ifdef WIN16
+    static BOOL
+#else
+    static LRESULT
+#endif
+_OnActivateApp(
+    HWND hwnd,
+    BOOL fActivate,
+#ifdef WIN16
+    HTASK dwThreadId
+#else
+    DWORD dwThreadId
+#endif
+	)
+{
+    /* we call gui_focus_change() in _OnSetFocus() */
+    /* gui_focus_change((int)fActivate); */
+    return MyWindowProc(hwnd, WM_ACTIVATEAPP, fActivate, (DWORD)dwThreadId);
+}
+
+#if defined(FEAT_WINDOWS) || defined(PROTO)
+    void
+gui_mch_destroy_scrollbar(scrollbar_T *sb)
+{
+    DestroyWindow(sb->id);
+}
+#endif
+
+/*
+ * Get current mouse coordinates in text window.
+ */
+    void
+gui_mch_getmouse(int *x, int *y)
+{
+    RECT rct;
+    POINT mp;
+
+    (void)GetWindowRect(s_textArea, &rct);
+    (void)GetCursorPos((LPPOINT)&mp);
+    *x = (int)(mp.x - rct.left);
+    *y = (int)(mp.y - rct.top);
+}
+
+/*
+ * Move mouse pointer to character at (x, y).
+ */
+    void
+gui_mch_setmouse(int x, int y)
+{
+    RECT rct;
+
+    (void)GetWindowRect(s_textArea, &rct);
+    (void)SetCursorPos(x + gui.border_offset + rct.left,
+		       y + gui.border_offset + rct.top);
+}
+
+    static void
+gui_mswin_get_valid_dimensions(
+    int w,
+    int h,
+    int *valid_w,
+    int *valid_h)
+{
+    int	    base_width, base_height;
+
+    base_width = gui_get_base_width()
+	+ (GetSystemMetrics(SM_CXFRAME) +
+	   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
+    base_height = gui_get_base_height()
+	+ (GetSystemMetrics(SM_CYFRAME) +
+	   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
+	+ GetSystemMetrics(SM_CYCAPTION)
+#ifdef FEAT_MENU
+	+ gui_mswin_get_menu_height(FALSE)
+#endif
+	;
+    *valid_w = base_width +
+		    ((w - base_width) / gui.char_width) * gui.char_width;
+    *valid_h = base_height +
+		    ((h - base_height) / gui.char_height) * gui.char_height;
+}
+
+    void
+gui_mch_flash(int msec)
+{
+    RECT    rc;
+
+    /*
+     * Note: InvertRect() excludes right and bottom of rectangle.
+     */
+    rc.left = 0;
+    rc.top = 0;
+    rc.right = gui.num_cols * gui.char_width;
+    rc.bottom = gui.num_rows * gui.char_height;
+    InvertRect(s_hdc, &rc);
+    gui_mch_flush();			/* make sure it's displayed */
+
+    ui_delay((long)msec, TRUE);	/* wait for a few msec */
+
+    InvertRect(s_hdc, &rc);
+}
+
+/*
+ * Return flags used for scrolling.
+ * The SW_INVALIDATE is required when part of the window is covered or
+ * off-screen. Refer to MS KB Q75236.
+ */
+    static int
+get_scroll_flags(void)
+{
+    HWND	hwnd;
+    RECT	rcVim, rcOther, rcDest;
+
+    GetWindowRect(s_hwnd, &rcVim);
+
+    /* Check if the window is partly above or below the screen.  We don't care
+     * about partly left or right of the screen, it is not relevant when
+     * scrolling up or down. */
+    if (rcVim.top < 0 || rcVim.bottom > GetSystemMetrics(SM_CYFULLSCREEN))
+	return SW_INVALIDATE;
+
+    /* Check if there is an window (partly) on top of us. */
+    for (hwnd = s_hwnd; (hwnd = GetWindow(hwnd, GW_HWNDPREV)) != (HWND)0; )
+	if (IsWindowVisible(hwnd))
+	{
+	    GetWindowRect(hwnd, &rcOther);
+	    if (IntersectRect(&rcDest, &rcVim, &rcOther))
+		return SW_INVALIDATE;
+	}
+    return 0;
+}
+
+/*
+ * On some Intel GPUs, the regions drawn just prior to ScrollWindowEx()
+ * may not be scrolled out properly.
+ * For gVim, when _OnScroll() is repeated, the character at the
+ * previous cursor position may be left drawn after scroll.
+ * The problem can be avoided by calling GetPixel() to get a pixel in
+ * the region before ScrollWindowEx().
+ */
+    static void
+intel_gpu_workaround(void)
+{
+    GetPixel(s_hdc, FILL_X(gui.col), FILL_Y(gui.row));
+}
+
+/*
+ * Delete the given number of lines from the given row, scrolling up any
+ * text further down within the scroll region.
+ */
+    void
+gui_mch_delete_lines(
+    int	    row,
+    int	    num_lines)
+{
+    RECT	rc;
+
+    intel_gpu_workaround();
+
+    rc.left = FILL_X(gui.scroll_region_left);
+    rc.right = FILL_X(gui.scroll_region_right + 1);
+    rc.top = FILL_Y(row);
+    rc.bottom = FILL_Y(gui.scroll_region_bot + 1);
+
+    ScrollWindowEx(s_textArea, 0, -num_lines * gui.char_height,
+				    &rc, &rc, NULL, NULL, get_scroll_flags());
+
+    UpdateWindow(s_textArea);
+    /* This seems to be required to avoid the cursor disappearing when
+     * scrolling such that the cursor ends up in the top-left character on
+     * the screen...   But why?  (Webb) */
+    /* It's probably fixed by disabling drawing the cursor while scrolling. */
+    /* gui.cursor_is_valid = FALSE; */
+
+    gui_clear_block(gui.scroll_region_bot - num_lines + 1,
+						       gui.scroll_region_left,
+	gui.scroll_region_bot, gui.scroll_region_right);
+}
+
+/*
+ * Insert the given number of lines before the given row, scrolling down any
+ * following text within the scroll region.
+ */
+    void
+gui_mch_insert_lines(
+    int		row,
+    int		num_lines)
+{
+    RECT	rc;
+
+    intel_gpu_workaround();
+
+    rc.left = FILL_X(gui.scroll_region_left);
+    rc.right = FILL_X(gui.scroll_region_right + 1);
+    rc.top = FILL_Y(row);
+    rc.bottom = FILL_Y(gui.scroll_region_bot + 1);
+    /* The SW_INVALIDATE is required when part of the window is covered or
+     * off-screen.  How do we avoid it when it's not needed? */
+    ScrollWindowEx(s_textArea, 0, num_lines * gui.char_height,
+				    &rc, &rc, NULL, NULL, get_scroll_flags());
+
+    UpdateWindow(s_textArea);
+
+    gui_clear_block(row, gui.scroll_region_left,
+				row + num_lines - 1, gui.scroll_region_right);
+}
+
+
+/*ARGSUSED*/
+    void
+gui_mch_exit(int rc)
+{
+#if defined(FEAT_DIRECTX)
+    DWriteContext_Close(s_dwc);
+    DWrite_Final();
+    s_dwc = NULL;
+#endif
+
+    ReleaseDC(s_textArea, s_hdc);
+    DeleteObject(s_brush);
+
+#ifdef FEAT_TEAROFF
+    /* Unload the tearoff bitmap */
+    (void)DeleteObject((HGDIOBJ)s_htearbitmap);
+#endif
+
+    /* Destroy our window (if we have one). */
+    if (s_hwnd != NULL)
+    {
+	destroying = TRUE;	/* ignore WM_DESTROY message now */
+	DestroyWindow(s_hwnd);
+    }
+
+#ifdef GLOBAL_IME
+    global_ime_end();
+#endif
+}
+
+    static char_u *
+logfont2name(LOGFONT lf)
+{
+    char	*p;
+    char	*res;
+    char	*charset_name;
+    char	*font_name = lf.lfFaceName;
+
+    charset_name = charset_id2name((int)lf.lfCharSet);
+#ifdef FEAT_MBYTE
+    /* Convert a font name from the current codepage to 'encoding'.
+     * TODO: Use Wide APIs (including LOGFONTW) instead of ANSI APIs. */
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	int	len;
+	acp_to_enc(lf.lfFaceName, (int)strlen(lf.lfFaceName),
+						(char_u **)&font_name, &len);
+    }
+#endif
+    res = alloc((unsigned)(strlen(font_name) + 20
+		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)));
+    if (res != NULL)
+    {
+	p = res;
+	/* make a normal font string out of the lf thing:*/
+	sprintf((char *)p, "%s:h%d", font_name, pixels_to_points(
+			 lf.lfHeight < 0 ? -lf.lfHeight : lf.lfHeight, TRUE));
+	while (*p)
+	{
+	    if (*p == ' ')
+		*p = '_';
+	    ++p;
+	}
+#ifndef MSWIN16_FASTTEXT
+	if (lf.lfItalic)
+	    STRCAT(p, ":i");
+	if (lf.lfWeight >= FW_BOLD)
+	    STRCAT(p, ":b");
+#endif
+	if (lf.lfUnderline)
+	    STRCAT(p, ":u");
+	if (lf.lfStrikeOut)
+	    STRCAT(p, ":s");
+	if (charset_name != NULL)
+	{
+	    STRCAT(p, ":c");
+	    STRCAT(p, charset_name);
+	}
+    }
+
+#ifdef FEAT_MBYTE
+    if (font_name != lf.lfFaceName)
+	vim_free(font_name);
+#endif
+    return res;
+}
+
+
+#ifdef FEAT_MBYTE_IME
+/*
+ * Set correct LOGFONT to IME.  Use 'guifontwide' if available, otherwise use
+ * 'guifont'
+ */
+    static void
+update_im_font(void)
+{
+    LOGFONT	lf_wide;
+
+    if (p_guifontwide != NULL && *p_guifontwide != NUL
+	    && gui.wide_font != NOFONT
+	    && GetObject((HFONT)gui.wide_font, sizeof(lf_wide), &lf_wide))
+	norm_logfont = lf_wide;
+    else
+	norm_logfont = sub_logfont;
+    im_set_font(&norm_logfont);
+}
+#endif
+
+#ifdef FEAT_MBYTE
+/*
+ * Handler of gui.wide_font (p_guifontwide) changed notification.
+ */
+    void
+gui_mch_wide_font_changed()
+{
+# ifndef MSWIN16_FASTTEXT
+    LOGFONT lf;
+# endif
+
+# ifdef FEAT_MBYTE_IME
+    update_im_font();
+# endif
+
+# ifndef MSWIN16_FASTTEXT
+    gui_mch_free_font(gui.wide_ital_font);
+    gui.wide_ital_font = NOFONT;
+    gui_mch_free_font(gui.wide_bold_font);
+    gui.wide_bold_font = NOFONT;
+    gui_mch_free_font(gui.wide_boldital_font);
+    gui.wide_boldital_font = NOFONT;
+
+    if (gui.wide_font
+	&& GetObject((HFONT)gui.wide_font, sizeof(lf), &lf))
+    {
+	if (!lf.lfItalic)
+	{
+	    lf.lfItalic = TRUE;
+	    gui.wide_ital_font = get_font_handle(&lf);
+	    lf.lfItalic = FALSE;
+	}
+	if (lf.lfWeight < FW_BOLD)
+	{
+	    lf.lfWeight = FW_BOLD;
+	    gui.wide_bold_font = get_font_handle(&lf);
+	    if (!lf.lfItalic)
+	    {
+		lf.lfItalic = TRUE;
+		gui.wide_boldital_font = get_font_handle(&lf);
+	    }
+	}
+    }
+# endif
+}
+#endif
+
+/*
+ * Initialise vim to use the font with the given name.
+ * Return FAIL if the font could not be loaded, OK otherwise.
+ */
+/*ARGSUSED*/
+    int
+gui_mch_init_font(char_u *font_name, int fontset)
+{
+    LOGFONT	lf;
+    GuiFont	font = NOFONT;
+    char_u	*p;
+
+    /* Load the font */
+    if (get_logfont(&lf, font_name, NULL, TRUE) == OK)
+	font = get_font_handle(&lf);
+    if (font == NOFONT)
+	return FAIL;
+
+    if (font_name == NULL)
+	font_name = lf.lfFaceName;
+#if defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)
+    norm_logfont = lf;
+    sub_logfont = lf;
+#endif
+#ifdef FEAT_MBYTE_IME
+    update_im_font();
+#endif
+    gui_mch_free_font(gui.norm_font);
+    gui.norm_font = font;
+    current_font_height = lf.lfHeight;
+    GetFontSize(font);
+
+    p = logfont2name(lf);
+    if (p != NULL)
+    {
+	hl_set_font_name(p);
+
+	/* When setting 'guifont' to "*" replace it with the actual font name.
+	 * */
+	if (STRCMP(font_name, "*") == 0 && STRCMP(p_guifont, "*") == 0)
+	{
+	    vim_free(p_guifont);
+	    p_guifont = p;
+	}
+	else
+	    vim_free(p);
+    }
+
+#ifndef MSWIN16_FASTTEXT
+    gui_mch_free_font(gui.ital_font);
+    gui.ital_font = NOFONT;
+    gui_mch_free_font(gui.bold_font);
+    gui.bold_font = NOFONT;
+    gui_mch_free_font(gui.boldital_font);
+    gui.boldital_font = NOFONT;
+
+    if (!lf.lfItalic)
+    {
+	lf.lfItalic = TRUE;
+	gui.ital_font = get_font_handle(&lf);
+	lf.lfItalic = FALSE;
+    }
+    if (lf.lfWeight < FW_BOLD)
+    {
+	lf.lfWeight = FW_BOLD;
+	gui.bold_font = get_font_handle(&lf);
+	if (!lf.lfItalic)
+	{
+	    lf.lfItalic = TRUE;
+	    gui.boldital_font = get_font_handle(&lf);
+	}
+    }
+#endif
+
+    return OK;
+}
+
+#ifndef WPF_RESTORETOMAXIMIZED
+# define WPF_RESTORETOMAXIMIZED 2   /* just in case someone doesn't have it */
+#endif
+
+/*
+ * Return TRUE if the GUI window is maximized, filling the whole screen.
+ */
+    int
+gui_mch_maximized()
+{
+    WINDOWPLACEMENT wp;
+
+    wp.length = sizeof(WINDOWPLACEMENT);
+    if (GetWindowPlacement(s_hwnd, &wp))
+	return wp.showCmd == SW_SHOWMAXIMIZED
+	    || (wp.showCmd == SW_SHOWMINIMIZED
+		    && wp.flags == WPF_RESTORETOMAXIMIZED);
+
+    return 0;
+}
+
+/*
+ * Called when the font changed while the window is maximized.  Compute the
+ * new Rows and Columns.  This is like resizing the window.
+ */
+    void
+gui_mch_newfont()
+{
+    RECT	rect;
+
+    GetWindowRect(s_hwnd, &rect);
+    if (win_socket_id == 0)
+    {
+	gui_resize_shell(rect.right - rect.left
+	    - (GetSystemMetrics(SM_CXFRAME) +
+	       GetSystemMetrics(SM_CXPADDEDBORDER)) * 2,
+	    rect.bottom - rect.top
+	    - (GetSystemMetrics(SM_CYFRAME) +
+	       GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
+	    - GetSystemMetrics(SM_CYCAPTION)
+#ifdef FEAT_MENU
+	    - gui_mswin_get_menu_height(FALSE)
+#endif
+	);
+    }
+    else
+    {
+	/* Inside another window, don't use the frame and border. */
+	gui_resize_shell(rect.right - rect.left,
+	    rect.bottom - rect.top
+#ifdef FEAT_MENU
+			- gui_mswin_get_menu_height(FALSE)
+#endif
+	);
+    }
+}
+
+/*
+ * Set the window title
+ */
+/*ARGSUSED*/
+    void
+gui_mch_settitle(
+    char_u  *title,
+    char_u  *icon)
+{
+    set_window_title(s_hwnd, (title == NULL ? "VIM" : (char *)title));
+}
+
+#ifdef FEAT_MOUSESHAPE
+/* Table for shape IDCs.  Keep in sync with the mshape_names[] table in
+ * misc2.c! */
+static LPCSTR mshape_idcs[] =
+{
+    IDC_ARROW,			/* arrow */
+    MAKEINTRESOURCE(0),		/* blank */
+    IDC_IBEAM,			/* beam */
+    IDC_SIZENS,			/* updown */
+    IDC_SIZENS,			/* udsizing */
+    IDC_SIZEWE,			/* leftright */
+    IDC_SIZEWE,			/* lrsizing */
+    IDC_WAIT,			/* busy */
+#ifdef WIN3264
+    IDC_NO,			/* no */
+#else
+    IDC_ICON,			/* no */
+#endif
+    IDC_ARROW,			/* crosshair */
+    IDC_ARROW,			/* hand1 */
+    IDC_ARROW,			/* hand2 */
+    IDC_ARROW,			/* pencil */
+    IDC_ARROW,			/* question */
+    IDC_ARROW,			/* right-arrow */
+    IDC_UPARROW,		/* up-arrow */
+    IDC_ARROW			/* last one */
+};
+
+    void
+mch_set_mouse_shape(int shape)
+{
+    LPCSTR idc;
+
+    if (shape == MSHAPE_HIDE)
+	ShowCursor(FALSE);
+    else
+    {
+	if (shape >= MSHAPE_NUMBERED)
+	    idc = IDC_ARROW;
+	else
+	    idc = mshape_idcs[shape];
+#ifdef SetClassLongPtr
+	SetClassLongPtr(s_textArea, GCLP_HCURSOR, (__int3264)(LONG_PTR)LoadCursor(NULL, idc));
+#else
+# ifdef WIN32
+	SetClassLong(s_textArea, GCL_HCURSOR, (long_u)LoadCursor(NULL, idc));
+# else /* Win16 */
+	SetClassWord(s_textArea, GCW_HCURSOR, (WORD)LoadCursor(NULL, idc));
+# endif
+#endif
+	if (!p_mh)
+	{
+	    POINT mp;
+
+	    /* Set the position to make it redrawn with the new shape. */
+	    (void)GetCursorPos((LPPOINT)&mp);
+	    (void)SetCursorPos(mp.x, mp.y);
+	    ShowCursor(TRUE);
+	}
+    }
+}
+#endif
+
+#ifdef FEAT_BROWSE
+/*
+ * The file browser exists in two versions: with "W" uses wide characters,
+ * without "W" the current codepage.  When FEAT_MBYTE is defined and on
+ * Windows NT/2000/XP the "W" functions are used.
+ */
+
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+/*
+ * Wide version of convert_filter().
+ */
+    static WCHAR *
+convert_filterW(char_u *s)
+{
+    char_u *tmp;
+    int len;
+    WCHAR *res;
+
+    tmp = convert_filter(s);
+    if (tmp == NULL)
+	return NULL;
+    len = (int)STRLEN(s) + 3;
+    res = enc_to_utf16(tmp, &len);
+    vim_free(tmp);
+    return res;
+}
+
+/*
+ * Wide version of gui_mch_browse().  Keep in sync!
+ */
+    static char_u *
+gui_mch_browseW(
+	int saving,
+	char_u *title,
+	char_u *dflt,
+	char_u *ext,
+	char_u *initdir,
+	char_u *filter)
+{
+    /* We always use the wide function.  This means enc_to_utf16() must work,
+     * otherwise it fails miserably! */
+    OPENFILENAMEW	fileStruct;
+    WCHAR		fileBuf[MAXPATHL];
+    WCHAR		*wp;
+    int			i;
+    WCHAR		*titlep = NULL;
+    WCHAR		*extp = NULL;
+    WCHAR		*initdirp = NULL;
+    WCHAR		*filterp;
+    char_u		*p;
+
+    if (dflt == NULL)
+	fileBuf[0] = NUL;
+    else
+    {
+	wp = enc_to_utf16(dflt, NULL);
+	if (wp == NULL)
+	    fileBuf[0] = NUL;
+	else
+	{
+	    for (i = 0; wp[i] != NUL && i < MAXPATHL - 1; ++i)
+		fileBuf[i] = wp[i];
+	    fileBuf[i] = NUL;
+	    vim_free(wp);
+	}
+    }
+
+    /* Convert the filter to Windows format. */
+    filterp = convert_filterW(filter);
+
+    vim_memset(&fileStruct, 0, sizeof(OPENFILENAMEW));
+#ifdef OPENFILENAME_SIZE_VERSION_400
+    /* be compatible with Windows NT 4.0 */
+    /* TODO: what to use for OPENFILENAMEW??? */
+    fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+#else
+    fileStruct.lStructSize = sizeof(fileStruct);
+#endif
+
+    if (title != NULL)
+	titlep = enc_to_utf16(title, NULL);
+    fileStruct.lpstrTitle = titlep;
+
+    if (ext != NULL)
+	extp = enc_to_utf16(ext, NULL);
+    fileStruct.lpstrDefExt = extp;
+
+    fileStruct.lpstrFile = fileBuf;
+    fileStruct.nMaxFile = MAXPATHL;
+    fileStruct.lpstrFilter = filterp;
+    fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
+    /* has an initial dir been specified? */
+    if (initdir != NULL && *initdir != NUL)
+    {
+	/* Must have backslashes here, no matter what 'shellslash' says */
+	initdirp = enc_to_utf16(initdir, NULL);
+	if (initdirp != NULL)
+	{
+	    for (wp = initdirp; *wp != NUL; ++wp)
+		if (*wp == '/')
+		    *wp = '\\';
+	}
+	fileStruct.lpstrInitialDir = initdirp;
+    }
+
+    /*
+     * TODO: Allow selection of multiple files.  Needs another arg to this
+     * function to ask for it, and need to use OFN_ALLOWMULTISELECT below.
+     * Also, should we use OFN_FILEMUSTEXIST when opening?  Vim can edit on
+     * files that don't exist yet, so I haven't put it in.  What about
+     * OFN_PATHMUSTEXIST?
+     * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
+     */
+    fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
+#ifdef FEAT_SHORTCUT
+    if (curbuf->b_p_bin)
+	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
+#endif
+    if (saving)
+    {
+	if (!GetSaveFileNameW(&fileStruct))
+	    return NULL;
+    }
+    else
+    {
+	if (!GetOpenFileNameW(&fileStruct))
+	    return NULL;
+    }
+
+    vim_free(filterp);
+    vim_free(initdirp);
+    vim_free(titlep);
+    vim_free(extp);
+
+    /* Convert from UCS2 to 'encoding'. */
+    p = utf16_to_enc(fileBuf, NULL);
+    if (p != NULL)
+	/* when out of memory we get garbage for non-ASCII chars */
+	STRCPY(fileBuf, p);
+    vim_free(p);
+
+    /* Give focus back to main window (when using MDI). */
+    SetFocus(s_hwnd);
+
+    /* Shorten the file name if possible */
+    return vim_strsave(shorten_fname1((char_u *)fileBuf));
+}
+# endif /* FEAT_MBYTE */
+
+
+/*
+ * Convert the string s to the proper format for a filter string by replacing
+ * the \t and \n delimiters with \0.
+ * Returns the converted string in allocated memory.
+ *
+ * Keep in sync with convert_filterW() above!
+ */
+    static char_u *
+convert_filter(char_u *s)
+{
+    char_u	*res;
+    unsigned	s_len = (unsigned)STRLEN(s);
+    unsigned	i;
+
+    res = alloc(s_len + 3);
+    if (res != NULL)
+    {
+	for (i = 0; i < s_len; ++i)
+	    if (s[i] == '\t' || s[i] == '\n')
+		res[i] = '\0';
+	    else
+		res[i] = s[i];
+	res[s_len] = NUL;
+	/* Add two extra NULs to make sure it's properly terminated. */
+	res[s_len + 1] = NUL;
+	res[s_len + 2] = NUL;
+    }
+    return res;
+}
+
+/*
+ * Select a directory.
+ */
+    char_u *
+gui_mch_browsedir(char_u *title, char_u *initdir)
+{
+    /* We fake this: Use a filter that doesn't select anything and a default
+     * file name that won't be used. */
+    return gui_mch_browse(0, title, (char_u *)_("Not Used"), NULL,
+			      initdir, (char_u *)_("Directory\t*.nothing\n"));
+}
+
+/*
+ * Pop open a file browser and return the file selected, in allocated memory,
+ * or NULL if Cancel is hit.
+ *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
+ *  title   - Title message for the file browser dialog.
+ *  dflt    - Default name of file.
+ *  ext     - Default extension to be added to files without extensions.
+ *  initdir - directory in which to open the browser (NULL = current dir)
+ *  filter  - Filter for matched files to choose from.
+ *
+ * Keep in sync with gui_mch_browseW() above!
+ */
+    char_u *
+gui_mch_browse(
+	int saving,
+	char_u *title,
+	char_u *dflt,
+	char_u *ext,
+	char_u *initdir,
+	char_u *filter)
+{
+    OPENFILENAME	fileStruct;
+    char_u		fileBuf[MAXPATHL];
+    char_u		*initdirp = NULL;
+    char_u		*filterp;
+    char_u		*p;
+
+# if defined(FEAT_MBYTE) && defined(WIN3264)
+    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
+	return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
+# endif
+
+    if (dflt == NULL)
+	fileBuf[0] = NUL;
+    else
+	vim_strncpy(fileBuf, dflt, MAXPATHL - 1);
+
+    /* Convert the filter to Windows format. */
+    filterp = convert_filter(filter);
+
+    vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
+#ifdef OPENFILENAME_SIZE_VERSION_400
+    /* be compatible with Windows NT 4.0 */
+    fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+#else
+    fileStruct.lStructSize = sizeof(fileStruct);
+#endif
+
+    fileStruct.lpstrTitle = title;
+    fileStruct.lpstrDefExt = ext;
+
+    fileStruct.lpstrFile = fileBuf;
+    fileStruct.nMaxFile = MAXPATHL;
+    fileStruct.lpstrFilter = filterp;
+    fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
+    /* has an initial dir been specified? */
+    if (initdir != NULL && *initdir != NUL)
+    {
+	/* Must have backslashes here, no matter what 'shellslash' says */
+	initdirp = vim_strsave(initdir);
+	if (initdirp != NULL)
+	    for (p = initdirp; *p != NUL; ++p)
+		if (*p == '/')
+		    *p = '\\';
+	fileStruct.lpstrInitialDir = initdirp;
+    }
+
+    /*
+     * TODO: Allow selection of multiple files.  Needs another arg to this
+     * function to ask for it, and need to use OFN_ALLOWMULTISELECT below.
+     * Also, should we use OFN_FILEMUSTEXIST when opening?  Vim can edit on
+     * files that don't exist yet, so I haven't put it in.  What about
+     * OFN_PATHMUSTEXIST?
+     * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
+     */
+    fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
+#ifdef FEAT_SHORTCUT
+    if (curbuf->b_p_bin)
+	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
+#endif
+    if (saving)
+    {
+	if (!GetSaveFileName(&fileStruct))
+	    return NULL;
+    }
+    else
+    {
+	if (!GetOpenFileName(&fileStruct))
+	    return NULL;
+    }
+
+    vim_free(filterp);
+    vim_free(initdirp);
+
+    /* Give focus back to main window (when using MDI). */
+    SetFocus(s_hwnd);
+
+    /* Shorten the file name if possible */
+    return vim_strsave(shorten_fname1((char_u *)fileBuf));
+}
+#endif /* FEAT_BROWSE */
+
+/*ARGSUSED*/
+    static void
+_OnDropFiles(
+    HWND hwnd,
+    HDROP hDrop)
+{
+#ifdef FEAT_WINDOWS
+#ifdef WIN3264
+# define BUFPATHLEN _MAX_PATH
+# define DRAGQVAL 0xFFFFFFFF
+#else
+# define BUFPATHLEN MAXPATHL
+# define DRAGQVAL 0xFFFF
+#endif
+#ifdef FEAT_MBYTE
+    WCHAR   wszFile[BUFPATHLEN];
+#endif
+    char    szFile[BUFPATHLEN];
+    UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
+    UINT    i;
+    char_u  **fnames;
+    POINT   pt;
+    int_u   modifiers = 0;
+
+    /* TRACE("_OnDropFiles: %d files dropped\n", cFiles); */
+
+    /* Obtain dropped position */
+    DragQueryPoint(hDrop, &pt);
+    MapWindowPoints(s_hwnd, s_textArea, &pt, 1);
+
+    reset_VIsual();
+
+    fnames = (char_u **)alloc(cFiles * sizeof(char_u *));
+
+    if (fnames != NULL)
+	for (i = 0; i < cFiles; ++i)
+	{
+#ifdef FEAT_MBYTE
+	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
+		fnames[i] = utf16_to_enc(wszFile, NULL);
+	    else
+#endif
+	    {
+		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
+		fnames[i] = vim_strsave(szFile);
+	    }
+	}
+
+    DragFinish(hDrop);
+
+    if (fnames != NULL)
+    {
+	if ((GetKeyState(VK_SHIFT) & 0x8000) != 0)
+	    modifiers |= MOUSE_SHIFT;
+	if ((GetKeyState(VK_CONTROL) & 0x8000) != 0)
+	    modifiers |= MOUSE_CTRL;
+	if ((GetKeyState(VK_MENU) & 0x8000) != 0)
+	    modifiers |= MOUSE_ALT;
+
+	gui_handle_drop(pt.x, pt.y, modifiers, fnames, cFiles);
+
+	s_need_activate = TRUE;
+    }
+#endif
+}
+
+/*ARGSUSED*/
+    static int
+_OnScroll(
+    HWND hwnd,
+    HWND hwndCtl,
+    UINT code,
+    int pos)
+{
+    static UINT	prev_code = 0;   /* code of previous call */
+    scrollbar_T *sb, *sb_info;
+    long	val;
+    int		dragging = FALSE;
+    int		dont_scroll_save = dont_scroll;
+#ifndef WIN3264
+    int		nPos;
+#else
+    SCROLLINFO	si;
+
+    si.cbSize = sizeof(si);
+    si.fMask = SIF_POS;
+#endif
+
+    sb = gui_mswin_find_scrollbar(hwndCtl);
+    if (sb == NULL)
+	return 0;
+
+    if (sb->wp != NULL)		/* Left or right scrollbar */
+    {
+	/*
+	 * Careful: need to get scrollbar info out of first (left) scrollbar
+	 * for window, but keep real scrollbar too because we must pass it to
+	 * gui_drag_scrollbar().
+	 */
+	sb_info = &sb->wp->w_scrollbars[0];
+    }
+    else	    /* Bottom scrollbar */
+	sb_info = sb;
+    val = sb_info->value;
+
+    switch (code)
+    {
+	case SB_THUMBTRACK:
+	    val = pos;
+	    dragging = TRUE;
+	    if (sb->scroll_shift > 0)
+		val <<= sb->scroll_shift;
+	    break;
+	case SB_LINEDOWN:
+	    val++;
+	    break;
+	case SB_LINEUP:
+	    val--;
+	    break;
+	case SB_PAGEDOWN:
+	    val += (sb_info->size > 2 ? sb_info->size - 2 : 1);
+	    break;
+	case SB_PAGEUP:
+	    val -= (sb_info->size > 2 ? sb_info->size - 2 : 1);
+	    break;
+	case SB_TOP:
+	    val = 0;
+	    break;
+	case SB_BOTTOM:
+	    val = sb_info->max;
+	    break;
+	case SB_ENDSCROLL:
+	    if (prev_code == SB_THUMBTRACK)
+	    {
+		/*
+		 * "pos" only gives us 16-bit data.  In case of large file,
+		 * use GetScrollPos() which returns 32-bit.  Unfortunately it
+		 * is not valid while the scrollbar is being dragged.
+		 */
+		val = GetScrollPos(hwndCtl, SB_CTL);
+		if (sb->scroll_shift > 0)
+		    val <<= sb->scroll_shift;
+	    }
+	    break;
+
+	default:
+	    /* TRACE("Unknown scrollbar event %d\n", code); */
+	    return 0;
+    }
+    prev_code = code;
+
+#ifdef WIN3264
+    si.nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
+    SetScrollInfo(hwndCtl, SB_CTL, &si, TRUE);
+#else
+    nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
+    SetScrollPos(hwndCtl, SB_CTL, nPos, TRUE);
+#endif
+
+    /*
+     * When moving a vertical scrollbar, move the other vertical scrollbar too.
+     */
+    if (sb->wp != NULL)
+    {
+	scrollbar_T *sba = sb->wp->w_scrollbars;
+	HWND    id = sba[ (sb == sba + SBAR_LEFT) ? SBAR_RIGHT : SBAR_LEFT].id;
+
+#ifdef WIN3264
+	SetScrollInfo(id, SB_CTL, &si, TRUE);
+#else
+	SetScrollPos(id, SB_CTL, nPos, TRUE);
+#endif
+    }
+
+    /* Don't let us be interrupted here by another message. */
+    s_busy_processing = TRUE;
+
+    /* When "allow_scrollbar" is FALSE still need to remember the new
+     * position, but don't actually scroll by setting "dont_scroll". */
+    dont_scroll = !allow_scrollbar;
+
+    gui_drag_scrollbar(sb, val, dragging);
+
+    s_busy_processing = FALSE;
+    dont_scroll = dont_scroll_save;
+
+    return 0;
+}
+
+
+/*
+ * Get command line arguments.
+ * Use "prog" as the name of the program and "cmdline" as the arguments.
+ * Copy the arguments to allocated memory.
+ * Return the number of arguments (including program name).
+ * Return pointers to the arguments in "argvp".  Memory is allocated with
+ * malloc(), use free() instead of vim_free().
+ * Return pointer to buffer in "tofree".
+ * Returns zero when out of memory.
+ */
+/*ARGSUSED*/
+    int
+get_cmd_args(char *prog, char *cmdline, char ***argvp, char **tofree)
+{
+    int		i;
+    char	*p;
+    char	*progp;
+    char	*pnew = NULL;
+    char	*newcmdline;
+    int		inquote;
+    int		argc;
+    char	**argv = NULL;
+    int		round;
+
+    *tofree = NULL;
+
+#ifdef FEAT_MBYTE
+    /* Try using the Unicode version first, it takes care of conversion when
+     * 'encoding' is changed. */
+    argc = get_cmd_argsW(&argv);
+    if (argc != 0)
+	goto done;
+#endif
+
+    /* Handle the program name.  Remove the ".exe" extension, and find the 1st
+     * non-space. */
+    p = strrchr(prog, '.');
+    if (p != NULL)
+	*p = NUL;
+    for (progp = prog; *progp == ' '; ++progp)
+	;
+
+    /* The command line is copied to allocated memory, so that we can change
+     * it.  Add the size of the string, the separating NUL and a terminating
+     * NUL. */
+    newcmdline = malloc(STRLEN(cmdline) + STRLEN(progp) + 2);
+    if (newcmdline == NULL)
+	return 0;
+
+    /*
+     * First round: count the number of arguments ("pnew" == NULL).
+     * Second round: produce the arguments.
+     */
+    for (round = 1; round <= 2; ++round)
+    {
+	/* First argument is the program name. */
+	if (pnew != NULL)
+	{
+	    argv[0] = pnew;
+	    strcpy(pnew, progp);
+	    pnew += strlen(pnew);
+	    *pnew++ = NUL;
+	}
+
+	/*
+	 * Isolate each argument and put it in argv[].
+	 */
+	p = cmdline;
+	argc = 1;
+	while (*p != NUL)
+	{
+	    inquote = FALSE;
+	    if (pnew != NULL)
+		argv[argc] = pnew;
+	    ++argc;
+	    while (*p != NUL && (inquote || (*p != ' ' && *p != '\t')))
+	    {
+		/* Backslashes are only special when followed by a double
+		 * quote. */
+		i = (int)strspn(p, "\\");
+		if (p[i] == '"')
+		{
+		    /* Halve the number of backslashes. */
+		    if (i > 1 && pnew != NULL)
+		    {
+			vim_memset(pnew, '\\', i / 2);
+			pnew += i / 2;
+		    }
+
+		    /* Even nr of backslashes toggles quoting, uneven copies
+		     * the double quote. */
+		    if ((i & 1) == 0)
+			inquote = !inquote;
+		    else if (pnew != NULL)
+			*pnew++ = '"';
+		    p += i + 1;
+		}
+		else if (i > 0)
+		{
+		    /* Copy span of backslashes unmodified. */
+		    if (pnew != NULL)
+		    {
+			vim_memset(pnew, '\\', i);
+			pnew += i;
+		    }
+		    p += i;
+		}
+		else
+		{
+		    if (pnew != NULL)
+			*pnew++ = *p;
+#ifdef FEAT_MBYTE
+		    /* Can't use mb_* functions, because 'encoding' is not
+		     * initialized yet here. */
+		    if (IsDBCSLeadByte(*p))
+		    {
+			++p;
+			if (pnew != NULL)
+			    *pnew++ = *p;
+		    }
+#endif
+		    ++p;
+		}
+	    }
+
+	    if (pnew != NULL)
+		*pnew++ = NUL;
+	    while (*p == ' ' || *p == '\t')
+		++p;		    /* advance until a non-space */
+	}
+
+	if (round == 1)
+	{
+	    argv = (char **)malloc((argc + 1) * sizeof(char *));
+	    if (argv == NULL )
+	    {
+		free(newcmdline);
+		return 0;		   /* malloc error */
+	    }
+	    pnew = newcmdline;
+	    *tofree = newcmdline;
+	}
+    }
+
+#ifdef FEAT_MBYTE
+done:
+#endif
+    argv[argc] = NULL;		/* NULL-terminated list */
+    *argvp = argv;
+    return argc;
+}
diff -urN vim-src/src/guiw16rc.h vim-qt-src/src/guiw16rc.h
--- vim-src/src/guiw16rc.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/guiw16rc.h	2016-06-08 06:39:27.726315188 +0200
@@ -0,0 +1,17 @@
+
+#define	IDR_VIM 150
+
+#define IDR_VIM_ERROR	151
+#define IDR_VIM_ALERT	152
+#define IDR_VIM_INFO	153
+#define IDR_VIM_QUESTION 154
+
+#define IDR_ICOBUDDYBASE			200
+
+#define IDR_ICOBUDDY_DEF1			(IDR_ICOBUDDYBASE + 3)
+#define IDR_ICOBUDDY_DEF2			(IDR_ICOBUDDYBASE + 0)
+#define IDR_ICOBUDDY_DEF3			(IDR_ICOBUDDYBASE + 1)
+#define IDR_ICOBUDDY_DEF4			(IDR_ICOBUDDYBASE + 2)
+
+#define IDR_ICOBUDDY_GRIN			(IDR_ICOBUDDYBASE + 4)
+#define IDR_ICOBUDDY_ALARM			(IDR_ICOBUDDYBASE + 5)
diff -urN vim-src/src/if_sniff.c vim-qt-src/src/if_sniff.c
--- vim-src/src/if_sniff.c	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/if_sniff.c	2016-06-08 06:39:27.730315218 +0200
@@ -0,0 +1,1220 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * if_sniff.c Interface between Vim and SNiFF+
+ *
+ * See README.txt for an overview of the Vim source code.
+ */
+
+#include "vim.h"
+
+#ifdef WIN32
+# include <stdio.h>
+# include <process.h>
+# include <string.h>
+# include <assert.h>
+#else
+# ifdef FEAT_GUI_X11
+#  include "gui_x11.pro"
+# endif
+# include "os_unixx.h"
+#endif
+
+static int sniffemacs_pid;
+
+int fd_from_sniff;
+int sniff_connected = 0;
+int sniff_request_waiting = 0;
+int want_sniff_request = 0;
+
+#define MAX_REQUEST_LEN 512
+
+#define NEED_SYMBOL	2
+#define EMPTY_SYMBOL	4
+#define NEED_FILE	8
+#define SILENT		16
+#define DISCONNECT	32
+#define CONNECT		64
+
+#define RQ_NONE		0
+#define RQ_SIMPLE	1
+#define RQ_CONTEXT	NEED_FILE + NEED_SYMBOL
+#define RQ_SCONTEXT	NEED_FILE + NEED_SYMBOL + EMPTY_SYMBOL
+#define RQ_NOSYMBOL	NEED_FILE
+#define RQ_SILENT	RQ_NOSYMBOL + SILENT
+#define RQ_CONNECT	RQ_NONE + CONNECT
+#define RQ_DISCONNECT	RQ_SIMPLE + DISCONNECT
+
+struct sn_cmd
+{
+    char *cmd_name;
+    char cmd_code;
+    char *cmd_msg;
+    int  cmd_type;
+};
+
+struct sn_cmd_list
+{
+    struct sn_cmd* sniff_cmd;
+    struct sn_cmd_list* next_cmd;
+};
+
+static struct sn_cmd sniff_cmds[] =
+{
+    { "toggle",		'e', N_("Toggle implementation/definition"),RQ_SCONTEXT },
+    { "superclass",	's', N_("Show base class of"),		RQ_CONTEXT },
+    { "overridden",	'm', N_("Show overridden member function"),RQ_SCONTEXT },
+    { "retrieve-file",	'r', N_("Retrieve from file"),		RQ_CONTEXT },
+    { "retrieve-project",'p', N_("Retrieve from project"),	RQ_CONTEXT },
+    { "retrieve-all-projects",
+			'P', N_("Retrieve from all projects"),	RQ_CONTEXT },
+    { "retrieve-next",	'R', N_("Retrieve"),	RQ_CONTEXT },
+    { "goto-symbol",	'g', N_("Show source of"),		RQ_CONTEXT },
+    { "find-symbol",	'f', N_("Find symbol"),			RQ_CONTEXT },
+    { "browse-class",	'w', N_("Browse class"),		RQ_CONTEXT },
+    { "hierarchy",	't', N_("Show class in hierarchy"),	RQ_CONTEXT },
+    { "restr-hier",	'T', N_("Show class in restricted hierarchy"),RQ_CONTEXT },
+    { "xref-to",	'x', N_("Xref refers to"),		RQ_CONTEXT },
+    { "xref-by",	'X', N_("Xref referred by"),		RQ_CONTEXT },
+    { "xref-has",	'c', N_("Xref has a"),			RQ_CONTEXT },
+    { "xref-used-by",	'C', N_("Xref used by"),		RQ_CONTEXT },
+    { "show-docu",	'd', N_("Show docu of"),		RQ_CONTEXT },
+    { "gen-docu",	'D', N_("Generate docu for"),		RQ_CONTEXT },
+    { "connect",	'y', NULL,				RQ_CONNECT },
+    { "disconnect",	'q', NULL,				RQ_DISCONNECT },
+    { "font-info",	'z', NULL,				RQ_SILENT },
+    { "update",		'u', NULL,				RQ_SILENT },
+    { NULL,		'\0', NULL, 0}
+};
+
+
+static char *SniffEmacs[2] = {"sniffemacs", (char *)NULL};  /* Yes, Emacs! */
+static int fd_to_sniff;
+static int sniff_will_disconnect = 0;
+static char msg_sniff_disconnect[] = N_("Cannot connect to SNiFF+. Check environment (sniffemacs must be found in $PATH).\n");
+static char sniff_rq_sep[] = " ";
+static struct sn_cmd_list *sniff_cmd_ext = NULL;
+
+/* Initializing vim commands
+ * executed each time vim connects to Sniff
+ */
+static char *init_cmds[]= {
+    "augroup sniff",
+    "autocmd BufWritePost * sniff update",
+    "autocmd BufReadPost * sniff font-info",
+    "autocmd VimLeave * sniff disconnect",
+    "augroup END",
+
+    "let g:sniff_connected = 1",
+
+    "if ! exists('g:sniff_mappings_sourced')|"
+	"if ! exists('g:sniff_mappings')|"
+	    "if exists('$SNIFF_DIR4')|"
+		"let g:sniff_mappings='$SNIFF_DIR4/config/integrations/vim/sniff.vim'|"
+	    "else|"
+		"let g:sniff_mappings='$SNIFF_DIR/config/sniff.vim'|"
+	    "endif|"
+	"endif|"
+	"let g:sniff_mappings=expand(g:sniff_mappings)|"
+	"if filereadable(g:sniff_mappings)|"
+	    "execute 'source' g:sniff_mappings|"
+	    "let g:sniff_mappings_sourced=1|"
+	"endif|"
+    "endif",
+
+    NULL
+};
+
+/*-------- Function Prototypes ----------------------------------*/
+
+static int ConnectToSniffEmacs __ARGS((void));
+static void sniff_connect __ARGS((void));
+static void HandleSniffRequest __ARGS((char* buffer));
+static int get_request __ARGS((int fd, char *buf, int maxlen));
+static void WriteToSniff __ARGS((char *str));
+static void SendRequest __ARGS((struct sn_cmd *command, char* symbol));
+static void vi_msg __ARGS((char *));
+static void vi_error_msg __ARGS((char *));
+static char *vi_symbol_under_cursor __ARGS((void));
+static void vi_open_file __ARGS((char *));
+static char *vi_buffer_name __ARGS((void));
+static buf_T *vi_find_buffer __ARGS((char *));
+static void vi_exec_cmd __ARGS((char *));
+static void vi_set_cursor_pos __ARGS((long char_nr));
+static long vi_cursor_pos __ARGS((void));
+
+/* debug trace */
+#if 0
+static FILE* _tracefile = NULL;
+#define SNIFF_TRACE_OPEN(file) if (!_tracefile) _tracefile = fopen(file, "w")
+#define SNIFF_TRACE(msg) fprintf(_tracefile, msg); fflush(_tracefile);
+#define SNIFF_TRACE1(msg, arg) fprintf(_tracefile, msg,arg); fflush(_tracefile);
+#define SNIFF_TRACE_CLOSE fclose(_tracefile); _tracefile=NULL;
+#else
+#define SNIFF_TRACE_OPEN(file)
+#define SNIFF_TRACE(msg)
+#define SNIFF_TRACE1(msg, arg)
+#define SNIFF_TRACE_CLOSE
+#endif
+
+/*-------- Windows Only Declarations -----------------------------*/
+#ifdef WIN32
+
+static int  sniff_request_processed=1;
+static HANDLE sniffemacs_handle=NULL;
+static HANDLE readthread_handle=NULL;
+static HANDLE handle_to_sniff=NULL;
+static HANDLE handle_from_sniff=NULL;
+
+struct sniffBufNode
+{
+    struct sniffBufNode *next;
+    int    bufLen;
+    char   buf[MAX_REQUEST_LEN];
+};
+static struct sniffBufNode *sniffBufStart=NULL;
+static struct sniffBufNode *sniffBufEnd=NULL;
+static HANDLE hBufferMutex=NULL;
+
+# ifdef FEAT_GUI_W32
+    extern HWND s_hwnd;       /* gvim's Window handle */
+# endif
+/*
+ * some helper functions for Windows port only
+ */
+
+    static HANDLE
+ExecuteDetachedProgram(char *szBinary, char *szCmdLine,
+    HANDLE hStdInput, HANDLE hStdOutput)
+{
+    BOOL bResult;
+    DWORD nError;
+    PROCESS_INFORMATION aProcessInformation;
+    PROCESS_INFORMATION *pProcessInformation= &aProcessInformation;
+    STARTUPINFO aStartupInfo;
+    STARTUPINFO *pStartupInfo= &aStartupInfo;
+    DWORD dwCreationFlags= 0;
+    char szPath[512];
+    HINSTANCE hResult;
+
+    hResult = FindExecutable(szBinary, ".", szPath);
+    if ((int)hResult <= 32)
+    {
+	/* can't find the exe file */
+	return NULL;
+    }
+
+    ZeroMemory(pStartupInfo, sizeof(*pStartupInfo));
+    pStartupInfo->dwFlags= STARTF_USESHOWWINDOW|STARTF_USESTDHANDLES;
+    pStartupInfo->hStdInput = hStdInput;
+    pStartupInfo->hStdOutput = hStdOutput;
+    pStartupInfo->wShowWindow= SW_HIDE;
+    pStartupInfo->cb = sizeof(STARTUPINFO);
+
+    bResult= CreateProcess(
+	szPath,
+	szCmdLine,
+	NULL,    /* security attr for process */
+	NULL,    /* security attr for primary thread */
+	TRUE,    /* DO inherit stdin and stdout */
+	dwCreationFlags, /* creation flags */
+	NULL,    /* environment */
+	".",    /* current directory */
+	pStartupInfo,   /* startup info: NULL crashes  */
+	pProcessInformation /* process information: NULL crashes */
+    );
+    nError= GetLastError();
+    if (bResult)
+    {
+	CloseHandle(pProcessInformation->hThread);
+	CloseHandle(hStdInput);
+	CloseHandle(hStdOutput);
+	return(pProcessInformation->hProcess);
+    }
+    else
+	return(NULL);
+}
+
+/*
+ * write to the internal Thread / Thread communications buffer.
+ * Return TRUE if successful, FALSE else.
+ */
+    static BOOL
+writeToBuffer(char *msg, int len)
+{
+    DWORD dwWaitResult;     /* Request ownership of mutex. */
+    struct sniffBufNode *bn;
+    int bnSize;
+
+    SNIFF_TRACE1("writeToBuffer %d\n", len);
+    bnSize = sizeof(struct sniffBufNode) - MAX_REQUEST_LEN + len + 1;
+    if (bnSize < 128) bnSize = 128; /* minimum length to avoid fragmentation */
+    bn = (struct sniffBufNode *)malloc(bnSize);
+    if (!bn)
+	return FALSE;
+
+    memcpy(bn->buf, msg, len);
+    bn->buf[len]='\0';    /* terminate CString for added safety */
+    bn->next = NULL;
+    bn->bufLen = len;
+    /* now, acquire a Mutex for adding the string to our linked list */
+    dwWaitResult = WaitForSingleObject(
+	hBufferMutex,   /* handle of mutex */
+	1000L);   /* one-second time-out interval */
+    if (dwWaitResult == WAIT_OBJECT_0)
+    {
+	/* The thread got mutex ownership. */
+	if (sniffBufEnd)
+	{
+	    sniffBufEnd->next = bn;
+	    sniffBufEnd = bn;
+	}
+	else
+	    sniffBufStart = sniffBufEnd = bn;
+	/* Release ownership of the mutex object. */
+	if (! ReleaseMutex(hBufferMutex))
+	{
+	    /* Deal with error. */
+	}
+	return TRUE;
+    }
+
+    /* Cannot get mutex ownership due to time-out or mutex object abandoned. */
+    free(bn);
+    return FALSE;
+}
+
+/*
+ * read from the internal Thread / Thread communications buffer.
+ * Return TRUE if successful, FALSE else.
+ */
+    static int
+ReadFromBuffer(char *buf, int maxlen)
+{
+    DWORD dwWaitResult;     /* Request ownership of mutex. */
+    int   theLen;
+    struct sniffBufNode *bn;
+
+    dwWaitResult = WaitForSingleObject(
+	hBufferMutex,   /* handle of mutex */
+	1000L);		/* one-second time-out interval */
+    if (dwWaitResult == WAIT_OBJECT_0)
+    {
+	if (!sniffBufStart)
+	{
+	    /* all pending Requests Processed */
+	    theLen = 0;
+	}
+	else
+	{
+	    bn = sniffBufStart;
+	    theLen = bn->bufLen;
+	    SNIFF_TRACE1("ReadFromBuffer %d\n", theLen);
+	    if (theLen >= maxlen)
+	    {
+		/* notify the user of buffer overflow? */
+		theLen = maxlen-1;
+	    }
+	    memcpy(buf, bn->buf, theLen);
+	    buf[theLen] = '\0';
+	    if (! (sniffBufStart = bn->next))
+	    {
+		sniffBufEnd = NULL;
+		sniff_request_processed = 1;
+	    }
+	    free(bn);
+	}
+	if (! ReleaseMutex(hBufferMutex))
+	{
+	    /* Deal with error. */
+	}
+	return theLen;
+    }
+
+    /* Cannot get mutex ownership due to time-out or mutex object abandoned. */
+    return -1;
+}
+
+/* on Win32, a separate Thread reads the input pipe. get_request is not needed here. */
+    static void __cdecl
+SniffEmacsReadThread(void *dummy)
+{
+    static char	ReadThreadBuffer[MAX_REQUEST_LEN];
+    int		ReadThreadLen=0;
+    int		result=0;
+    int		msgLen=0;
+    char	*msgStart, *msgCur;
+
+    SNIFF_TRACE("begin thread\n");
+    /* Read from the pipe to SniffEmacs */
+    while (sniff_connected)
+    {
+	if (!ReadFile(handle_from_sniff,
+		ReadThreadBuffer + ReadThreadLen,    /* acknowledge rest in buffer */
+		MAX_REQUEST_LEN - ReadThreadLen,
+		&result,
+		NULL))
+	{
+	    DWORD err = GetLastError();
+	    result = -1;
+	}
+
+	if (result < 0)
+	{
+	    /* probably sniffemacs died... log the Error? */
+	    sniff_disconnect(1);
+	}
+	else if (result > 0)
+	{
+	    ReadThreadLen += result-1;   /* total length of valid chars */
+	    for(msgCur=msgStart=ReadThreadBuffer; ReadThreadLen > 0; msgCur++, ReadThreadLen--)
+	    {
+		if (*msgCur == '\0' || *msgCur == '\r' || *msgCur == '\n')
+		{
+		    msgLen = msgCur-msgStart; /* don't add the CR/LF chars */
+		    if (msgLen > 0)
+			writeToBuffer(msgStart, msgLen);
+		    msgStart = msgCur + 1; /* over-read single CR/LF chars */
+		}
+	    }
+
+	/* move incomplete message to beginning of buffer */
+	ReadThreadLen = msgCur - msgStart;
+	if (ReadThreadLen > 0)
+	    mch_memmove(ReadThreadBuffer, msgStart, ReadThreadLen);
+
+	if (sniff_request_processed)
+	{
+	    /* notify others that new data has arrived */
+	    sniff_request_processed = 0;
+	    sniff_request_waiting = 1;
+#ifdef FEAT_GUI_W32
+	    PostMessage(s_hwnd, WM_USER, (WPARAM)0, (LPARAM)0);
+#endif
+	    }
+	}
+    }
+    SNIFF_TRACE("end thread\n");
+}
+#endif /* WIN32 */
+/*-------- End of Windows Only Declarations ------------------------*/
+
+
+/* ProcessSniffRequests
+ * Function that should be called from outside
+ * to process the waiting sniff requests
+ */
+    void
+ProcessSniffRequests()
+{
+    static char buf[MAX_REQUEST_LEN];
+    int len;
+
+    while (sniff_connected)
+    {
+#ifdef WIN32
+	len = ReadFromBuffer(buf, sizeof(buf));
+#else
+	len = get_request(fd_from_sniff, buf, sizeof(buf));
+#endif
+	if (len < 0)
+	{
+	    vi_error_msg(_("E274: Sniff: Error during read. Disconnected"));
+	    sniff_disconnect(1);
+	    break;
+	}
+	else if (len > 0)
+	    HandleSniffRequest( buf );
+	else
+	    break;
+    }
+
+    if (sniff_will_disconnect)	/* Now the last msg has been processed */
+	sniff_disconnect(1);
+}
+
+    static struct sn_cmd *
+find_sniff_cmd(cmd)
+    char *cmd;
+{
+    struct sn_cmd *sniff_cmd = NULL;
+    int i;
+    for(i=0; sniff_cmds[i].cmd_name; i++)
+    {
+	if (!strcmp(cmd, sniff_cmds[i].cmd_name))
+	{
+	    sniff_cmd = &sniff_cmds[i];
+	    break;
+	}
+    }
+    if (!sniff_cmd)
+    {
+	struct sn_cmd_list *list = sniff_cmd_ext;
+	while (list)
+	{
+	    if (!strcmp(cmd, list->sniff_cmd->cmd_name))
+	    {
+		sniff_cmd = list->sniff_cmd;
+		break;
+	    }
+	    list = list->next_cmd;
+	}
+    }
+    return sniff_cmd;
+}
+
+    static int
+add_sniff_cmd(cmd, def, msg)
+    char *cmd;
+    char *def;
+    char *msg;
+{
+    int rc = 0;
+    if (def != NULL && def[0] != NUL && find_sniff_cmd(cmd) == NULL)
+    {
+	struct sn_cmd_list *list = sniff_cmd_ext;
+	struct sn_cmd *sniff_cmd = (struct sn_cmd*)malloc(sizeof(struct sn_cmd));
+	struct sn_cmd_list *cmd_node = (struct sn_cmd_list*)malloc(sizeof(struct sn_cmd_list));
+	int rq_type = 0;
+
+	/* unescape message text */
+	char *p = msg;
+	char *end = p+strlen(msg);
+	while (*p)
+	{
+	    if (*p == '\\')
+		mch_memmove(p,p+1,end-p);
+	    p++;
+	}
+	SNIFF_TRACE1("request name = %s\n",cmd);
+	SNIFF_TRACE1("request def = %s\n",def);
+	SNIFF_TRACE1("request msg = %s\n",msg);
+
+	while (list && list->next_cmd)
+	    list = list->next_cmd;
+	if (!list)
+	    sniff_cmd_ext = cmd_node;
+	else
+	    list->next_cmd = cmd_node;
+
+	sniff_cmd->cmd_name = cmd;
+	sniff_cmd->cmd_code = def[0];
+	sniff_cmd->cmd_msg = msg;
+	switch(def[1])
+	{
+	    case 'f':
+		rq_type = RQ_NOSYMBOL;
+		break;
+	    case 's':
+		rq_type = RQ_CONTEXT;
+		break;
+	    case 'S':
+		rq_type = RQ_SCONTEXT;
+		break;
+	    default:
+		rq_type = RQ_SIMPLE;
+		break;
+	}
+	sniff_cmd->cmd_type = rq_type;
+	cmd_node->sniff_cmd = sniff_cmd;
+	cmd_node->next_cmd = NULL;
+	rc = 1;
+    }
+    return rc;
+}
+
+/* ex_sniff
+ * Handle ":sniff" command
+ */
+    void
+ex_sniff(eap)
+    exarg_T	*eap;
+{
+    char_u	*arg = eap->arg;
+    char_u *symbol = NULL;
+    char_u *cmd = NULL;
+
+    SNIFF_TRACE_OPEN("if_sniff.log");
+    if (ends_excmd(*arg))	/* no request: print available commands */
+    {
+	int i;
+	msg_start();
+	msg_outtrans_attr((char_u *)"-- SNiFF+ commands --", hl_attr(HLF_T));
+	for(i=0; sniff_cmds[i].cmd_name; i++)
+	{
+	    msg_putchar('\n');
+	    msg_outtrans((char_u *)":sniff ");
+	    msg_outtrans((char_u *)sniff_cmds[i].cmd_name);
+	}
+	msg_putchar('\n');
+	msg_outtrans((char_u *)_("SNiFF+ is currently "));
+	if (!sniff_connected)
+	    msg_outtrans((char_u *)_("not "));
+	msg_outtrans((char_u *)_("connected"));
+	msg_end();
+    }
+    else	/* extract command name and symbol if present */
+    {
+	symbol = skiptowhite(arg);
+	cmd  = vim_strnsave(arg, (int)(symbol-arg));
+	symbol = skipwhite(symbol);
+	if (ends_excmd(*symbol))
+	    symbol = NULL;
+	if (!strcmp((char *)cmd, "addcmd"))
+	{
+	    char_u *def = skiptowhite(symbol);
+	    char_u *name = vim_strnsave(symbol, (int)(def-symbol));
+	    char_u *msg;
+	    def = skipwhite(def);
+	    msg = skiptowhite(def);
+	    def = vim_strnsave(def, (int)(msg-def));
+	    msg = skipwhite(msg);
+	    if (ends_excmd(*msg))
+		msg = vim_strsave(name);
+	    else
+		msg = vim_strnsave(msg, (int)(skiptowhite_esc(msg)-msg));
+	    if (!add_sniff_cmd((char*)name, (char*)def, (char*)msg))
+	    {
+		vim_free(msg);
+		vim_free(def);
+		vim_free(name);
+	    }
+	}
+	else
+	{
+	    struct sn_cmd* sniff_cmd = find_sniff_cmd((char*)cmd);
+	    if (sniff_cmd)
+		SendRequest(sniff_cmd, (char *)symbol);
+	    else
+		EMSG2(_("E275: Unknown SNiFF+ request: %s"), cmd);
+	}
+	vim_free(cmd);
+    }
+}
+
+
+    static void
+sniff_connect()
+{
+    if (sniff_connected)
+	return;
+    if (ConnectToSniffEmacs())
+	vi_error_msg(_("E276: Error connecting to SNiFF+"));
+    else
+    {
+	int i;
+
+	for (i = 0; init_cmds[i]; i++)
+	    vi_exec_cmd(init_cmds[i]);
+    }
+}
+
+    void
+sniff_disconnect(immediately)
+    int immediately;
+{
+    if (!sniff_connected)
+	return;
+    if (immediately)
+    {
+	vi_exec_cmd("augroup sniff");
+	vi_exec_cmd("au!");
+	vi_exec_cmd("augroup END");
+	vi_exec_cmd("unlet g:sniff_connected");
+	sniff_connected = 0;
+	want_sniff_request = 0;
+	sniff_will_disconnect = 0;
+#ifdef FEAT_GUI
+	if (gui.in_use)
+	    gui_mch_wait_for_chars(0L);
+#endif
+#ifdef WIN32
+	while (sniffBufStart != NULL)
+	{
+	    struct sniffBufNode *node = sniffBufStart;
+	    sniffBufStart = sniffBufStart->next;
+	    free(node);
+	}
+	sniffBufStart = sniffBufEnd = NULL;
+	sniff_request_processed = 1;
+	CloseHandle(handle_to_sniff);
+	CloseHandle(handle_from_sniff);
+	WaitForSingleObject(sniffemacs_handle, 1000L);
+	CloseHandle(sniffemacs_handle);
+	sniffemacs_handle = NULL;
+	WaitForSingleObject(readthread_handle, 1000L);
+	readthread_handle = NULL;
+	CloseHandle(hBufferMutex);
+	hBufferMutex = NULL;
+	SNIFF_TRACE_CLOSE;
+#else
+	close(fd_to_sniff);
+	close(fd_from_sniff);
+	wait(NULL);
+#endif
+    }
+    else
+    {
+#ifdef WIN32
+# if (defined(_MSC_VER) && _MSC_VER >= 1400)
+        Sleep(2);
+# else
+	_sleep(2);
+# endif
+	if (!sniff_request_processed)
+	    ProcessSniffRequests();
+#else
+	sleep(2);		    /* Incoming msg could disturb edit */
+#endif
+	sniff_will_disconnect = 1;  /* We expect disconnect msg in 2 secs */
+    }
+}
+
+
+/* ConnectToSniffEmacs
+ * Connect to Sniff: returns 1 on error
+ */
+    static int
+ConnectToSniffEmacs()
+{
+#ifdef WIN32		/* Windows Version of the Code */
+    HANDLE ToSniffEmacs[2], FromSniffEmacs[2];
+    SECURITY_ATTRIBUTES sa;
+
+    sa.nLength = sizeof(sa);
+    sa.lpSecurityDescriptor = NULL;
+    sa.bInheritHandle = TRUE;
+
+    if (! CreatePipe(&ToSniffEmacs[0], &ToSniffEmacs[1], &sa, 0))
+	return 1;
+    if (! CreatePipe(&FromSniffEmacs[0], &FromSniffEmacs[1], &sa, 0))
+	return 1;
+
+    sniffemacs_handle = ExecuteDetachedProgram(SniffEmacs[0], SniffEmacs[0],
+	ToSniffEmacs[0], FromSniffEmacs[1]);
+
+    if (sniffemacs_handle)
+    {
+	handle_to_sniff  = ToSniffEmacs[1];
+	handle_from_sniff = FromSniffEmacs[0];
+	sniff_connected = 1;
+	hBufferMutex = CreateMutex(
+	    NULL,			/* no security attributes */
+	    FALSE,			/* initially not owned */
+	    "SniffReadBufferMutex");    /* name of mutex */
+	if (hBufferMutex == NULL)
+	{
+	    /* Check for error. */
+	}
+	readthread_handle = (HANDLE)_beginthread(SniffEmacsReadThread, 0, NULL);
+	return 0;
+    }
+    else
+    {
+	/* error in spawn() */
+	return 1;
+    }
+
+#else		/* UNIX Version of the Code */
+    int ToSniffEmacs[2], FromSniffEmacs[2];
+
+    if (pipe(ToSniffEmacs) != 0)
+	return 1;
+    if (pipe(FromSniffEmacs) != 0)
+	return 1;
+
+    /* fork */
+    if ((sniffemacs_pid=fork()) == 0)
+    {
+	/* child */
+
+	/* prepare communication pipes */
+	close(ToSniffEmacs[1]);
+	close(FromSniffEmacs[0]);
+
+	dup2(ToSniffEmacs[0],fileno(stdin));   /* write to ToSniffEmacs[1] */
+	dup2(FromSniffEmacs[1],fileno(stdout));/* read from FromSniffEmacs[0] */
+
+	close(ToSniffEmacs[0]);
+	close(FromSniffEmacs[1]);
+
+	/* start sniffemacs */
+	execvp (SniffEmacs[0], SniffEmacs);
+	{
+/*	    FILE *out = fdopen(FromSniffEmacs[1], "w"); */
+	    sleep(1);
+	    fputs(_(msg_sniff_disconnect), stdout);
+	    fflush(stdout);
+	    sleep(3);
+#ifdef FEAT_GUI
+	    if (gui.in_use)
+		gui_exit(1);
+#endif
+	    exit(1);
+	}
+	return 1;
+    }
+    else if (sniffemacs_pid > 0)
+    {
+	/* parent process */
+	close(ToSniffEmacs[0]);
+	fd_to_sniff  = ToSniffEmacs[1];
+	close(FromSniffEmacs[1]);
+	fd_from_sniff = FromSniffEmacs[0];
+	sniff_connected = 1;
+	return 0;
+    }
+    else   /* error in fork() */
+	return 1;
+#endif		/* UNIX Version of the Code */
+}
+
+
+/* HandleSniffRequest
+ * Handle one request from SNiFF+
+ */
+    static void
+HandleSniffRequest(buffer)
+    char *buffer;
+{
+    char VICommand[MAX_REQUEST_LEN];
+    char command;
+    char *arguments;
+    char *token;
+    char *argv[3];
+    int argc = 0;
+    buf_T  *buf;
+
+    const char *SetTab     = "set tabstop=%d";
+    const char *SelectBuf  = "buf %s";
+    const char *DeleteBuf  = "bd %s";
+    const char *UnloadBuf  = "bun %s";
+    const char *GotoLine   = "%d";
+
+    command   = buffer[0];
+    arguments = &buffer[1];
+    token = strtok(arguments, sniff_rq_sep);
+    while (argc <3)
+    {
+	if (token)
+	{
+	    argv[argc] = (char*)vim_strsave((char_u *)token);
+	    token = strtok(0, sniff_rq_sep);
+	}
+	else
+	    argv[argc] = strdup("");
+	argc++;
+    }
+
+    switch (command)
+    {
+	case 'o' :  /* visit file at char pos */
+	case 'O' :  /* visit file at line number */
+	{
+	    char *file = argv[0];
+	    int position = atoi(argv[1]);
+
+	    buf = vi_find_buffer(file);
+	    setpcmark();      /* insert current pos in jump list [mark.c]*/
+	    if (!buf)
+		vi_open_file(file);
+	    else if (buf!=curbuf)
+	    {
+		vim_snprintf(VICommand, sizeof(VICommand),
+						     (char *)SelectBuf, file);
+		vi_exec_cmd(VICommand);
+	    }
+	    if (command == 'o')
+		vi_set_cursor_pos((long)position);
+	    else
+	    {
+		vim_snprintf(VICommand, sizeof(VICommand),
+					     (char *)GotoLine, (int)position);
+		vi_exec_cmd(VICommand);
+	    }
+	    checkpcmark();	/* [mark.c] */
+#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_W32)
+	    if (gui.in_use && !gui.in_focus)  /* Raise Vim Window */
+	    {
+# ifdef FEAT_GUI_W32
+		SetForegroundWindow(s_hwnd);
+# else
+		extern Widget vimShell;
+
+		XSetInputFocus(gui.dpy, XtWindow(vimShell), RevertToNone,
+			CurrentTime);
+		XRaiseWindow(gui.dpy, XtWindow(vimShell));
+# endif
+	    }
+#endif
+	    break;
+	}
+	case 'p' :  /* path of file has changed */
+	    /* when changing from shared to private WS (checkout) */
+	{
+	    char *file = argv[0];
+	    char *new_path = argv[1];
+
+	    buf = vi_find_buffer(file);
+	    if (buf && !buf->b_changed) /* delete buffer only if not modified */
+	    {
+		vim_snprintf(VICommand, sizeof(VICommand),
+						     (char *)DeleteBuf, file);
+		vi_exec_cmd(VICommand);
+	    }
+	    vi_open_file(new_path);
+	    break;
+	}
+	case 'w' :  /* writability has changed */
+	    /* Sniff sends request twice,
+	     * but only the last one is the right one */
+	{
+	    char *file = argv[0];
+	    int writable = atoi(argv[1]);
+
+	    buf = vi_find_buffer(file);
+	    if (buf)
+	    {
+		buf->b_p_ro = !writable;
+		if (buf != curbuf)
+		{
+		    buf->b_flags |= BF_CHECK_RO + BF_NEVERLOADED;
+		    if (writable && !buf->b_changed)
+		    {
+			vim_snprintf(VICommand, sizeof(VICommand),
+						     (char *)UnloadBuf, file);
+			vi_exec_cmd(VICommand);
+		    }
+		}
+		else if (writable && !buf->b_changed)
+		{
+		    vi_exec_cmd("e");
+		}
+	    }
+	    break;
+	}
+	case 'h' :  /* highlight info */
+	    break;  /* not implemented */
+
+	case 't' :  /* Set tab width */
+	{
+	    int tab_width = atoi(argv[1]);
+
+	    if (tab_width > 0 && tab_width <= 16)
+	    {
+		vim_snprintf(VICommand, sizeof(VICommand),
+						   (char *)SetTab, tab_width);
+		vi_exec_cmd(VICommand);
+	    }
+	    break;
+	}
+	case '|':
+	{
+	    /* change the request separator */
+	    sniff_rq_sep[0] = arguments[0];
+	    /* echo the request */
+	    WriteToSniff(buffer);
+	    break;
+	}
+	case 'A' :  /* Warning/Info msg */
+	    vi_msg(arguments);
+	    if (!strncmp(arguments, "Disconnected", 12))
+		sniff_disconnect(1);	/* unexpected disconnection */
+	    break;
+	case 'a' :  /* Error msg */
+	    vi_error_msg(arguments);
+	    if (!strncmp(arguments, "Cannot connect", 14))
+		sniff_disconnect(1);
+	    break;
+
+	default :
+	    break;
+    }
+    while (argc)
+	vim_free(argv[--argc]);
+}
+
+
+#ifndef WIN32
+/* get_request
+ * read string from fd up to next newline (excluding the nl),
+ * returns  length of string
+ *	    0 if no data available or no complete line
+ *	   <0 on error
+ */
+    static int
+get_request(fd, buf, maxlen)
+    int		fd;
+    char	*buf;
+    int		maxlen;
+{
+    static char	inbuf[1024];
+    static int	pos = 0, bytes = 0;
+    int		len;
+#ifdef HAVE_SELECT
+    struct timeval tval;
+    fd_set	rfds;
+
+    FD_ZERO(&rfds);
+    FD_SET(fd, &rfds);
+    tval.tv_sec  = 0;
+    tval.tv_usec = 0;
+#else
+    struct pollfd fds;
+
+    fds.fd = fd;
+    fds.events = POLLIN;
+#endif
+
+    for (len = 0; len < maxlen; len++)
+    {
+	if (pos >= bytes)	    /* end of buffer reached? */
+	{
+#ifdef HAVE_SELECT
+	    if (select(fd + 1, &rfds, NULL, NULL, &tval) > 0)
+#else
+	    if (poll(&fds, 1, 0) > 0)
+#endif
+	    {
+		pos = 0;
+		bytes = read(fd, inbuf, sizeof(inbuf));
+		if (bytes <= 0)
+		    return bytes;
+	    }
+	    else
+	    {
+		pos = pos-len;
+		buf[0] = '\0';
+		return 0;
+	    }
+	}
+	if ((buf[len] = inbuf[pos++]) =='\n')
+	    break;
+    }
+    buf[len] = '\0';
+    return len;
+}
+#endif     /* WIN32 */
+
+
+    static void
+SendRequest(command, symbol)
+    struct sn_cmd *command;
+    char *symbol;
+{
+    int		cmd_type = command->cmd_type;
+    static char cmdstr[MAX_REQUEST_LEN];
+    static char msgtxt[MAX_REQUEST_LEN];
+    char	*buffer_name = NULL;
+
+    if (cmd_type == RQ_CONNECT)
+    {
+	sniff_connect();
+	return;
+    }
+    if (!sniff_connected && !(cmd_type & SILENT))
+    {
+	vi_error_msg(_("E278: SNiFF+ not connected"));
+	return;
+    }
+
+    if (cmd_type & NEED_FILE)
+    {
+	if (!curbuf->b_sniff)
+	{
+	    if (!(cmd_type & SILENT))
+		vi_error_msg(_("E279: Not a SNiFF+ buffer"));
+	    return;
+	}
+	buffer_name = vi_buffer_name();
+	if (buffer_name == NULL)
+	    return;
+	if (cmd_type & NEED_SYMBOL)
+	{
+	    if (cmd_type & EMPTY_SYMBOL)
+		symbol = " ";
+	    else if (!symbol && !(symbol = vi_symbol_under_cursor()))
+		return;	    /* error msg already displayed */
+	}
+
+	if (symbol)
+	    vim_snprintf(cmdstr, sizeof(cmdstr), "%c%s%s%ld%s%s\n",
+		command->cmd_code,
+		buffer_name,
+		sniff_rq_sep,
+		vi_cursor_pos(),
+		sniff_rq_sep,
+		symbol
+	    );
+	else
+	    vim_snprintf(cmdstr, sizeof(cmdstr), "%c%s\n",
+		    command->cmd_code, buffer_name);
+    }
+    else    /* simple request */
+    {
+	cmdstr[0] = command->cmd_code;
+	cmdstr[1] = '\n';
+	cmdstr[2] = '\0';
+    }
+    if (command->cmd_msg && !(cmd_type & SILENT))
+    {
+	if ((cmd_type & NEED_SYMBOL) && !(cmd_type & EMPTY_SYMBOL))
+	{
+	    vim_snprintf(msgtxt, sizeof(msgtxt), "%s: %s",
+						 _(command->cmd_msg), symbol);
+	    vi_msg(msgtxt);
+	}
+	else
+	    vi_msg(_(command->cmd_msg));
+    }
+    WriteToSniff(cmdstr);
+    if (cmd_type & DISCONNECT)
+	sniff_disconnect(0);
+}
+
+
+
+    static void
+WriteToSniff(str)
+    char *str;
+{
+    int bytes;
+#ifdef WIN32
+    if (! WriteFile(handle_to_sniff, str, strlen(str), &bytes, NULL))
+    {
+	DWORD err=GetLastError();
+	bytes = -1;
+    }
+#else
+    bytes = write(fd_to_sniff, str, strlen(str));
+#endif
+    if (bytes<0)
+    {
+	vi_msg(_("Sniff: Error during write. Disconnected"));
+	sniff_disconnect(1);
+    }
+}
+
+/*-------- vim helping functions --------------------------------*/
+
+    static void
+vi_msg(str)
+    char *str;
+{
+    if (str != NULL && *str != NUL)
+	MSG((char_u *)str);
+}
+
+    static void
+vi_error_msg(str)
+    char *str;
+{
+    if (str != NULL && *str != NUL)
+	EMSG((char_u *)str);
+}
+
+    static void
+vi_open_file(fname)
+    char *fname;
+{
+    ++no_wait_return;
+    do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF,
+	    curwin);
+    curbuf->b_sniff = TRUE;
+    --no_wait_return;					/* [ex_docmd.c] */
+}
+
+    static buf_T *
+vi_find_buffer(fname)
+    char *fname;
+{			    /* derived from buflist_findname() [buffer.c] */
+    buf_T	*buf;
+
+    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
+	if (buf->b_sfname != NULL && fnamecmp(fname, buf->b_sfname) == 0)
+	    return (buf);
+    return NULL;
+}
+
+
+    static char *
+vi_symbol_under_cursor()
+{
+    int		len;
+    char	*symbolp;
+    char	*p;
+    static char sniff_symbol[256];
+
+    len = find_ident_under_cursor((char_u **)&symbolp, FIND_IDENT);
+    /* [normal.c] */
+    if (len <= 0)
+	return NULL;
+    for (p=sniff_symbol; len; len--)
+	*p++ = *symbolp++;
+    *p = '\0';
+    return sniff_symbol;
+}
+
+
+    static char *
+vi_buffer_name()
+{
+    return (char *)curbuf->b_sfname;
+}
+
+    static void
+vi_exec_cmd(vicmd)
+    char *vicmd;
+{
+    do_cmdline_cmd((char_u *)vicmd);  /* [ex_docmd.c] */
+}
+
+/*
+ * Set cursor on character position
+ * derived from cursor_pos_info() [buffer.c]
+ */
+    static void
+vi_set_cursor_pos(char_pos)
+    long char_pos;
+{
+    linenr_T	lnum;
+    long	char_count = 1;  /* first position = 1 */
+    int		line_size;
+    int		eol_size;
+
+    if (char_pos == 0)
+    {
+	char_pos = 1;
+    }
+    if (get_fileformat(curbuf) == EOL_DOS)
+	eol_size = 2;
+    else
+	eol_size = 1;
+    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
+    {
+	line_size = STRLEN(ml_get(lnum)) + eol_size;
+	if (char_count+line_size > char_pos) break;
+	char_count += line_size;
+    }
+    curwin->w_cursor.lnum = lnum;
+    curwin->w_cursor.col  = char_pos - char_count;
+}
+
+    static long
+vi_cursor_pos()
+{
+    linenr_T	lnum;
+    long	char_count=1;  /* sniff starts with pos 1 */
+    int		line_size;
+    int		eol_size;
+
+    if (curbuf->b_p_tx)
+	eol_size = 2;
+    else
+	eol_size = 1;
+    for (lnum = 1; lnum < curwin->w_cursor.lnum; ++lnum)
+    {
+	line_size = STRLEN(ml_get(lnum)) + eol_size;
+	char_count += line_size;
+    }
+    return char_count + curwin->w_cursor.col;
+}
diff -urN vim-src/src/if_sniff.h vim-qt-src/src/if_sniff.h
--- vim-src/src/if_sniff.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/if_sniff.h	2016-06-08 06:39:27.730315218 +0200
@@ -0,0 +1,16 @@
+/*
+ * if_sniff.h Interface between Vim and SNiFF+
+ */
+
+#ifndef __if_sniff_h__
+#define __if_sniff_h__
+
+extern int  want_sniff_request;
+extern int  sniff_request_waiting;
+extern int  sniff_connected;
+extern int  fd_from_sniff;
+extern void sniff_disconnect __ARGS((int immediately));
+extern void ProcessSniffRequests __ARGS((void));
+extern void ex_sniff __ARGS((exarg_T *eap));
+
+#endif
diff -urN vim-src/src/main.c vim-qt-src/src/main.c
--- vim-src/src/main.c	2016-06-08 06:34:09.801884855 +0200
+++ vim-qt-src/src/main.c	2016-06-08 06:40:09.632637369 +0200
@@ -1663,7 +1663,7 @@
     }
 
     /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
-    if (TOLOWER_ASC(initstr[0]) == 'g')
+    if (TOLOWER_ASC(initstr[0]) == 'g' || TOLOWER_ASC(initstr[0]) == 'q')
     {
 	main_start_gui();
 #ifdef FEAT_GUI
diff -urN vim-src/src/menu.c vim-qt-src/src/menu.c
--- vim-src/src/menu.c	2016-03-27 19:08:37.211722709 +0200
+++ vim-qt-src/src/menu.c	2016-06-08 06:40:09.635637392 +0200
@@ -272,7 +272,7 @@
 	EMSG(_(e_trailing));
 	goto theend;
     }
-#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
+#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || FEAT_GUI_QT)
     old_menu_height = gui.menu_height;
 # if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
     old_toolbar_height = gui.toolbar_height;
@@ -391,7 +391,7 @@
 	vim_free(map_buf);
     }
 
-#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK))
+#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT))
     /* If the menubar height changed, resize the window */
     if (gui.in_use
 	    && (gui.menu_height != old_menu_height
diff -urN vim-src/src/message.c vim-qt-src/src/message.c
--- vim-src/src/message.c	2016-06-08 06:34:09.803884870 +0200
+++ vim-qt-src/src/message.c	2016-06-08 06:40:09.635637392 +0200
@@ -3777,7 +3777,7 @@
 	    filter = BROWSE_FILTER_DEFAULT;
 	if (flags & BROWSE_DIR)
 	{
-#  if defined(FEAT_GUI_GTK) || defined(WIN3264)
+#  if defined(FEAT_GUI_GTK) || defined(WIN3264) && !defined(FEAT_GUI_QT)
 	    /* For systems that have a directory dialog. */
 	    fname = gui_mch_browsedir(title, initdir);
 #  else
@@ -3785,7 +3785,7 @@
 	     * remove the file name. */
 	    fname = gui_mch_browse(0, title, dflt, ext, initdir, (char_u *)"");
 #  endif
-#  if !defined(FEAT_GUI_GTK)
+#  if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_QT)
 	    /* Win32 adds a dummy file name, others return an arbitrary file
 	     * name.  GTK+ 2 returns only the directory, */
 	    if (fname != NULL && *fname != NUL && !mch_isdir(fname))
diff -urN vim-src/src/normal.c vim-qt-src/src/normal.c
--- vim-src/src/normal.c	2016-06-08 06:34:09.811884931 +0200
+++ vim-qt-src/src/normal.c	2016-06-08 06:40:09.642637446 +0200
@@ -2636,7 +2636,7 @@
 	     * Windows only shows the popup menu on the button up event.
 	     */
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
-			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT)
 	    if (!is_click)
 		return FALSE;
 #endif
@@ -2646,7 +2646,7 @@
 #endif
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
 	    || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON)
+	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_QT)
 	    if (gui.in_use)
 	    {
 		jump_flags = 0;
diff -urN vim-src/src/ops.c vim-qt-src/src/ops.c
--- vim-src/src/ops.c	2016-06-08 06:34:09.812884939 +0200
+++ vim-qt-src/src/ops.c	2016-06-08 06:40:09.643637454 +0200
@@ -29,7 +29,7 @@
 #define DELETION_REGISTER	36
 #ifdef FEAT_CLIPBOARD
 # define STAR_REGISTER		37
-#  ifdef FEAT_X11
+#  if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 #   define PLUS_REGISTER	38
 #  else
 #   define PLUS_REGISTER	STAR_REGISTER	    /* there is only one */
@@ -2918,7 +2918,7 @@
     char_u		*p;
     char_u		*pnew;
     struct block_def	bd;
-#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+#if defined(FEAT_CLIPBOARD) && ( defined(FEAT_X11) || defined(FEAT_GUI_QT) )
     int			did_star = FALSE;
 #endif
 
@@ -3187,12 +3187,12 @@
 
 	clip_own_selection(&clip_star);
 	clip_gen_set_selection(&clip_star);
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 	did_star = TRUE;
 # endif
     }
 
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
     /*
      * If we were yanking to the '+' register, send result to selection.
      * Also copy to the '*' register, in case auto-select is off.
diff -urN vim-src/src/option.c vim-qt-src/src/option.c
--- vim-src/src/option.c	2016-06-08 06:34:09.814884954 +0200
+++ vim-qt-src/src/option.c	2016-06-08 06:40:09.644637462 +0200
@@ -1264,6 +1264,28 @@
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+
+    {"fullscreen",    "fu", P_BOOL|P_NO_MKRC,
+#ifdef FEAT_FULLSCREEN
+			    (char_u *)&p_fullscreen, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+
+    {"fuoptions",  "fuopt", P_STRING|P_COMMA|P_NODUP|P_VI_DEF,
+#ifdef FEAT_FULLSCREEN
+			    (char_u *)&p_fuoptions, PV_NONE,
+			    {(char_u *)"", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)NULL, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+
+
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
@@ -6588,7 +6610,7 @@
 	if (gui.in_use)
 	{
 	    p = p_guifont;
-# if defined(FEAT_GUI_GTK)
+# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 	    /*
 	     * Put up a font dialog and let the user select a new value.
 	     * If this is cancelled go back to the old value but don't
@@ -7132,6 +7154,14 @@
     }
 #endif
 
+#ifdef FEAT_FULLSCREEN
+    /* 'fuoptions' */
+    else if (varp == &p_fuoptions)
+    {
+        gui_mch_update_fuoptions(p_fuoptions);
+    }
+#endif
+
 #ifdef FEAT_VIRTUALEDIT
     /* 'virtualedit' */
     else if (varp == &p_ve)
@@ -8062,6 +8092,18 @@
 	set_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);
     }
 
+#ifdef FEAT_FULLSCREEN
+    else if ((int *)varp == &p_fullscreen && (gui.in_use || gui.starting))
+    {
+	if ( p_fullscreen && !old_value )
+	{
+	    gui_mch_enter_fullscreen();
+	} else if ( !p_fullscreen && old_value ) {
+	    gui_mch_leave_fullscreen();
+	}
+    }
+#endif
+
     /* when 'textauto' is set or reset also change 'fileformats' */
     else if ((int *)varp == &p_ta)
 	set_string_option_direct((char_u *)"ffs", -1,
@@ -8157,7 +8199,7 @@
 	p_wiv = (*T_XS != NUL);
     }
 
-#ifdef FEAT_BEVAL
+#if defined(FEAT_BEVAL) && !defined(FEAT_GUI_QT) 
     else if ((int *)varp == &p_beval)
     {
 	if (p_beval && !old_value)
diff -urN vim-src/src/option.h vim-qt-src/src/option.h
--- vim-src/src/option.h	2016-06-08 06:34:09.814884954 +0200
+++ vim-qt-src/src/option.h	2016-06-08 06:40:09.644637462 +0200
@@ -511,6 +511,10 @@
 #ifdef HAVE_FSYNC
 EXTERN int	p_fs;		/* 'fsync' */
 #endif
+#ifdef FEAT_FULLSCREEN
+EXTERN int	p_fullscreen;	/* fullscreen gui window */
+EXTERN char_u	*p_fuoptions;	/* fullscreen options */
+#endif
 EXTERN int	p_gd;		/* 'gdefault' */
 #ifdef FEAT_PRINTER
 EXTERN char_u	*p_pdev;	/* 'printdevice' */
diff -urN vim-src/src/os_msdos.c vim-qt-src/src/os_msdos.c
--- vim-src/src/os_msdos.c	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/os_msdos.c	2016-06-08 06:39:27.750315372 +0200
@@ -0,0 +1,3090 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * os_msdos.c
+ *
+ * MSDOS system-dependent routines.
+ * A cheap plastic imitation of the amiga dependent code.
+ * A lot in this file was made by Juergen Weigert (jw).
+ *
+ * DJGPP changes by Gert van Antwerpen
+ * Faster text screens by John Lange (jlange@zilker.net)
+ * Windows clipboard functionality added by David Kotchan (dk)
+ *
+ * Some functions are also used for Win16 (MS-Windows 3.1).
+ */
+
+#include "vim.h"
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+# include <conio.h>
+#endif
+
+/*
+ * MS-DOS only code, not used for Win16.
+ */
+#ifndef WIN16
+
+
+#ifndef PROTO
+# include <bios.h>
+# ifdef DJGPP
+#  include <dpmi.h>
+#  include <signal.h>
+#  include <sys/movedata.h>
+#  include <crt0.h>
+#  ifdef FEAT_CLIPBOARD
+#   include <sys/segments.h>
+#  endif
+# else
+#  include <alloc.h>
+# endif
+#endif
+
+#if defined(DJGPP) || defined(PROTO)
+# define _cdecl	    /* DJGPP doesn't have this */
+#endif
+
+static int cbrk_pressed = FALSE;    /* set by ctrl-break interrupt */
+static int ctrlc_pressed = FALSE;   /* set when ctrl-C or ctrl-break detected */
+static int delayed_redraw = FALSE;  /* set when ctrl-C detected */
+
+static int bioskey_read = _NKEYBRD_READ;   /* bioskey() argument: read key */
+static int bioskey_ready = _NKEYBRD_READY; /* bioskey() argument: key ready? */
+
+#ifdef FEAT_MOUSE
+static int mouse_avail = FALSE;		/* mouse present */
+static int mouse_active;		/* mouse enabled */
+static int mouse_hidden;		/* mouse not shown */
+static int mouse_click = -1;		/* mouse status */
+static int mouse_last_click = -1;	/* previous status at click */
+static int mouse_x = -1;		/* mouse x coordinate */
+static int mouse_y = -1;		/* mouse y coordinate */
+static long mouse_click_time = 0;	/* biostime() of last click */
+static int mouse_click_count = 0;	/* count for multi-clicks */
+static int mouse_click_x = 0;		/* x of previous mouse click */
+static int mouse_click_y = 0;		/* y of previous mouse click */
+static linenr_T mouse_topline = 0;	/* w_topline at previous mouse click */
+#ifdef FEAT_DIFF
+static int mouse_topfill = 0;		/* w_topfill at previous mouse click */
+#endif
+static int mouse_x_div = 8;		/* column = x coord / mouse_x_div */
+static int mouse_y_div = 8;		/* line   = y coord / mouse_y_div */
+#endif
+
+#define BIOSTICK    55			/* biostime() increases one tick about
+					   every 55 msec */
+
+static int orig_attr = 0x0700;		/* video attributes when starting */
+
+static int S_iLeft = 0;			/* Scroll window; these are 1 offset */
+static int S_iTop = 0;
+static int S_iRight = 0;
+static int S_iBottom = 0;
+
+/*
+ * Need to remember the values, because we set horizontal and vertical
+ * edges separately.
+ */
+    static void
+mywindow(int iLeft, int iTop, int iRight, int iBottom)
+{
+    S_iLeft = iLeft;
+    S_iTop = iTop;
+    S_iRight = iRight;
+    S_iBottom = iBottom;
+    window(iLeft, iTop, iRight, iBottom);
+}
+
+#ifdef DJGPP
+/*
+ * For DJGPP, use our own functions for fast text screens.  JML 1/18/98
+ */
+
+unsigned long	S_ulScreenBase = 0xb8000;
+unsigned short	S_uiAttribute = 0;
+int		S_iCurrentRow = 0;	/* These are 0 offset */
+int		S_iCurrentColumn = 0;
+short		S_selVideo;	/* Selector for DJGPP direct video transfers */
+
+/*
+ * Use burst writes to improve mch_write speed - VJN 01/10/99
+ */
+unsigned short	S_linebuffer[8000]; /* <VN> enough for 160x50 */
+unsigned short	S_blankbuffer[256]; /* <VN> max length of console line */
+unsigned short	*S_linebufferpos = S_linebuffer;
+int		S_iBufferRow;
+int		S_iBufferColumn;
+
+    static void
+myflush(void)
+{
+    if (S_linebufferpos != S_linebuffer)
+    {
+	_dosmemputw(S_linebuffer, (S_linebufferpos - S_linebuffer),
+		S_ulScreenBase
+		      + S_iBufferRow * (Columns << 1) + (S_iBufferColumn << 1));
+	S_linebufferpos = S_linebuffer;
+    }
+}
+
+    static void
+mygotoxy(int x, int y)
+{
+    S_iCurrentRow = y - 1;
+    S_iCurrentColumn = x - 1;
+}
+
+/*
+ * Set the system cursor to our cursor position.
+ */
+    static void
+set_sys_cursor(void)
+{
+    if (term_console && full_screen)
+    {
+	myflush();
+	gotoxy(S_iCurrentColumn + 1, S_iCurrentRow + 1);
+    }
+}
+
+    static void
+setblankbuffer(unsigned short uiValue)
+{
+    int				i;
+    static unsigned short	olduiValue = 0;
+
+    if (olduiValue != uiValue)
+    {
+	/* Load blank line buffer with spaces */
+	for (i = 0; i < Columns; ++i)
+	    S_blankbuffer[i] = uiValue;
+	olduiValue = uiValue;
+    }
+}
+
+    static void
+myclreol(void)
+{
+    /* Clear to end of line */
+    setblankbuffer(S_uiAttribute | ' ');
+    _dosmemputw(S_blankbuffer, S_iRight - S_iCurrentColumn, S_ulScreenBase
+			 + (S_iCurrentRow) * (Columns << 1)
+			 + (S_iCurrentColumn << 1));
+}
+
+    static void
+myclrscr(void)
+{
+    /* Clear whole screen */
+    short	iColumn;
+    int		endpoint = (Rows * Columns) << 1;
+
+    setblankbuffer(S_uiAttribute | ' ');
+
+    for (iColumn = 0; iColumn < endpoint; iColumn += (Columns << 1))
+	_dosmemputw(S_blankbuffer, Columns, S_ulScreenBase + iColumn);
+}
+
+    static void
+mydelline(void)
+{
+    short iRow, iColumn;
+
+    iColumn = (S_iLeft - 1) << 1;
+
+    /* Copy the lines underneath */
+    for (iRow = S_iCurrentRow; iRow < S_iBottom - 1; iRow++)
+	movedata(S_selVideo, (((iRow + 1) * Columns) << 1) + iColumn,
+		S_selVideo, ((iRow * Columns) << 1) + iColumn,
+		(S_iRight - S_iLeft + 1) << 1);
+
+    /* Clear the new row */
+    setblankbuffer(S_uiAttribute | ' ');
+
+    _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
+			 + (S_iBottom - 1) * (Columns << 1) + iColumn);
+}
+
+    static void
+myinsline(void)
+{
+    short iRow, iColumn;
+
+    iColumn = (S_iLeft - 1) << 1;
+
+    /* Copy the lines underneath */
+    for (iRow = S_iBottom - 1; iRow >= S_iTop; iRow--)
+	movedata(S_selVideo, (((iRow - 1) * Columns) << 1) + iColumn,
+		S_selVideo, ((iRow * Columns) << 1) + iColumn,
+		(S_iRight - S_iLeft + 1) << 1);
+
+    /* Clear the new row */
+    setblankbuffer(S_uiAttribute | ' ');
+
+    _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
+			 + (S_iTop - 1) * (Columns << 1) + iColumn);
+}
+
+/*
+ * Scroll the screen one line up, clear the last line.
+ */
+    static void
+myscroll(void)
+{
+    short		iRow, iColumn;
+
+    iColumn = (S_iLeft - 1) << 1;
+
+    /* Copy the screen */
+    for (iRow = S_iTop; iRow < S_iBottom; iRow++)
+	movedata(S_selVideo, ((iRow * Columns) << 1) + iColumn,
+		S_selVideo, (((iRow - 1) * Columns) << 1) + iColumn,
+		(S_iRight - S_iLeft + 1) << 1);
+
+    /* Clear the bottom row */
+    setblankbuffer(S_uiAttribute | ' ');
+
+    _dosmemputw(S_blankbuffer, (S_iRight - S_iLeft) + 1, S_ulScreenBase
+			 + (S_iBottom - 1) * (Columns << 1) + iColumn);
+}
+
+    static int
+myputch(int iChar)
+{
+    unsigned short uiValue;
+
+    if (iChar == '\n')
+    {
+	myflush();
+	if (S_iCurrentRow >= S_iBottom - S_iTop)
+	    myscroll();
+	else
+	{
+	    S_iCurrentColumn = S_iLeft - 1;
+	    S_iCurrentRow++;
+	}
+    }
+    else if (iChar == '\r')
+    {
+	myflush();
+	S_iCurrentColumn = S_iLeft - 1;
+    }
+    else if (iChar == '\b')
+    {
+	myflush();
+	if (S_iCurrentColumn >= S_iLeft)
+	    S_iCurrentColumn--;
+    }
+    else if (iChar == 7)
+    {
+	sound(440);	/* short beep */
+	delay(200);
+	nosound();
+    }
+    else
+    {
+	uiValue = S_uiAttribute | (unsigned char)iChar;
+
+	/*
+	 * Normal char - are we starting to buffer?
+	 */
+	if (S_linebufferpos == S_linebuffer)
+	{
+	    S_iBufferColumn = S_iCurrentColumn;
+	    S_iBufferRow = S_iCurrentRow;
+	}
+
+	*S_linebufferpos++ = uiValue;
+
+	S_iCurrentColumn++;
+	if (S_iCurrentColumn >= S_iRight && S_iCurrentRow >= S_iBottom - S_iTop)
+	{
+	    myflush();
+	    myscroll();
+	    S_iCurrentColumn = S_iLeft - 1;
+	    S_iCurrentRow++;
+	}
+    }
+
+    return 0;
+}
+
+    static void
+mytextinit(struct text_info *pTextinfo)
+{
+    S_selVideo = __dpmi_segment_to_descriptor(S_ulScreenBase >> 4);
+    S_uiAttribute = pTextinfo->normattr << 8;
+}
+
+    static void
+get_screenbase(void)
+{
+    static union REGS	    regs;
+
+    /* old Hercules grafic card has different base address (Macewicz) */
+    regs.h.ah = 0x0f;
+    (void)int86(0x10, &regs, &regs);	/* int 10 0f */
+    if (regs.h.al == 0x07)		/* video mode 7 -- hercules mono */
+	S_ulScreenBase = 0xb0000;
+    else
+	S_ulScreenBase = 0xb8000;
+}
+
+    static void
+mytextattr(int iAttribute)
+{
+    S_uiAttribute = (unsigned short)iAttribute << 8;
+}
+
+    static void
+mynormvideo(void)
+{
+    mytextattr(orig_attr);
+}
+
+    static void
+mytextcolor(int iTextColor)
+{
+    S_uiAttribute = (unsigned short)((S_uiAttribute & 0xf000)
+					   | (unsigned short)iTextColor << 8);
+}
+
+    static void
+mytextbackground(int iBkgColor)
+{
+    S_uiAttribute = (unsigned short)((S_uiAttribute & 0x0f00)
+					 | (unsigned short)(iBkgColor << 12));
+}
+/*
+ * Getdigits: Get a number from a string and skip over it.
+ * Note: the argument is a pointer to a char_u pointer!
+ */
+
+    static long
+mygetdigits(pp)
+    char_u **pp;
+{
+    char_u	*p;
+    long	retval = 0;
+
+    p = *pp;
+    if (*p == '-')		/* skip negative sign */
+	++p;
+    while (VIM_ISDIGIT(*p))
+    {
+	retval = (retval * 10) + (*p - '0');
+	++p;
+    }
+    if (**pp == '-')		/* process negative sign */
+	retval = -retval;
+
+    *pp = p;
+    return retval;
+}
+#else
+# define mygotoxy gotoxy
+# define myputch putch
+# define myscroll scroll
+# define mynormvideo normvideo
+# define mytextattr textattr
+# define mytextcolor textcolor
+# define mytextbackground textbackground
+# define mygetdigits getdigits
+# define myclreol clreol
+# define myclrscr clrscr
+# define myinsline insline
+# define mydelline delline
+#endif
+
+static const struct
+{
+    char_u	scancode;
+    char_u	metakey;
+} altkey_table[] =
+{
+    {0x1e, 0xe1}, /* a */
+    {0x30, 0xe2}, /* b */
+    {0x2e, 0xe3}, /* c */
+    {0x20, 0xe4}, /* d */
+    {0x12, 0xe5}, /* e */
+    {0x21, 0xe6}, /* f */
+    {0x22, 0xe7}, /* g */
+    {0x23, 0xe8}, /* h */
+    {0x17, 0xe9}, /* i */
+    {0x24, 0xea}, /* j */
+    {0x25, 0xeb}, /* k */
+    {0x26, 0xec}, /* l */
+    {0x32, 0xed}, /* m */
+    {0x31, 0xee}, /* n */
+    {0x18, 0xef}, /* o */
+    {0x19, 0xf0}, /* p */
+    {0x10, 0xf1}, /* q */
+    {0x13, 0xf2}, /* r */
+    {0x1f, 0xf3}, /* s */
+    {0x14, 0xf4}, /* t */
+    {0x16, 0xf5}, /* u */
+    {0x2f, 0xf6}, /* v */
+    {0x11, 0xf7}, /* w */
+    {0x2d, 0xf8}, /* x */
+    {0x15, 0xf9}, /* y */
+    {0x2c, 0xfa}, /* z */
+    {0x78, 0xb1}, /* 1 */
+    {0x79, 0xb2}, /* 2 */
+    {0x7a, 0xb3}, /* 3 */
+    {0x7b, 0xb4}, /* 4 */
+    {0x7c, 0xb5}, /* 5 */
+    {0x7d, 0xb6}, /* 6 */
+    {0x7e, 0xb7}, /* 7 */
+    {0x7f, 0xb8}, /* 8 */
+    {0x80, 0xb9}, /* 9 */
+    {0x81, 0xb0}, /* 0 */
+};
+
+/*
+ * Translate extended keycodes into meta-chars where applicable
+ */
+    static int
+translate_altkeys(int rawkey)
+{
+    int i, c;
+
+    if ((rawkey & 0xff) == 0)
+    {
+	c = (rawkey >> 8);
+	for (i = sizeof(altkey_table) / sizeof(altkey_table[0]); --i >= 0; )
+	{
+	    if (c == altkey_table[i].scancode)
+		return (int)altkey_table[i].metakey;
+	}
+    }
+    return rawkey;
+}
+
+/*
+ * Set normal fg/bg color, based on T_ME.  Called when t_me has been set.
+ */
+    void
+mch_set_normal_colors()
+{
+    char_u	*p;
+    int		n;
+
+    cterm_normal_fg_color = (orig_attr & 0xf) + 1;
+    cterm_normal_bg_color = ((orig_attr >> 4) & 0xf) + 1;
+    if (T_ME[0] == ESC && T_ME[1] == '|')
+    {
+	p = T_ME + 2;
+	n = getdigits(&p);
+	if (*p == 'm' && n > 0)
+	{
+	    cterm_normal_fg_color = (n & 0xf) + 1;
+	    cterm_normal_bg_color = ((n >> 4) & 0xf) + 1;
+	}
+    }
+}
+
+#if defined(MCH_CURSOR_SHAPE) || defined(PROTO)
+/*
+ * Save/restore the shape of the cursor.
+ * call with FALSE to save, TRUE to restore
+ */
+    static void
+mch_restore_cursor_shape(int restore)
+{
+    static union REGS	    regs;
+    static int		    saved = FALSE;
+
+    if (restore)
+    {
+	if (saved)
+	    regs.h.ah = 0x01;	    /* Set Cursor */
+	else
+	    return;
+    }
+    else
+    {
+	regs.h.ah = 0x03;	    /* Get Cursor */
+	regs.h.bh = 0x00;	    /* Page */
+	saved = TRUE;
+    }
+
+    (void)int86(0x10, &regs, &regs);
+}
+
+/*
+ * Set the shape of the cursor.
+ * 'thickness' can be from 0 (thin) to 7 (block)
+ */
+    static void
+mch_set_cursor_shape(int thickness)
+{
+    union REGS	    regs;
+
+    regs.h.ch = 7 - thickness;	    /* Starting Line */
+    regs.h.cl = 7;		    /* Ending Line */
+    regs.h.ah = 0x01;		    /* Set Cursor */
+    (void)int86(0x10, &regs, &regs);
+}
+
+    void
+mch_update_cursor(void)
+{
+    int		idx;
+    int		thickness;
+
+    /*
+     * How the cursor is drawn depends on the current mode.
+     */
+    idx = get_shape_idx(FALSE);
+
+    if (shape_table[idx].shape == SHAPE_BLOCK)
+	thickness = 7;
+    else
+	thickness = (7 * shape_table[idx].percentage + 90) / 100;
+    mch_set_cursor_shape(thickness);
+}
+#endif
+
+/*
+ * Return amount of memory currently available in Kbyte.
+ */
+    long_u
+mch_avail_mem(int special)
+{
+#ifdef DJGPP
+    return _go32_dpmi_remaining_virtual_memory() >> 10;
+#else
+    return coreleft() >> 10;
+#endif
+}
+
+#ifdef FEAT_MOUSE
+
+/*
+ * Set area where mouse can be moved to: The whole screen.
+ * Rows and Columns must be valid when calling!
+ */
+    static void
+mouse_area(void)
+{
+    union REGS	    regs;
+
+    if (mouse_avail)
+    {
+	regs.x.cx = 0;	/* mouse visible between cx and dx */
+	regs.x.dx = Columns * mouse_x_div - 1;
+	regs.x.ax = 7;
+	(void)int86(0x33, &regs, &regs);
+
+	regs.x.cx = 0;	/* mouse visible between cx and dx */
+	regs.x.dx = Rows * mouse_y_div - 1;
+	regs.x.ax = 8;
+	(void)int86(0x33, &regs, &regs);
+    }
+}
+
+    static void
+show_mouse(int on)
+{
+    static int	    was_on = FALSE;
+    union REGS	    regs;
+
+    if (mouse_avail)
+    {
+	if (!mouse_active || mouse_hidden)
+	    on = FALSE;
+	/*
+	 * Careful: Each switch on must be compensated by exactly one switch
+	 * off
+	 */
+	if ((on && !was_on) || (!on && was_on))
+	{
+	    was_on = on;
+	    regs.x.ax = on ? 1 : 2;
+	    int86(0x33, &regs, &regs);	/* show mouse */
+	    if (on)
+		mouse_area();
+	}
+    }
+}
+
+#endif
+
+/*
+ * Version of kbhit() and getch() that use direct console I/O.
+ * This avoids trouble with CTRL-P and the like, and should work over a telnet
+ * connection (it works for Xvi).
+ */
+
+static int cons_key = -1;
+
+/*
+ * Try to get one character directly from the console.
+ * If there is a key, it is stored in cons_key.
+ * Only call when cons_key is -1!
+ */
+    static void
+cons_getkey(void)
+{
+    union REGS regs;
+
+    /* call DOS function 6: Direct console I/O */
+    regs.h.ah = 0x06;
+    regs.h.dl = 0xff;
+    (void)intdos(&regs, &regs);
+    if ((regs.x.flags & 0x40) == 0)	/* zero flag not set? */
+	cons_key = (regs.h.al & 0xff);
+}
+
+/*
+ * Return TRUE if a character is available.
+ */
+    static int
+cons_kbhit(void)
+{
+    if (cons_key < 0)
+	cons_getkey();
+    return (cons_key >= 0);
+}
+
+/*
+ * Return a character from the console.
+ * Should only be called when vim_kbhit() returns TRUE.
+ */
+    static int
+cons_getch(void)
+{
+    int	    c = -1;
+
+    if (cons_key < 0)
+	cons_getkey();
+    c = cons_key;
+    cons_key = -1;
+    return c;
+}
+
+
+#ifdef DJGPP
+/*
+ * DJGPP provides a kbhit() function that goes to the BIOS instead of DOS.
+ * This doesn't work for terminals connected to a serial port.
+ * Redefine kbhit() here to make it work.
+ */
+    static int
+vim_kbhit(void)
+{
+    union REGS regs;
+
+    regs.h.ah = 0x0b;
+    (void)intdos(&regs, &regs);
+    return regs.h.al;
+}
+
+#ifdef kbhit
+# undef kbhit	    /* might have been defined in conio.h */
+#endif
+#define kbhit()	vim_kbhit()
+
+#endif
+
+/*
+ * Simulate WaitForChar() by slowly polling with bioskey(1) or kbhit().
+ *
+ * If Vim should work over the serial line after a 'ctty com1' we must use
+ * kbhit() and getch(). (jw)
+ * Usually kbhit() is not used, because then CTRL-C and CTRL-P
+ * will be caught by DOS (mool).
+ *
+ * return TRUE if a character is available, FALSE otherwise
+ */
+
+#define FOREVER 1999999999L
+
+    static  int
+WaitForChar(long msec)
+{
+    long	starttime = 0;
+
+    if (msec != 0)
+	starttime = biostime(0, 0L);
+
+    for (;;)
+    {
+#ifdef FEAT_MOUSE
+	long		clicktime;
+	static int	old_status = 0;
+	union REGS	regs;
+	int		x, y;
+
+	if (mouse_avail && mouse_active && mouse_click < 0)
+	{
+	    regs.x.ax = 3;
+	    int86(0x33, &regs, &regs);	    /* check mouse status */
+		/* only recognize button-down and button-up event */
+	    x = regs.x.cx / mouse_x_div;
+	    y = regs.x.dx / mouse_y_div;
+	    if ((old_status == 0) != (regs.x.bx == 0))
+	    {
+		if (old_status)	/* button up */
+		    mouse_click = MOUSE_RELEASE;
+		else			/* button down */
+		{
+		    /*
+		     * Translate MSDOS mouse events to Vim mouse events.
+		     * TODO: should handle middle mouse button, by pressing
+		     * left and right at the same time.
+		     */
+		    if (regs.x.bx & MSDOS_MOUSE_LEFT)
+			mouse_click = MOUSE_LEFT;
+		    else if (regs.x.bx & MSDOS_MOUSE_RIGHT)
+			mouse_click = MOUSE_RIGHT;
+		    else if (regs.x.bx & MSDOS_MOUSE_MIDDLE)
+			mouse_click = MOUSE_MIDDLE;
+
+		    /*
+		     * Find out if this is a multi-click
+		     */
+		    clicktime = biostime(0, 0L);
+		    if (mouse_click_x == x && mouse_click_y == y
+			    && mouse_topline == curwin->w_topline
+#ifdef FEAT_DIFF
+			    && mouse_topfill == curwin->w_topfill
+#endif
+			    && mouse_click_count != 4
+			    && mouse_click == mouse_last_click
+			    && clicktime < mouse_click_time
+							+ p_mouset / BIOSTICK)
+			++mouse_click_count;
+		    else
+			mouse_click_count = 1;
+		    mouse_click_time = clicktime;
+		    mouse_last_click = mouse_click;
+		    mouse_click_x = x;
+		    mouse_click_y = y;
+		    mouse_topline = curwin->w_topline;
+#ifdef FEAT_DIFF
+		    mouse_topfill = curwin->w_topfill;
+#endif
+		    SET_NUM_MOUSE_CLICKS(mouse_click, mouse_click_count);
+		}
+	    }
+	    else if (old_status && (x != mouse_x || y != mouse_y))
+		mouse_click = MOUSE_DRAG;
+	    old_status = regs.x.bx;
+	    if (mouse_hidden && mouse_x >= 0 && (mouse_x != x || mouse_y != y))
+	    {
+		mouse_hidden = FALSE;
+		show_mouse(TRUE);
+	    }
+	    mouse_x = x;
+	    mouse_y = y;
+	}
+#endif
+
+	if ((p_consk ? cons_kbhit()
+				 : p_biosk ? bioskey(bioskey_ready) : kbhit())
+		|| cbrk_pressed
+#ifdef FEAT_MOUSE
+						    || mouse_click >= 0
+#endif
+		)
+	    return TRUE;
+	/*
+	 * Use biostime() to wait until our time is done.
+	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
+	 * reported to give problems with the original Windows 95.  This is
+	 * fixed in service pack 1, but not everybody installed that.
+	 * The DJGPP implementation of usleep() uses a busy-wait loop too.
+	 */
+	if (msec == 0 || (msec != FOREVER
+			    && biostime(0, 0L) > starttime + msec / BIOSTICK))
+	    break;
+
+#ifdef DJGPP
+	/* Yield the CPU to the next process. */
+	__dpmi_yield();
+#endif
+    }
+    return FALSE;
+}
+
+/*
+ * don't do anything for about "msec" msec
+ */
+    void
+mch_delay(
+    long	msec,
+    int		ignoreinput)
+{
+    long	starttime;
+
+    if (ignoreinput)
+    {
+	/*
+	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
+	 * reported to give problems with the original Windows 95.  This is
+	 * fixed in service pack 1, but not everybody installed that.
+	 */
+	starttime = biostime(0, 0L);
+	while (biostime(0, 0L) < starttime + msec / BIOSTICK)
+	    ;
+    }
+    else
+	WaitForChar(msec);
+}
+
+/*
+ * mch_write(): write the output buffer to the screen
+ */
+    void
+mch_write(
+    char_u	*s,
+    int		len)
+{
+    char_u	*p;
+    int		row, col;
+
+    if (term_console && full_screen)
+	while (len--)
+	{
+	    /* translate ESC | sequences into bios calls */
+	    if (p_wd)	    /* testing: wait a bit for each char */
+		WaitForChar(p_wd);
+
+	    if (s[0] == '\n')
+#ifdef DJGPP
+	    {
+		myflush();
+		S_iCurrentColumn = S_iLeft - 1;
+	    }
+#else
+		myputch('\r');
+#endif
+	    else if (s[0] == ESC && len > 1 && s[1] == '|')
+	    {
+		switch (s[2])
+		{
+#ifdef DJGPP
+		case 'B':   ScreenVisualBell();
+			    goto got3;
+#endif
+		case 'J':
+#ifdef DJGPP
+			    myflush();
+#endif
+			    myclrscr();
+			    goto got3;
+
+		case 'K':
+#ifdef DJGPP
+			    myflush();
+#endif
+			    myclreol();
+			    goto got3;
+
+		case 'L':
+#ifdef DJGPP
+			    myflush();
+#endif
+			    myinsline();
+			    goto got3;
+
+		case 'M':
+#ifdef DJGPP
+			    myflush();
+#endif
+			    mydelline();
+got3:			    s += 3;
+			    len -= 2;
+			    continue;
+
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':   p = s + 2;
+			    row = mygetdigits(&p);    /* no check for length! */
+			    if (p > s + len)
+				break;
+			    if (*p == ';')
+			    {
+				++p;
+				col = mygetdigits(&p); /* no check for length! */
+				if (p > s + len)
+				    break;
+				if (*p == 'H' || *p == 'r' || *p == 'V')
+				{
+#ifdef DJGPP
+				    myflush();
+#endif
+				    if (*p == 'H')  /* set cursor position */
+					mygotoxy(col, row);
+				    else if (*p == 'V')
+					mywindow(row, S_iTop, col, S_iBottom);
+				    else	    /* set scroll region  */
+					mywindow(S_iLeft, row, S_iRight, col);
+				    len -= p - s;
+				    s = p + 1;
+				    continue;
+				}
+			    }
+			    else if (*p == 'm' || *p == 'f' || *p == 'b')
+			    {
+				if (*p == 'm')	    /* set color */
+				{
+				    if (row == 0)
+					mynormvideo();/* reset color */
+				    else
+					mytextattr(row);
+				}
+				else if (*p == 'f') /* set foreground color */
+				    mytextcolor(row);
+				else		    /* set background color */
+				    mytextbackground(row);
+
+				len -= p - s;
+				s = p + 1;
+				continue;
+			    }
+		}
+	    }
+	    myputch(*s++);
+	}
+    else
+    {
+	write(1, s, (unsigned)len);
+    }
+}
+
+/*
+ * mch_inchar(): low level input function.
+ * Get a characters from the keyboard.
+ * If time == 0 do not wait for characters.
+ * If time == n wait a short time for characters.
+ * If time == -1 wait forever for characters.
+ *
+ * return the number of characters obtained
+ */
+    int
+mch_inchar(
+    char_u	*buf,
+    int		maxlen,
+    long	time,
+    int		tb_change_cnt)
+{
+    int		len = 0;
+    int		c;
+    int		tmp_c;
+    static int	nextchar = 0;	    /* may keep character when maxlen == 1 */
+
+    /*
+     * if we got a ctrl-C when we were busy, there will be a "^C" somewhere
+     * on the screen, so we need to redisplay it.
+     */
+    if (delayed_redraw)
+    {
+	delayed_redraw = FALSE;
+	update_screen(CLEAR);
+	setcursor();
+	out_flush();
+    }
+
+    /* return remaining character from last call */
+    if (nextchar)
+    {
+	*buf = nextchar;
+	nextchar = 0;
+	return 1;
+    }
+
+#ifdef FEAT_MOUSE
+    if (time != 0)
+	show_mouse(TRUE);
+#endif
+#ifdef DJGPP
+    set_sys_cursor();
+#endif
+    if (time >= 0)
+    {
+	if (WaitForChar(time) == 0)	/* no character available */
+	{
+#ifdef FEAT_MOUSE
+	    show_mouse(FALSE);
+#endif
+	    return 0;
+	}
+    }
+    else    /* time == -1 */
+    {
+	/*
+	 * If there is no character available within 2 seconds (default)
+	 * write the autoscript file to disk.  Or cause the CursorHold event
+	 * to be triggered.
+	 */
+	if (WaitForChar(p_ut) == 0)
+	{
+#ifdef FEAT_AUTOCMD
+	    if (trigger_cursorhold() && maxlen >= 3)
+	    {
+		buf[0] = K_SPECIAL;
+		buf[1] = KS_EXTRA;
+		buf[2] = (int)KE_CURSORHOLD;
+		return 3;
+	    }
+#endif
+	    before_blocking();
+	}
+    }
+    WaitForChar(FOREVER);	/* wait for key or mouse click */
+
+/*
+ * Try to read as many characters as there are, until the buffer is full.
+ */
+    /*
+     * we will get at least one key. Get more if they are available
+     * After a ctrl-break we have to read a 0 (!) from the buffer.
+     * bioskey(1) will return 0 if no key is available and when a
+     * ctrl-break was typed. When ctrl-break is hit, this does not always
+     * implies a key hit.
+     */
+    cbrk_pressed = FALSE;
+#ifdef FEAT_MOUSE
+    if (mouse_click >= 0 && maxlen >= 5)
+    {
+	len = 5;
+	*buf++ = ESC + 128;
+	*buf++ = 'M';
+	*buf++ = mouse_click;
+	*buf++ = mouse_x + '!';
+	*buf++ = mouse_y + '!';
+	mouse_click = -1;
+    }
+    else
+#endif
+    {
+#ifdef FEAT_MOUSE
+	mouse_hidden = TRUE;
+#endif
+	if (p_biosk && !p_consk)
+	{
+	    while ((len == 0 || bioskey(bioskey_ready)) && len < maxlen)
+	    {
+		c = translate_altkeys(bioskey(bioskey_read)); /* get the key */
+		/*
+		 * translate a few things for inchar():
+		 * 0x0000 == CTRL-break		-> 3	(CTRL-C)
+		 * 0x0300 == CTRL-@		-> NUL
+		 * 0xnn00 == extended key code	-> K_NUL, nn
+		 * 0xnne0 == enhanced keyboard	-> K_NUL, nn
+		 * K_NUL			-> K_NUL, 3
+		 */
+		if (c == 0)
+		    c = 3;
+		else if (c == 0x0300)
+		    c = NUL;
+		else if ((c & 0xff) == 0
+			|| c == K_NUL
+			|| c == 0x4e2b
+			|| c == 0x4a2d
+			|| c == 0x372a
+			|| ((c & 0xff) == 0xe0 && c != 0xe0))
+		{
+		    if (c == K_NUL)
+			c = 3;
+		    else
+			c >>= 8;
+		    *buf++ = K_NUL;
+		    ++len;
+		}
+
+		if (len < maxlen)
+		{
+		    *buf++ = c;
+		    len++;
+#ifdef FEAT_MBYTE
+		    /* Convert from 'termencoding' to 'encoding'. Only
+		     * translate normal characters, not key codes. */
+		    if (input_conv.vc_type != CONV_NONE
+					    && (len == 1 || buf[-2] != K_NUL))
+			len += convert_input(buf - 1, 1, maxlen - len + 1) - 1;
+#endif
+		}
+		else
+		    nextchar = c;
+	    }
+	}
+	else
+	{
+	    while ((len == 0 || (p_consk ? cons_kbhit() : kbhit()))
+		    && len < maxlen)
+	    {
+		switch (c = (p_consk ? cons_getch() : getch()))
+		{
+		    case 0:
+			/* NUL means that there is another character.
+			 * Get it immediately, because kbhit() doesn't always
+			 * return TRUE for the second character.
+			 */
+			if (p_consk)
+			    c = cons_getch();
+			else
+			    c = getch();
+			tmp_c = translate_altkeys(c << 8);
+			if (tmp_c == (c << 8))
+			{
+			    *buf++ = K_NUL;
+			    ++len;
+			}
+			else
+			    c = tmp_c;
+			break;
+		    case K_NUL:
+			*buf++ = K_NUL;
+			++len;
+			c = 3;
+			break;
+		    case 3:
+			cbrk_pressed = TRUE;
+			/*FALLTHROUGH*/
+		    default:
+			break;
+		}
+		if (len < maxlen)
+		{
+		    *buf++ = c;
+		    ++len;
+		}
+		else
+		    nextchar = c;
+	    }
+	}
+    }
+#ifdef FEAT_MOUSE
+    show_mouse(FALSE);
+#endif
+
+    beep_count = 0;	    /* may beep again now that we got some chars */
+    return len;
+}
+
+/*
+ * return non-zero if a character is available
+ */
+    int
+mch_char_avail(void)
+{
+    return WaitForChar(0L);
+}
+
+#ifdef DJGPP
+# define INT_ARG    int
+#else
+# define INT_ARG
+#endif
+
+/*
+ * function for ctrl-break interrupt
+ */
+    static void interrupt
+#ifdef DJGPP
+catch_cbrk(int a)
+#else
+catch_cbrk(void)
+#endif
+{
+    cbrk_pressed = TRUE;
+    ctrlc_pressed = TRUE;
+}
+
+#ifndef DJGPP
+/*
+ * ctrl-break handler for DOS. Never called when a ctrl-break is typed, because
+ * we catch interrupt 1b. If you type ctrl-C while Vim is waiting for a
+ * character this function is not called. When a ctrl-C is typed while Vim is
+ * busy this function may be called. By that time a ^C has been displayed on
+ * the screen, so we have to redisplay the screen. We can't do that here,
+ * because we may be called by DOS. The redraw is in mch_inchar().
+ */
+    static int _cdecl
+cbrk_handler(void)
+{
+    delayed_redraw = TRUE;
+    return 1;		    /* resume operation after ctrl-break */
+}
+
+/*
+ * function for critical error interrupt
+ * For DOS 1 and 2 return 0 (Ignore).
+ * For DOS 3 and later return 3 (Fail)
+ */
+    static void interrupt
+catch_cint(bp, di, si, ds, es, dx, cx, bx, ax)
+    unsigned bp, di, si, ds, es, dx, cx, bx, ax;
+{
+    ax = (ax & 0xff00);	    /* set AL to 0 */
+    if (_osmajor >= 3)
+	ax |= 3;	    /* set AL to 3 */
+}
+#endif
+
+/*
+ * Set the interrupt vectors for use with Vim on or off.
+ * on == TRUE means as used within Vim
+ */
+    static void
+set_interrupts(int on)
+{
+    static int saved_cbrk;
+#ifndef DJGPP
+    static void interrupt (*old_cint)();
+#endif
+    static void interrupt (*old_cbrk)(INT_ARG);
+
+    if (on)
+    {
+	saved_cbrk = getcbrk();		/* save old ctrl-break setting */
+	setcbrk(0);			/* do not check for ctrl-break */
+#ifdef DJGPP
+	old_cbrk = signal(SIGINT, catch_cbrk);	/* critical error interrupt */
+#else
+	old_cint = getvect(0x24);	/* save old critical error interrupt */
+	setvect(0x24, catch_cint);	/* install our critical error interrupt */
+	old_cbrk = getvect(0x1B);	/* save old ctrl-break interrupt */
+	setvect(0x1B, catch_cbrk);	/* install our ctrl-break interrupt */
+	ctrlbrk(cbrk_handler);		/* vim's ctrl-break handler */
+#endif
+	if (term_console)
+	    out_str(T_ME);		/* set colors */
+    }
+    else
+    {
+	setcbrk(saved_cbrk);		/* restore ctrl-break setting */
+#ifdef DJGPP
+	signal(SIGINT,old_cbrk);	/* critical error interrupt */
+#else
+	setvect(0x24, old_cint);	/* restore critical error interrupt */
+	setvect(0x1B, old_cbrk);	/* restore ctrl-break interrupt */
+#endif
+	/* restore ctrl-break handler, how ??? */
+	if (term_console)
+	    mynormvideo();		/* restore screen colors */
+    }
+}
+
+/*
+ * We have no job control, fake it by starting a new shell.
+ */
+    void
+mch_suspend(void)
+{
+    suspend_shell();
+}
+
+extern int _fmode;
+
+/*
+ * Prepare window for use by Vim.
+ */
+    void
+mch_init(void)
+{
+    union REGS regs;
+
+#if defined(DJGPP) && defined(FEAT_CLIPBOARD)
+    __dpmi_regs  dpmi_regs;
+#endif
+
+    /*
+     * Get the video attributes at the cursor.  These will be used as the
+     * default attributes.
+     */
+    regs.h.ah = 0x08;
+    regs.h.bh = 0x00;		/* video page 0 */
+    int86(0x10, &regs, &regs);
+    orig_attr = regs.h.ah;
+    mynormvideo();
+    if (cterm_normal_fg_color == 0)
+	cterm_normal_fg_color = (orig_attr & 0xf) + 1;
+    if (cterm_normal_bg_color == 0)
+	cterm_normal_bg_color = ((orig_attr >> 4) & 0xf) + 1;
+
+    term_console = TRUE;    /* assume using the console for the things here */
+    _fmode = O_BINARY;	    /* we do our own CR-LF translation */
+    out_flush();
+    set_interrupts(TRUE);   /* catch interrupts */
+
+#ifdef DJGPP
+    /*
+     * Use Long File Names by default, if $LFN not set.
+     */
+    if (getenv("LFN") == NULL)
+	putenv("LFN=y");
+
+    get_screenbase();
+#endif
+
+#ifdef FEAT_MOUSE
+/* find out if a MS compatible mouse is available */
+    regs.x.ax = 0;
+    (void)int86(0x33, &regs, &regs);
+    mouse_avail = regs.x.ax;
+    /* best guess for mouse coordinate computations */
+    mch_get_shellsize();
+    if (Columns <= 40)
+	mouse_x_div = 16;
+    if (Rows == 30)
+	mouse_y_div = 16;
+#endif
+
+    /*
+     * Try switching to 16 colors for background, instead of 8 colors and
+     * blinking.  Does this always work?  Can the old value be restored?
+     */
+    regs.x.ax = 0x1003;
+    regs.h.bl = 0x00;
+    regs.h.bh = 0x00;
+    int86(0x10, &regs, &regs);
+
+    /*
+     * Test if we have an enhanced AT keyboard.  Write 0xFFFF to the keyboard
+     * buffer and try to read it back.  If we can't in 16 tries, it's an old
+     * type XT keyboard.
+     */
+    regs.h.ah = 0x05;
+    regs.x.cx = 0xffff;
+    int86(0x16, &regs, &regs);
+    if (regs.h.al != 1)	/* skip this when keyboard buffer is full */
+    {
+	int i;
+
+	for (i = 0; i < 16; ++i)
+	{
+	    regs.h.ah = 0x10;
+	    int86(0x16, &regs, &regs);
+	    if (regs.x.ax == 0xffff)
+		break;
+	}
+	if (i == 16)	/* 0xffff not read, must be old keyboard */
+	{
+	    bioskey_read = 0;
+	    bioskey_ready = 1;
+	}
+    }
+
+#ifdef MCH_CURSOR_SHAPE
+    /* Save the old cursor shape */
+    mch_restore_cursor_shape(FALSE);
+    /* Initialise the cursor shape */
+    mch_update_cursor();
+#endif
+
+#if defined(DJGPP) && defined(FEAT_CLIPBOARD)
+    /*
+     * Check to see if the Windows clipboard is available, ie. are we
+     * running from a DOS session within Windows.  Obviously, the Windows
+     * clipboard will not be available if we're running under pure DOS.
+     *
+     * int 0x2f, AX = 0x1700 identifies the Windows version we're running
+     * under.  Upon return from the interrupt, if AX is unchanged, we're
+     * running under pure DOS and no Windows clipboard is available.
+     *
+     * Remark: could use int86() here but __dpmi_int() is recommended in
+     * the DJGPP docs, since int86() doesn't cover all available interrupts.
+     */
+    dpmi_regs.x.ax = 0x1700;
+    if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+	/* real-mode interrupt failed? */
+	dpmi_regs.x.ax = 0x1700;	/* force failure */
+
+    if (dpmi_regs.x.ax == 0x1700)	/* no change in AX? */
+	clip_init(FALSE);		/* no clipboard available, too bad */
+    else				/* else, running under Windows, OK */
+	clip_init(TRUE);		/* clipboard is available */
+#endif
+}
+
+    int
+mch_check_win(
+    int		argc,
+    char	**argv)
+{
+    /* store argv[0], may be used for $VIM */
+    if (*argv[0] != NUL)
+	exe_name = FullName_save((char_u *)argv[0], FALSE);
+
+    /*
+     * Try the DOS search path.  The executable may in
+     * fact be called differently, so try this last.
+     */
+    if (exe_name == NULL || *exe_name == NUL)
+	exe_name = searchpath("vim.exe");
+
+    if (isatty(1))
+	return OK;
+    return FAIL;
+}
+
+/*
+ * Return TRUE if the input comes from a terminal, FALSE otherwise.
+ */
+    int
+mch_input_isatty(void)
+{
+    if (isatty(read_cmd_fd))
+	return TRUE;
+    return FALSE;
+}
+
+#if defined(USE_FNAME_CASE) || defined(PROTO)
+/*
+ * fname_case(): Set the case of the file name, if it already exists.
+ * TODO: should expand short to long file names.  Need to use DOS interrupts,
+ * see DJGPP sources libc/dos/dir/findfirs.c.
+ */
+    void
+fname_case(char_u *name, int len)
+{
+    char_u	    *tail;
+    struct ffblk    fb;
+
+    slash_adjust(name);
+    if (findfirst(name, &fb, 0) == 0)
+    {
+	tail = gettail(name);
+	if (len == 0 ? STRLEN(tail) == STRLEN(fb.ff_name)
+		: (tail - name) + STRLEN(fb.ff_name) < len)
+	    STRCPY(tail, fb.ff_name);
+    }
+}
+#endif
+
+/*
+ * return process ID
+ */
+    long
+mch_get_pid(void)
+{
+    return (long)0;
+}
+
+/*
+ * Change default drive (just like _chdrive of Borland C 3.1)
+ */
+    static int
+change_drive(int drive)
+{
+    union REGS regs;
+
+    regs.h.ah = 0x0e;
+    regs.h.dl = drive - 1;
+    intdos(&regs, &regs);   /* set default drive */
+    regs.h.ah = 0x19;
+    intdos(&regs, &regs);   /* get default drive */
+    if (regs.h.al == drive - 1)
+	return 0;
+    return -1;
+}
+
+/*
+ * Get absolute file name into buffer 'buf' of length 'len' bytes.
+ * All slashes are replaced with backslashes, to avoid trouble when comparing
+ * file names.  When 'shellslash' set do it the other way around.
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+mch_FullName(
+    char_u	*fname,
+    char_u	*buf,
+    int		len,
+    int		force)
+{
+    if (!force && mch_isFullName(fname))	/* already expanded */
+    {
+	vim_strncpy(buf, fname, len - 1);
+	slash_adjust(buf);
+	return OK;
+    }
+
+#ifdef __BORLANDC__		/* Only Borland C++ has this */
+    if (_fullpath((char *)buf, (char *)fname, len - 1) == NULL)
+	return FAIL;
+    return OK;
+#else			/* almost the same as mch_FullName() in os_unix.c */
+    {
+# if 1
+	char_u	fullpath[MAXPATHL];
+
+	if (!_truename(fname, fullpath))
+	    return FAIL;
+	slash_adjust(fullpath);	    /* Only needed when 'shellslash' set */
+	vim_strncpy(buf, fullpath, len - 1);
+	return OK;
+
+# else  /* Old code, to be deleted... */
+	int	l;
+	char_u	olddir[MAXPATHL];
+	char_u	*p, *q;
+	int	c;
+	int	retval = OK;
+
+	*buf = 0;
+	/*
+	 * change to the directory for a moment,
+	 * and then do the getwd() (and get back to where we were).
+	 * This will get the correct path name with "../" things.
+	 */
+	p = vim_strrchr(fname, '/');
+	q = vim_strrchr(fname, '\\');
+	if (q != NULL && (p == NULL || q > p))
+	    p = q;
+	q = vim_strrchr(fname, ':');
+	if (q != NULL && (p == NULL || q > p))
+	    p = q;
+	if (p != NULL)
+	{
+	    if (getcwd(olddir, MAXPATHL) == NULL)
+	    {
+		p = NULL;	/* can't get current dir: don't chdir */
+		retval = FAIL;
+	    }
+	    else
+	    {
+		if (p == fname)			/* /fname	    */
+		    q = p + 1;			/* -> /		    */
+		else if (q + 1 == p)		/* ... c:\foo	    */
+		    q = p + 1;			/* -> c:\	    */
+		else				/* but c:\foo\bar   */
+		    q = p;			/* -> c:\foo	    */
+
+		c = *q;			/* truncate at start of fname */
+		*q = NUL;
+# ifdef DJGPP
+		STRCPY(buf, fname);
+		slash_adjust(buf);	/* needed when fname starts with \ */
+		if (mch_chdir(buf))	/* change to the directory */
+# else
+		if (mch_chdir(fname))	/* change to the directory */
+# endif
+		    retval = FAIL;
+		else
+		{
+		    fname = q;
+		    if (c == psepc)	    /* if we cut the name at a */
+			fname++;	    /* '\', don't add it again */
+		}
+		*q = c;
+	    }
+	}
+	if (getcwd(buf, len) == NULL)
+	{
+	    retval = FAIL;
+	    *buf = NUL;
+	}
+#  ifdef USE_FNAME_CASE
+	else
+	{
+	    char_u	*head;
+	    char_u	*tail;
+	    struct ffblk fb;
+	    int		c;
+	    int		added;
+
+	    /* Apparently "longna~1" isn't expanded by getcwd(), at least not
+	     * for DJGPP.  Expand it here.  Have to do each dirname
+	     * separately. */
+	    slash_adjust(buf);
+	    head = buf;
+	    if (isalpha(*head) && head[1] == ':')
+		head += 2;	/* skip "c:" */
+	    while (*head != NUL)
+	    {
+		/* Advance "head" to the start of a dirname and "tail" to just
+		 * after it. */
+		while (*head == '/' || *head == '\\')
+		    ++head;
+		for (tail = head; *tail != NUL; ++tail)
+		    if (*tail == '/' || *tail == '\\')
+			break;
+		c = *tail;
+		*tail = NUL;
+
+		if (findfirst(buf, &fb, FA_DIREC) == 0)
+		{
+		    added = STRLEN(fb.ff_name);
+		    if ((head - buf) + added + STRLEN(tail + 1) + 2 < len)
+		    {
+			added -= (tail - head);
+			if (added != 0)
+			    STRMOVE(tail + 1 + added, tail + 1);
+			STRCPY(head, fb.ff_name);
+			tail += added;
+		    }
+		}
+		*tail = c;
+		head = tail;
+	    }
+	}
+#  endif
+	if (p != NULL)
+	    mch_chdir(olddir);
+	/*
+	 * Concatenate the file name to the path.
+	 */
+	if (*fname != NUL)
+	{
+	    l = STRLEN(buf);
+	    if (l > 0 && buf[l - 1] != '/' && buf[l - 1] != '\\')
+		strcat(buf, pseps);
+	    strcat(buf, fname);
+	}
+	return retval;
+# endif
+    }
+#endif
+}
+
+/*
+ * Replace all slashes by backslashes.
+ * This used to be the other way around, but MS-DOS sometimes has problems
+ * with slashes (e.g. in a command name).  We can't have mixed slashes and
+ * backslashes, because comparing file names will not work correctly.  The
+ * commands that use a file name should try to avoid the need to type a
+ * backslash twice.
+ * When 'shellslash' set do it the other way around.
+ */
+    void
+slash_adjust(char_u *p)
+{
+#ifdef OLD_DJGPP    /* this seems to have been fixed in DJGPP 2.01 */
+    /* DJGPP can't handle a file name that starts with a backslash, and when it
+     * starts with a slash there should be no backslashes */
+    if (*p == '\\' || *p == '/')
+	while (*p)
+	{
+	    if (*p == '\\')
+		*p = '/';
+	    mb_ptr_adv(p);
+	}
+    else
+#endif
+    while (*p)
+    {
+	if (*p == psepcN)
+	    *p = psepc;
+	mb_ptr_adv(p);
+    }
+}
+
+/*
+ * Return TRUE if "fname" does not depend on the current directory.
+ */
+    int
+mch_isFullName(char_u *fname)
+{
+    /* A name like "d:/foo" and "//server/share" is absolute */
+    return (fname[0] != NUL && fname[1] == ':'
+				     && (fname[2] == '/' || fname[2] == '\\'))
+	|| (fname[0] == fname[1] && (fname[0] == '/' || fname[0] == '\\'));
+}
+
+
+    void
+mch_early_init(void)
+{
+}
+
+/*
+ * Careful: mch_exit() may be called before mch_init()!
+ */
+    void
+mch_exit(int r)
+{
+    settmode(TMODE_COOK);
+    stoptermcap();
+    set_interrupts(FALSE);	    /* restore interrupts */
+#ifdef DJGPP
+    set_sys_cursor();
+#endif
+    /* Somehow outputting CR-NL causes the original colors to be restored */
+    out_char('\r');
+    out_char('\n');
+    out_flush();
+    ml_close_all(TRUE);		    /* remove all memfiles */
+#ifdef MCH_CURSOR_SHAPE
+    mch_restore_cursor_shape(TRUE);
+#endif
+    exit(r);
+}
+
+/*
+ * set the tty in (raw) ? "raw" : "cooked" mode
+ * Does not change the tty, as bioskey() and kbhit() work raw all the time.
+ */
+    void
+mch_settmode(int tmode)
+{
+}
+
+#ifdef FEAT_MOUSE
+    void
+mch_setmouse(int on)
+{
+    mouse_active = on;
+    mouse_hidden = TRUE;	/* don't show it until moved */
+}
+#endif
+
+/*
+ * set screen mode
+ * return FAIL for failure, OK otherwise
+ */
+    int
+mch_screenmode(char_u *arg)
+{
+    int		    mode;
+    int		    i;
+    static char	   *(names[]) = {"BW40", "C40", "BW80", "C80", "MONO", "C4350"};
+    static int	    modes[]   = { BW40,	  C40,	 BW80,	 C80,	MONO,	C4350};
+
+    mode = -1;
+    if (VIM_ISDIGIT(*arg))		    /* mode number given */
+	mode = atoi((char *)arg);
+    else
+    {
+	for (i = 0; i < sizeof(names) / sizeof(char_u *); ++i)
+	    if (stricmp(names[i], (char *)arg) == 0)
+	    {
+		mode = modes[i];
+		break;
+	    }
+    }
+    if (mode == -1)
+    {
+	EMSG("E362: Unsupported screen mode");
+	return FAIL;
+    }
+    textmode(mode);		    /* use Borland function */
+#ifdef DJGPP
+    /* base address may have changed */
+    get_screenbase();
+#endif
+
+    /* Screen colors may have changed. */
+    out_str(T_ME);
+
+#ifdef FEAT_MOUSE
+    if (mode <= 1 || mode == 4 || mode == 5 || mode == 13 || mode == 0x13)
+	mouse_x_div = 16;
+    else
+	mouse_x_div = 8;
+    if (mode == 0x11 || mode == 0x12)
+	mouse_y_div = 16;
+    else if (mode == 0x10)
+	mouse_y_div = 14;
+    else
+	mouse_y_div = 8;
+    shell_resized();
+#endif
+    return OK;
+}
+
+/*
+ * Structure used by Turbo-C/Borland-C to store video parameters.
+ */
+#ifndef DJGPP
+extern struct text_info _video;
+#endif
+
+/*
+ * try to get the real window size
+ * return FAIL for failure, OK otherwise
+ */
+    int
+mch_get_shellsize(void)
+{
+    struct text_info textinfo;
+
+    /*
+     * The screenwidth is returned by the BIOS OK.
+     * The screenheight is in a location in the bios RAM, if the display is
+     * EGA or VGA.
+     */
+    if (!term_console)
+	return FAIL;
+    gettextinfo(&textinfo);
+    Columns = textinfo.screenwidth;
+    Rows = textinfo.screenheight;
+#ifndef DJGPP
+    if (textinfo.currmode > 10)
+	Rows = *(char far *)MK_FP(0x40, 0x84) + 1;
+#endif
+
+    if (Columns < MIN_COLUMNS || Rows < MIN_LINES)
+    {
+	/* these values are overwritten by termcap size or default */
+	Columns = 80;
+	Rows = 25;
+	return FAIL;
+    }
+#ifdef DJGPP
+    mytextinit(&textinfo);   /* Added by JML, 1/15/98 */
+#endif
+
+    return OK;
+}
+
+/*
+ * Set the active window for delline/insline.
+ */
+    static void
+set_window(void)
+{
+    if (term_console)
+    {
+#ifndef DJGPP
+	_video.screenheight = Rows;
+#endif
+	mywindow(1, 1, Columns, Rows);
+    }
+    screen_start();
+}
+
+    void
+mch_set_shellsize(void)
+{
+    /* Should try to set the window size to Rows and Columns.
+     * May involve switching display mode....
+     * We assume the user knows the size and just use it. */
+}
+
+/*
+ * Rows and/or Columns has changed.
+ */
+    void
+mch_new_shellsize()
+{
+#ifdef FEAT_MOUSE
+    /* best guess for mouse coordinate computations */
+    if (Columns <= 40)
+	mouse_x_div = 16;
+    if (Rows == 30)
+	mouse_y_div = 16;
+#endif
+    set_window();
+#ifdef FEAT_MOUSE
+    mouse_area();	/* set area where mouse can go */
+#endif
+}
+
+#if defined(DJGPP) || defined(PROTO)
+/*
+ * Check the number of Columns with a BIOS call.  This avoids a crash of the
+ * DOS console when 'columns' is set to a too large value.
+ */
+    void
+mch_check_columns()
+{
+    static union REGS	regs;
+
+    regs.h.ah = 0x0f;
+    (void)int86(0x10, &regs, &regs);
+    if ((unsigned)Columns > (unsigned)regs.h.ah)
+	Columns = (unsigned)regs.h.ah;
+}
+#endif
+
+/*
+ * call shell, return FAIL for failure, OK otherwise
+ * options: SHELL_*, see vim.h.
+ */
+    int
+mch_call_shell(
+    char_u	*cmd,
+    int		options)
+{
+    int		x;
+    int		tmode = cur_tmode;
+#ifndef DJGPP
+    char_u	*newcmd;
+#endif
+
+    out_flush();
+#ifdef DJGPP
+    set_sys_cursor();
+#endif
+
+    if (options & SHELL_COOKED)
+	settmode(TMODE_COOK);	/* set to normal mode */
+    set_interrupts(FALSE);	/* restore interrupts */
+
+#ifdef DJGPP
+    /* ignore signals while external command is running */
+    signal(SIGINT, SIG_IGN);
+    signal(SIGHUP, SIG_IGN);
+    signal(SIGQUIT, SIG_IGN);
+    signal(SIGTERM, SIG_IGN);
+#endif
+    if (cmd == NULL)
+	x = system((char *)p_sh);
+    else
+    {
+#ifdef DJGPP
+	/*
+	 * Use 'shell' for system().
+	 */
+	setenv("SHELL", (char *)p_sh, 1);
+	x = system(cmd);
+#else
+	/* we use "command" to start the shell, slow but easy */
+	newcmd = alloc(STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 3);
+	if (newcmd == NULL)
+	    x = -1;
+	else
+	{
+	    sprintf((char *)newcmd, "%s %s %s", p_sh, p_shcf, cmd);
+	    x = system((char *)newcmd);
+	    vim_free(newcmd);
+	}
+#endif
+    }
+#ifdef DJGPP
+    signal(SIGINT, SIG_DFL);
+    signal(SIGHUP, SIG_DFL);
+    signal(SIGQUIT, SIG_DFL);
+    signal(SIGTERM, SIG_DFL);
+#endif
+    if (tmode == TMODE_RAW)
+	settmode(TMODE_RAW);	/* set to raw mode */
+    set_interrupts(TRUE);	/* catch interrupts */
+
+    if (x && !(options & SHELL_SILENT) && !emsg_silent)
+    {
+	MSG_PUTS("\nshell returned ");
+	msg_outnum((long)x);
+	msg_putchar('\n');
+    }
+
+    return x;
+}
+
+/*
+ * check for an "interrupt signal": CTRL-break or CTRL-C
+ */
+    void
+mch_breakcheck(void)
+{
+    if (ctrlc_pressed)
+    {
+	ctrlc_pressed = FALSE;
+	got_int = TRUE;
+    }
+}
+
+/*
+ * Return TRUE if "p" contain a wildcard that can be expanded by
+ * dos_expandpath().
+ */
+    int
+mch_has_exp_wildcard(char_u *p)
+{
+    for ( ; *p; mb_ptr_adv(p))
+    {
+	if (vim_strchr((char_u *)"?*[", *p) != NULL
+		|| (*p == '~' && p[1] != NUL))
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Return TRUE if "p" contain a wildcard or a "~1" kind of thing (could be a
+ * shortened file name).
+ */
+    int
+mch_has_wildcard(char_u *p)
+{
+    for ( ; *p; mb_ptr_adv(p))
+    {
+	if (vim_strchr((char_u *)
+#  ifdef VIM_BACKTICK
+				    "?*$[`"
+#  else
+				    "?*$["
+#  endif
+						, *p) != NULL
+		|| (*p == '~' && p[1] != NUL))
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Change directory to "path".
+ * The normal chdir() does not change the default drive.  This one does.
+ * Return 0 for success, -1 for failure.
+ */
+    int
+mch_chdir(char *path)
+{
+    if (path[0] == NUL)		    /* just checking... */
+	return 0;
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", path);
+	verbose_leave();
+    }
+    if (path[1] == ':')		    /* has a drive name */
+    {
+	if (change_drive(TOLOWER_ASC(path[0]) - 'a' + 1))
+	    return -1;		    /* invalid drive name */
+	path += 2;
+    }
+    if (*path == NUL)		    /* drive name only */
+	return 0;
+    return chdir(path);		    /* let the normal chdir() do the rest */
+}
+
+#ifdef DJGPP
+/*
+ * mch_rename() works around a bug in rename (aka MoveFile) in
+ * Windows 95: rename("foo.bar", "foo.bar~") will generate a
+ * file whose short file name is "FOO.BAR" (its long file name will
+ * be correct: "foo.bar~").  Because a file can be accessed by
+ * either its SFN or its LFN, "foo.bar" has effectively been
+ * renamed to "foo.bar", which is not at all what was wanted.  This
+ * seems to happen only when renaming files with three-character
+ * extensions by appending a suffix that does not include ".".
+ * Windows NT gets it right, however, with an SFN of "FOO~1.BAR".
+ * This works like mch_rename in os_win32.c, but is a bit simpler.
+ *
+ * Like rename(), returns 0 upon success, non-zero upon failure.
+ * Should probably set errno appropriately when errors occur.
+ */
+
+    int
+mch_rename(const char *OldFile, const char *NewFile)
+{
+    char_u  *TempFile;
+    int	    retval;
+    int	    fd;
+
+    /* rename() works correctly without long file names, so use that */
+    if (!_USE_LFN)
+	return rename(OldFile, NewFile);
+
+    if ((TempFile = alloc((unsigned)(STRLEN(OldFile) + 13))) == NULL)
+	return -1;
+
+    STRCPY(TempFile, OldFile);
+    STRCPY(gettail(TempFile), "axlqwqhy.ba~");
+    if (rename(OldFile, TempFile))
+	retval = -1;
+    else
+    {
+	/* now create an empty file called OldFile; this prevents
+	 * the operating system using OldFile as an alias (SFN)
+	 * if we're renaming within the same directory.  For example,
+	 * we're editing a file called filename.asc.txt by its SFN,
+	 * filena~1.txt.  If we rename filena~1.txt to filena~1.txt~
+	 * (i.e., we're making a backup while writing it), the SFN
+	 * for filena~1.txt~ will be filena~1.txt, by default, which
+	 * will cause all sorts of problems later in buf_write().  So, we
+	 * create an empty file called filena~1.txt and the system will have
+	 * to find some other SFN for filena~1.txt~, such as filena~2.txt
+	 */
+	if ((fd = open(OldFile, O_RDWR|O_CREAT|O_EXCL, 0444)) < 0)
+	    return -1;
+	retval = rename(TempFile, NewFile);
+	close(fd);
+	mch_remove((char_u *)OldFile);
+
+	/* If renaming to NewFile failed, rename TempFile back to OldFile, so
+	 * that it looks like nothing happened. */
+	if (retval)
+	    rename(TempFile, OldFile);
+    }
+    vim_free(TempFile);
+
+    return retval;  /* success */
+}
+#endif
+
+#if defined(DJGPP) || defined(PROTO)
+/*
+ * setlocale() for DJGPP with MS-DOS codepage support
+ * Author: Cyril Slobin <slobin@fe.msk.ru>
+ *
+ * Scaled down a lot for use by Vim: Only support setlocale(LC_ALL, "").
+ */
+
+#undef setlocale
+
+#ifndef PROTO
+# include <go32.h>
+# include <inlines/ctype.ha>
+#endif
+#include <locale.h>
+
+#define UPCASE (__dj_ISALNUM | __dj_ISALPHA | __dj_ISGRAPH | __dj_ISPRINT | __dj_ISUPPER)
+#define LOCASE (__dj_ISALNUM | __dj_ISALPHA | __dj_ISGRAPH | __dj_ISPRINT | __dj_ISLOWER)
+
+    char *
+djgpp_setlocale(void)
+{
+    __dpmi_regs regs;
+    struct { char id; unsigned short off, seg; } __attribute__ ((packed)) info;
+    unsigned char buffer[0x82], lower, upper;
+    int i;
+
+    regs.x.ax = 0x6502;
+    regs.x.bx = 0xffff;
+    regs.x.dx = 0xffff;
+    regs.x.cx = 5;
+    regs.x.es = __tb >> 4;
+    regs.x.di = __tb & 0xf;
+
+    __dpmi_int(0x21, &regs);
+
+    if (regs.x.flags & 1)
+	return NULL;
+
+    dosmemget(__tb, 5, &info);
+    dosmemget((info.seg << 4) + info.off, 0x82, buffer);
+
+    if (*(short *)buffer != 0x80)
+	return NULL;
+
+    /* Fix problem of underscores being replaced with y-umlaut. (Levin) */
+    if (buffer[26] == 0x5f)
+	buffer[26] = 0x98;
+
+    for (i = 0; i < 0x80; i++)
+    {
+	lower = i + 0x80;
+	upper = (buffer+2)[i];
+	if (lower != upper)
+	{
+	    __dj_ctype_flags[lower+1] = LOCASE;
+	    __dj_ctype_toupper[lower+1] = upper;
+	    if (__dj_ctype_flags[upper+1] == 0)
+		__dj_ctype_flags[upper+1] = UPCASE;
+	    if (__dj_ctype_tolower[upper+1] == upper)
+		__dj_ctype_tolower[upper+1] = lower;
+	}
+    }
+
+    return "C";
+}
+
+#if defined(FEAT_CLIPBOARD) || defined(PROTO)
+
+/*
+ * Clipboard stuff, for cutting and pasting text to other windows.
+ *
+ * Implementation of DOS/Windows clipboard data transfer
+ * by David Kotchan (dkotchan@sympatico.ca)
+ */
+
+#define CF_TEXT	    0x01    /* Windows clipboard format: Windows (ANSI) text */
+#define CF_OEMTEXT  0x07    /* Windows clipboard format: OEM (DOS) text */
+#define CF_VIMCLIP  0x04    /* trick: SYLK clipboard format for VimClipboard */
+
+static int Win16OpenClipboard(void);
+static int Win16CloseClipboard(void);
+static int Win16EmptyClipboard(void);
+static char_u *Win16GetClipboardData(int clip_data_format);
+static int Win16SetClipboardData(int clip_data_format, char_u *clip_data, int clip_data_size, int clip_data_type);
+
+/*
+ * Make vim the owner of the current selection.  Return OK upon success.
+ */
+    int
+clip_mch_own_selection(VimClipboard *cbd)
+{
+    /*
+     * Never actually own the clipboard.  If another application sets the
+     * clipboard, we don't want to think that we still own it.
+     */
+    return FAIL;
+}
+
+/*
+ * Make vim NOT the owner of the current selection.
+ */
+    void
+clip_mch_lose_selection(VimClipboard *cbd)
+{
+    /* Nothing needs to be done here */
+}
+
+/*
+ * Read the Windows clipboard text and put it in Vim's clipboard register.
+ */
+    void
+clip_mch_request_selection(VimClipboard *cbd)
+{
+    int		type = MAUTO;
+    char_u	*pAllocated = NULL;
+    char_u	*pClipText = NULL;
+    int		clip_data_format = 0;
+
+    if (Win16OpenClipboard())
+    {
+	/* Check for Vim's own clipboard format first.  The CF_VIMCLIP format
+	 * is just ordinary text (like CF_TEXT) except prepended by the
+	 * selection type (as a single character).  Note that under DOS we
+	 * actually cannot define a custom CF_VIMCLIP clipboard format; we
+	 * use instead one of the existing Windows-defined formats, usually
+	 * "DIF" or "SYLK".  See Win16GetClipboardData() for details.
+	 *
+	 * Note that Win16GetClipboardData() returns the address of the memory
+	 * block it allocated.  This is not necessary the start of the
+	 * clipboard text data: there may be other bytes ahead of the
+	 * text (particularly for CF_VIMCLIP) which are used for data
+	 * management.  So pClipText is not necessarily == pAllocated.
+	 */
+
+	if ((pAllocated = Win16GetClipboardData(CF_VIMCLIP)) != NULL)
+	{
+	    clip_data_format = CF_VIMCLIP;
+	    pClipText = pAllocated;
+
+	    switch (*pClipText++)	/* after ++, pClipText points to text */
+	    {
+		default:
+		case 'L':	type = MLINE;	break;
+		case 'C':	type = MCHAR;	break;
+		case 'B':	type = MBLOCK;	break;
+	    }
+	}
+
+	/* Otherwise, check for the normal Windows text formats.  There are
+	 * two of these: CF_TEXT (common) and CF_OEMTEXT (used for DOS
+	 * compatibility).  Experiments show that, under the DOS/Windows
+	 * clipboard interface, writing CF_TEXT data to the clipboard
+	 * automatically creates a CF_OEMTEXT format as well.
+	 */
+
+	else if ((pAllocated = Win16GetClipboardData(CF_TEXT)) != NULL)
+	{
+	    clip_data_format = CF_TEXT;
+	    pClipText = pAllocated;
+	}
+
+	else if ((pAllocated = Win16GetClipboardData(CF_OEMTEXT)) != NULL)
+	{
+	    clip_data_format = CF_OEMTEXT;
+	    pClipText = pAllocated;
+	}
+
+	/* Did we get anything? */
+
+	if (pClipText != NULL)
+	{
+	    char_u *pDest;
+	    char_u *pStart;
+	    char_u *pEnd;
+
+	    long_u clip_data_size = 0;
+
+	    /* The Windows clipboard normally stores its text lines terminated
+	     * by <CR><NL>.  But Vim uses only <NL>, so translate the <CR><NL>
+	     * into <NL>.  Also, watch for possible null bytes at the end of
+	     * pClipText.  These are padding added by "get_clipboard_data"
+	     * (int 0x2f, AX= 0x1705) in order to round the data size up to the
+	     * next multiple of 32 bytes.  See Win16GetClipboardData() for
+	     * details.
+	     */
+
+	    pDest = strstr( pClipText, "\r\n" );    /* find first <CR><NL> */
+
+	    if (pDest != NULL)			/* found one? */
+	    {
+		pStart = pDest + 1;		/* points to <NL> after <CR> */
+		pEnd = strstr( pStart, "\r\n" );/* find next <CR><NL> */
+
+		while (pEnd != NULL)		/* found one? */
+		{
+		    memmove(pDest, pStart, (long)(pEnd - pStart));
+							/* exclude <CR> */
+		    pDest += (long)(pEnd - pStart);	/* new destination */
+		    pStart = pEnd + 1;			/* new starting point */
+		    pEnd = strstr(pStart, "\r\n");	/* find next <CR><NL> */
+		}
+
+		/* Fell out of while() loop: no more <CR><NL> pairs.  Just copy
+		 * the rest of the data, up to the first null byte.  */
+		pEnd = strchr(pStart, '\0');		/* find first null */
+
+		memmove(pDest, pStart, (long)(pEnd - pStart)); /* exclude nul */
+		pDest += (long)(pEnd - pStart);
+		*pDest = '\0';				    /* terminate */
+
+		/* Now that all <CR><NL> pairs have been "compressed" into just
+		 * <NL>'s, determine the true text length.  */
+		clip_data_size = (long_u)(pDest - pClipText);
+	    }
+	    else
+	    {
+		/* no <CR><NL> pairs at all */
+		/* Since the data may have been padded with trailing nulls,
+		 * determine the true string length. */
+		clip_data_size = STRLEN(pClipText);	/* true data length */
+	    }
+
+	    /* Copy the cleaned-up data over to Vim's clipboard "*" register. */
+	    clip_yank_selection(type, pClipText, clip_data_size, cbd);
+
+	    /* Free the memory that Win16GetClipboardData() allocated. */
+	    vim_free(pAllocated);
+	}
+
+	Win16CloseClipboard();
+
+    }  // end if (Win16OpenClipboard())
+}
+
+/*
+ * Send the currently selected Vim text to the Windows clipboard.
+ */
+    void
+clip_mch_set_selection( VimClipboard *cbd )
+{
+    char_u	*pClipData = NULL;
+    long_u	clip_data_size;
+    int		clip_data_type;
+
+    /* If the '*' register isn't already filled in, fill it in now. */
+    cbd->owned = TRUE;
+    clip_get_selection(cbd);
+    cbd->owned = FALSE;
+
+    /*
+     * clip_convert_selection() returns a pointer to a buffer containing
+     * the text to send to the Windows clipboard, together with a count
+     * of the number of characters (bytes) in the buffer.  The function's
+     * return value is the 'type' of selection: MLINE, MCHAR, or MBLOCK;
+     * or -1 for failure.
+     */
+    clip_data_type = clip_convert_selection(&pClipData, &clip_data_size, cbd);
+
+    if (clip_data_type < 0)	    /* could not convert? */
+	return;			    /* early exit */
+
+    if (Win16OpenClipboard())
+    {
+	if (Win16EmptyClipboard())
+	{
+	    int sentOK;
+
+	    sentOK = Win16SetClipboardData(CF_TEXT, pClipData,
+					      clip_data_size, clip_data_type);
+	    sentOK = Win16SetClipboardData(CF_VIMCLIP,
+			 pClipData, clip_data_size, clip_data_type) && sentOK;
+
+	    if (!sentOK)
+	    {
+		/* one or both of Win16SetClipboardData() failed. */
+		/* Technically we don't know why Win16SetClipboardData()
+		 * failed, but almost always it will be because there wasn't
+		 * enough DOS memory to buffer the data, so report that as the
+		 * problem.
+		 *
+		 * We report the error here (instead of in
+		 * Win16SetClipboardData()) because we don't want the error
+		 * reported twice.
+		 */
+		EMSG("E450: Selection too large, cannot allocate DOS buffer");
+	    }
+	}
+
+	Win16CloseClipboard();
+    }
+
+    /* release memory allocated by clip_convert_selection() */
+    vim_free(pClipData);
+
+    return;
+}
+
+/*
+ * Win16OpenClipboard: open the Windows clipboard.  The clipboard must be open
+ * before it can be communicated with at all.  Return TRUE on success,
+ * FALSE on failure.
+ */
+    static int
+Win16OpenClipboard(void)
+{
+    __dpmi_regs  dpmi_regs;
+
+    long    start_time;
+    int	    tick_count;
+
+    /* int 0x2f, AX = 0x1701 attempts to open the Windows clipboard.  Upon
+     * return from the interrupt, if AX is non-zero, the clipboard was
+     * successfully opened.  If AX is zero, the clipboard could not be opened
+     * because it is currently in use by another process.
+     *
+     * Remark: other DOS programs I (dk) have written that use the Windows
+     * clipboard sometimes encounter the problem that the clipboard cannot
+     * be opened even though it is demonstrably not in use by any other
+     * process.  In all cases, repeated attempts to open the clipboard
+     * eventually succeed, but the initial attempt occasionally fails.
+     *
+     * The problem is intermittent and appears to be related to DOS being
+     * "busy" at certain unpredictable times.  DOS maintains two internal
+     * flags that indicate whether it's busy: InDOS and CritErr.  The
+     * location of InDOS can be found by calling int 0x21, AH = 0x34.  The
+     * location of CritErr can be found by calling int 0x21, AX = 0x5d06.
+     * If either of these flags is set, DOS is "busy" and cannot be
+     * interrupted.  See "Undocumented DOS" by Schulman et al for details.
+     *
+     * However here I take the easier approach that if the first call to open
+     * the clipboard does not succeed, just try again.  In fact, try once per
+     * biostime() clock tick, up to 18 times (about one second).
+     */
+
+    tick_count = 0;
+
+    dpmi_regs.x.ax = 0x1701;	/* open Windows clipboard */
+    if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+    {
+	/* real-mode interrupt failed? */
+	return FALSE;		/* FALSE --> clipboard not open */
+    }
+
+    /* wait up to one second */
+    while (dpmi_regs.x.ax == 0 && tick_count++ < 18)
+    {
+	/* Wait one clock tick (18.2 ticks/sec = 55 msec per tick).
+	 *
+	 * We busy-wait here.  Unfortunately, delay() and usleep() have been
+	 * reported to give problems with the original Windows 95.  This is
+	 * fixed in service pack 1, but not everybody installed that.
+	 */
+	start_time = biostime(0, 0L);
+	while (biostime(0, 0L) == start_time)
+	    ;
+
+	dpmi_regs.x.ax = 0x1701;    /* open Windows clipboard */
+	if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+	{
+	    /* real-mode interrupt failed? */
+	    return FALSE;		/* FALSE --> clipboard not open */
+	}
+    }
+
+    /* Couldn't open the clipboard, even after 18 attempts? */
+
+    if (tick_count >= 18 && dpmi_regs.x.ax == 0)
+	return FALSE;		/* FALSE --> clipboard not open */
+
+    return TRUE;	/* TRUE --> clipboard opened successfully, OK */
+}
+
+/*
+ * Win16CloseClipboard: close the Windows clipboard.  Return TRUE on
+ * success, FALSE on failure.  This function can always be called,
+ * whether the clipboard is open or not.
+ */
+    static int
+Win16CloseClipboard(void)
+{
+    __dpmi_regs  dpmi_regs;
+
+    /* Close the clipboard.  This interrupt can always be called, even
+     * if the clipboard is already closed.
+     */
+
+    dpmi_regs.x.ax = 0x1708;	    /* close the clipboard */
+    if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+    {
+	/* real-mode interrupt failed? */
+	return FALSE;		/* FALSE --> clipboard could not be closed */
+    }
+
+    return TRUE;	/* TRUE --> clipboard closed successfully, OK */
+}
+
+/*
+ * Win16EmptyClipboard: empty the (previously opened) Windows clipboard.
+ * Return TRUE on success, FALSE on failure.
+ */
+    static int
+Win16EmptyClipboard(void)
+{
+    __dpmi_regs  dpmi_regs;
+
+    /* int 0x2f, AX = 0x1702 attempts to empty the Windows clipboard.  Upon
+     * return from the interrupt, if AX == 0, the clipboard could not be
+     * emptied (for some reason).
+     */
+    dpmi_regs.x.ax = 0x1702;    /*  empty the Windows clipboard */
+    if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+    {
+	/* real-mode interrupt failed? */
+	return FALSE;		/* FALSE --> clipboard could not be emptied */
+    }
+
+    /* Did we succeed in clearing the clipboard? */
+    if (dpmi_regs.x.ax == 0)
+	return FALSE;		/* FALSE --> clipboard could not be emptied */
+
+    return TRUE;		/* TRUE --> clipboard was emptied, OK */
+}
+
+/*
+ * FreeDOSMemory: a helper function to free memory previously
+ * allocated by a call to __dpmi_allocate_dos_memory().
+ */
+    static void
+FreeDOSMemory(int protected_mode_selector)
+{
+    /* Free the DOS buffer and release the DPMI prot-mode selector.
+     *
+     * It's important that DOS memory be properly released because
+     * there's only a limited amount of it.  Therefore, if the call
+     * to __dpmi_free_dos_memory() fails, emit an error message
+     * unconditionally.
+     */
+    if (__dpmi_free_dos_memory(protected_mode_selector) == -1)
+	EMSG("E451: could not free DOS memory buffer (DJGPP)");
+}
+
+/*
+ * Win16GetClipboardData: query the Windows clipboard as to whether data
+ * is available in a particular clipboard format.  If data is
+ * available, allocate a buffer for it and read the data from the
+ * clipboard into the buffer.  Return a pointer to the buffer.  If
+ * no data is available in the requested format, return NULL.
+ *
+ * This routine allocates memory to hold the retrieved clipboard
+ * data.  It's the caller's responsibility to free this memory
+ * once it's finished using it.  The memory should be freed by
+ * calling vim_free().
+ */
+    static char_u *
+Win16GetClipboardData(int clip_data_format)
+{
+    __dpmi_regs  dpmi_regs;
+
+    int		real_mode_segment_address;
+    int		protected_mode_selector;
+
+    char_u	*clip_data_buffer;
+    long_u	clip_data_size;
+
+    /* We only handle clipboard formats we recognize, others are ignored.
+     *
+     * It's not possible to create a custom clipboard format for VimClipboard
+     * data under DOS, so one of the predefined Windows formats had to be
+     * used for CF_VIMCLIP.  Two obscure formats, popular when Windows 3.0
+     * came out but no longer in much use today, are the DIF and SYLK formats.
+     * DIF is the Data Interchange Format, SYLK is the Symbolic Link format.
+     * They are both text formats and either one can be hijacked for use as
+     * "the VimClipboard format".  Of course, this conflicts with anyone who
+     * still *is* using DIF or SYLK data formats, but that will be very few
+     * people.
+     *
+     * I (dk) chose SYLK as the more obscure format because it was used
+     * mostly for Microsoft Multiplan (the pre-cursor to Excel) and it's not
+     * likely Multiplan is used anywhere much anymore.  Mind you, Excel can
+     * still export to both DIF and SYLK formats.
+     */
+
+    switch (clip_data_format)
+    {
+    case CF_VIMCLIP:		    /* Vim's own special clipboard format */
+    case CF_TEXT:		    /* Windows text */
+    case CF_OEMTEXT:		    /* DOS (OEM) text */
+
+	/* int 0x2f, AX = 0x1704 returns the number of bytes of data currently
+	 * on the Windows clipboard, for the specified format.  Upon return
+	 * from the interrupt, DX:AX = the number of bytes, rounded up to the
+	 * nearest multiple of 32.
+	 */
+
+	dpmi_regs.x.ax = 0x1704;    /* get size of clipbd data */
+	dpmi_regs.x.dx = clip_data_format;
+	if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+	{
+	    /* real-mode interrupt failed? */
+	    return NULL;				    /* early exit */
+	}
+
+	/* Did we get anything?  If not, this is not an error. */
+	if (dpmi_regs.x.dx == 0 && dpmi_regs.x.ax == 0)
+	{
+	    /* no CF_VIMCLIP data? */
+	    return NULL;				    /* early exit */
+	}
+
+	/* There is data available in the requested clipboard format.
+	 *
+	 * Calculate data size.  Remember this is rounded up to the nearest
+	 * multiple of 32, so clip_data_size is actually an upper limit.
+	 * The extra bytes, if any, are set to null (0x00) when the data is
+	 * read from the clipboard.  (Later:) actually I'm no longer sure
+	 * this is strictly true: the end-of-data is marked by a null, but
+	 * the extra bytes appear to sometimes be null, sometimes not.
+	 * They may just be garbage.
+	 */
+	clip_data_size = dpmi_regs.x.ax + (dpmi_regs.x.dx << 16);
+
+	/* Allocate memory to retrieve the data.  The buffer has to lie in the
+	 * DOS memory region (in the first 1 MByte of address space) because
+	 * the Windows clipboard interface expects a 16-bit segment:offset
+	 * pointer to a buffer address within the DOS region.  Must therefore
+	 * use __dpmi_allocate_dos_memory() instead of lalloc() or alloc().
+	 */
+	real_mode_segment_address = __dpmi_allocate_dos_memory(
+		(clip_data_size + 15) >> 4,	/* buffer size, in 16-byte paragraphs */
+		&protected_mode_selector);	/* prot-mode selector for the address */
+
+	if (real_mode_segment_address == -1)
+	{
+	    /* memory allocation failed. */
+
+	    /* Technically we don't know why the allocation failed, but
+	     * almost always it will be because there wasn't enough DOS
+	     * memory to satisfy the request, so report that as the problem.
+	     * On my system, DJGPP is able to satisfy a DOS allocation request
+	     * up to about 600K in size.  This depends on your HIMEM.SYS and
+	     * EMM386.EXE settings however.
+	     */
+	    EMSG("E452: Clipboard data too large, cannot allocate DOS buffer");
+	    return NULL;				    /* early exit */
+	}
+
+	/* Copy data from the clipboard into the buffer.  Experiments show that
+	 * the Windows clipboard is smart enough to handle data transfers
+	 * larger than 64K properly, even though the buffer address is a 16-bit
+	 * segment:offset (which would normally limit the block size to 64K
+	 * unless ES gets incremented).
+	 */
+	dpmi_regs.x.ax = 0x1705;	/* get clipboard data */
+	dpmi_regs.x.dx = clip_data_format;		/* CF_VIMCLIP */
+	dpmi_regs.x.es = real_mode_segment_address;	/* buffer ad: segment */
+	dpmi_regs.x.bx = 0;				/* buffer ad: offset */
+	if (__dpmi_int( 0x2f, &dpmi_regs) == -1)
+	{
+	    /* real-mode interrupt failed? */
+	    EMSG("E453: could not copy clipboard data to DOS buffer");
+	    FreeDOSMemory(protected_mode_selector);	/* clean up DOS mem */
+	    return NULL;				/* early exit */
+	}
+
+	/* Clipboard data is now in DOS memory in the buffer pointed to by
+	 * ES:BX.  Copy this into ordinary memory that Vim can access (ie.
+	 * prot-mode memory).  Allocate one extra byte to ensure the text
+	 * is terminated properly (in case it was somehow corrupted).
+	 */
+	clip_data_buffer = (char_u *)lalloc(clip_data_size + 1, TRUE);
+
+	if (clip_data_buffer == NULL)
+	{
+	    /* allocation failed? */
+	    EMSG("E454: could not allocate clipboard memory buffer");
+	    FreeDOSMemory(protected_mode_selector);	/* clean up DOS mem */
+	    return NULL;				/* early exit */
+	}
+
+	*(clip_data_buffer + clip_data_size) = '\0';	/* ensure terminated */
+
+	/* Copy the data from DOS memory to Vim-accessible memory. */
+	movedata(				/* DJGPP version of memcpy() */
+		protected_mode_selector, 0, /* source: DOS ad (via selector) */
+		_my_ds(), (unsigned)clip_data_buffer,
+						/* target: normal mem address */
+		clip_data_size);		/* how many bytes */
+
+	/* Free the DOS buffer and release the DPMI prot-mode selector. */
+	FreeDOSMemory(protected_mode_selector);	 /* clean up DOS memory */
+
+	return clip_data_buffer;    /* return pointer to allocated buffer */
+
+    default:		/* unknown clipboard format */
+	return NULL;
+    }
+}
+
+/*
+ * Win16SetClipboardData: send 'clip_data_size' bytes of data from the buffer
+ * pointed to by 'clip_data', to the Windows clipboard.  The data is
+ * registered with the clipboard as being in the 'clip_data_format'
+ * format.
+ */
+    static int
+Win16SetClipboardData(
+	int	clip_data_format,
+	char_u	*clip_data,
+	int	clip_data_size,
+	int	clip_data_type)
+{
+    __dpmi_regs  dpmi_regs;
+
+    int		real_mode_segment_address;
+    int		protected_mode_selector;
+    long_u	protected_mode_offset = 0L;
+    int		total_size = clip_data_size;
+
+    char_u	*clip_sel_type;
+
+    /* If we're using the CF_VIMCLIP custom format, allocate an extra
+     * byte for clip_sel_type, which is a character indicating the type
+     * of text selection: MLINE, MCHAR, or MBLOCK.
+     */
+    if (clip_data_format == CF_VIMCLIP)
+	total_size++;			/* extra byte for marker */
+
+    /* Data cannot be sent directly from a Vim string (pClipData) to
+     * the Windows clipboard, because the Windows clipboard interface
+     * expects a 16-bit (DOS) segment:offset address for the source
+     * buffer.  Therefore we must create a "transfer buffer" in the DOS
+     * memory region (in the first 1 MByte of address space) and copy
+     * the Vim string into that.  From there, the data can then be sent
+     * to the Windows clipboard.
+     *
+     * To allocate DOS memory, we must use __dpmi_allocate_dos_memory()
+     * instead of lalloc() or alloc().  If the allocation fails, it will
+     * almost invariably be because there is not enough DOS memory
+     * available to accommodate the size of clip_data.  There is nothing
+     * we can do about this, we simply have to fail.
+     */
+    real_mode_segment_address = __dpmi_allocate_dos_memory(
+	    (total_size + 15) >> 4,	/* buffer size, in 16-byte paragraphs */
+	    &protected_mode_selector);	/* prot-mode selector for the address */
+
+    if (real_mode_segment_address == -1)
+    {
+	/* memory allocation failed. */
+	/* Technically we don't know why the allocation failed, but
+	 * almost always it will be because there wasn't enough DOS
+	 * memory to satisfy the request.  On my system, DJGPP is able
+	 * to satisfy a DOS allocation request up to about 600K in size.
+	 * This depends however on HIMEM.SYS and EMM386.EXE settings.
+	 */
+	return FALSE;				/* early exit */
+    }
+
+    /* Copy data from Vim's buffer (clip_data) into the DOS transfer buffer.
+     * This can be larger than 64K; movedata() takes care of crossing any
+     * 16-bit segment boundaries.
+     *
+     * If we're using Vim's custom clipboard format, we must copy one extra
+     * byte to indicate the type of selection: line, character, or block.
+     */
+    if (clip_data_format == CF_VIMCLIP)
+    {
+	switch (clip_data_type)
+	{
+	    default:
+	    case MLINE:	    clip_sel_type = "L";	break;
+	    case MCHAR:	    clip_sel_type = "C";	break;
+	    case MBLOCK:    clip_sel_type = "B";	break;
+	}
+
+	movedata(
+		_my_ds(), (unsigned)clip_sel_type,
+					    /* source: normal memory address */
+		protected_mode_selector, 0, /* target: DOS ad (via selector) */
+		1);			    /* how many bytes to copy */
+
+	protected_mode_offset += STRLEN(clip_sel_type);	/* allow for marker */
+    }
+
+    movedata(
+	_my_ds(), (unsigned)clip_data,	/* source: normal memory address */
+	protected_mode_selector,	/* target: DOS address (via selector) */
+	protected_mode_offset,		/* non-zero, if using clip_sel_type */
+	clip_data_size);		/* how many bytes to copy */
+
+    /* Send data from the DOS transfer buffer to the Windows clipboard.
+     * int 0x2f, AX = 0x1703 sends SI:CX bytes of data from the buffer
+     * at ES:BX, to the clipboard.
+     */
+    dpmi_regs.x.ax = 0x1703;			/* send clipboard data */
+    dpmi_regs.x.dx = clip_data_format;		/* flag: format of the data */
+    dpmi_regs.x.si = ((total_size >> 16)
+	    & 0x0000ffffL);			/* hi word of data size */
+    dpmi_regs.x.cx = (total_size & 0x0000ffffL);
+						/* lo word of data size */
+    dpmi_regs.x.es = real_mode_segment_address;	/* buffer address: segment */
+    dpmi_regs.x.bx = 0;				/* buffer address: offset */
+    if (__dpmi_int(0x2f, &dpmi_regs) == -1)
+    {
+	/* real-mode interrupt failed. */
+	FreeDOSMemory(protected_mode_selector);   /* clean up DOS memory */
+	return FALSE;				  /* early exit */
+    }
+
+    /* Free the DOS buffer and release the DPMI prot-mode selector. */
+    FreeDOSMemory(protected_mode_selector);	  /* clean up DOS memory */
+
+    return TRUE;	/* TRUE --> data successfully sent to clipboard */
+}
+
+#endif	/* FEAT_CLIPBOARD */
+#endif /* DJGPP */
+
+/*
+ * End of MS-DOS only code
+ */
+#endif /* WIN16 */
+
+/* common MS-DOS and Win16 code follows */
+
+    static int
+vim_chmod(char_u *name)
+{
+    char_u	*p;
+    int		f;
+    int		c = 0;
+
+    /* chmod() can't handle a file name with a trailing slash, remove it.
+     * But don't remove it for "/" or "c:/". */
+    p = name + STRLEN(name);
+    if (p > name)
+	--p;
+    if (p > name && (*p == '\\' || *p == '/') && p[-1] != ':')
+    {
+	c = *p;				/* remove trailing (back)slash */
+	*p = NUL;
+    }
+    else
+	p = NULL;
+#if defined(__BORLANDC__) && (__BORLANDC__ > 0x410)
+    /* this also sets the archive bit, supported by Borland C 4.0 and later,
+     * where __BORLANDC__ is 0x450 (3.1 is 0x410) */
+    f = _rtl_chmod((char *)name, 0, 0);
+#else
+    f = _chmod((char *)name, 0, 0);
+#endif
+    if (p != NULL)
+	*p = c;				/* put back (back)slash */
+    return f;
+}
+
+/*
+ * get file permissions for 'name'
+ * Returns -1 for error.
+ * Returns FA_attributes defined in dos.h
+ */
+    long
+mch_getperm(char_u *name)
+{
+    return (long)vim_chmod(name);	/* get file mode */
+}
+
+/*
+ * set file permission for 'name' to 'perm'
+ *
+ * return FAIL for failure, OK otherwise
+ */
+    int
+mch_setperm(
+    char_u	*name,
+    long	perm)
+{
+    perm |= FA_ARCH;	    /* file has changed, set archive bit */
+#if defined(__BORLANDC__) && (__BORLANDC__ > 0x410)
+    return (_rtl_chmod((char *)name, 1, (int)perm) == -1 ? FAIL : OK);
+#else
+    return (_chmod((char *)name, 1, (int)perm) == -1 ? FAIL : OK);
+#endif
+}
+
+/*
+ * Set hidden flag for "name".
+ */
+    void
+mch_hide(char_u *name)
+{
+    /* DOS 6.2 share.exe causes "seek error on file write" errors when making
+     * the swap file hidden.  Thus don't do it. */
+}
+
+/*
+ * return TRUE if "name" is a directory
+ * return FALSE if "name" is not a directory
+ * return FALSE for error
+ *
+ * beware of a trailing (back)slash
+ */
+    int
+mch_isdir(char_u *name)
+{
+    int		f;
+
+    f = vim_chmod(name);
+    if (f == -1)
+	return FALSE;		    /* file does not exist at all */
+    if ((f & FA_DIREC) == 0)
+	return FALSE;		    /* not a directory */
+    return TRUE;
+}
+
+/*
+ * Return 1 if "name" can be executed, 0 if not.
+ * If "use_path" is FALSE only check if "name" is executable.
+ * Return -1 if unknown.
+ */
+    int
+mch_can_exe(name, path, use_path)
+    char_u	*name;
+    char_u	**path;
+    int		use_path;
+{
+    char	*p;
+    int		mode;
+
+    if (!use_path)
+    {
+	/* TODO: proper check if file is executable. */
+	mode = vim_chmod(name);
+	return mode != -1 && (mode & FA_DIREC) == 0;
+    }
+    p = searchpath(name);
+    if (p == NULL || mch_isdir(p))
+	return FALSE;
+    if (path != NULL)
+	*path = vim_strsave(p);
+    return TRUE;
+}
+
+/*
+ * Check what "name" is:
+ * NODE_NORMAL: file or directory (or doesn't exist)
+ * NODE_WRITABLE: writable device, socket, fifo, etc.
+ * NODE_OTHER: non-writable things
+ */
+    int
+mch_nodetype(char_u *name)
+{
+    if (STRICMP(name, "AUX") == 0
+	    || STRICMP(name, "CON") == 0
+	    || STRICMP(name, "CLOCK$") == 0
+	    || STRICMP(name, "NUL") == 0
+	    || STRICMP(name, "PRN") == 0
+	    || ((STRNICMP(name, "COM", 3) == 0
+		    || STRNICMP(name, "LPT", 3) == 0)
+		&& VIM_ISDIGIT(name[3])
+		&& name[4] == NUL))
+	return NODE_WRITABLE;
+    /* TODO: NODE_OTHER? */
+    return NODE_NORMAL;
+}
+
+/*
+ * Get name of current directory into buffer 'buf' of length 'len' bytes.
+ * Return OK for success, FAIL for failure.
+ */
+    int
+mch_dirname(
+    char_u	*buf,
+    int		len)
+{
+#ifdef DJGPP
+    if (getcwd((char *)buf, len) == NULL)
+	return FAIL;
+    /* turn the '/'s returned by DJGPP into '\'s */
+    slash_adjust(buf);
+    return OK;
+#else
+    return (getcwd((char *)buf, len) != NULL ? OK : FAIL);
+#endif
+}
+
+/*
+ * this version of remove is not scared by a readonly (backup) file
+ *
+ * returns -1 on error, 0 otherwise (just like remove())
+ */
+    int
+mch_remove(char_u *name)
+{
+    (void)mch_setperm(name, 0);    /* default permissions */
+    return unlink((char *)name);
+}
+
+/*
+ * Special version of getenv(): Use uppercase name.
+ */
+    char_u *
+mch_getenv(char_u *name)
+{
+    int		i;
+#define MAXENVLEN 50
+    char_u	var_copy[MAXENVLEN + 1];
+    char_u	*p;
+    char_u	*res;
+
+    /*
+     * Take a copy of the argument, and force it to upper case before passing
+     * to getenv().  On DOS systems, getenv() doesn't like lower-case argument
+     * (unlike Win32 et al.)  If the name is too long to fit in var_copy[]
+     * allocate memory.
+     */
+    if ((i = STRLEN(name)) > MAXENVLEN)
+	p = alloc(i + 1);
+    else
+	p = var_copy;
+    if (p == NULL)
+	p = name;   /* out of memory, fall back to unmodified name */
+    else
+    {
+	for (i = 0; name[i] != NUL; ++i)
+	    p[i] = toupper(name[i]);
+	p[i] = NUL;
+    }
+
+    res = (char_u *)getenv((char *)p);
+
+    if (p != var_copy && p != name)
+	vim_free(p);
+
+    return res;
+}
+
+/*
+ * Insert user name in s[len].
+ */
+    int
+mch_get_user_name(
+    char_u	*s,
+    int		len)
+{
+    *s = NUL;
+    return FAIL;
+}
+
+/*
+ * Insert host name is s[len].
+ */
+    void
+mch_get_host_name(
+    char_u	*s,
+    int		len)
+{
+#ifdef DJGPP
+    vim_strncpy(s, "PC (32 bits Vim)", len - 1);
+#else
+    vim_strncpy(s, "PC (16 bits Vim)", len - 1);
+#endif
+}
diff -urN vim-src/src/os_msdos.h vim-qt-src/src/os_msdos.h
--- vim-src/src/os_msdos.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/os_msdos.h	2016-06-08 06:39:27.751315380 +0200
@@ -0,0 +1,110 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * MSDOS Machine-dependent things.
+ */
+
+#include "os_dos.h"		/* common MS-DOS and Win32 stuff */
+
+#define BINARY_FILE_IO
+#define USE_EXE_NAME		/* use argv[0] for $VIM */
+#define SYNC_DUP_CLOSE		/* sync() a file with dup() and close() */
+#define USE_TERM_CONSOLE
+#ifdef DJGPP
+# include <fcntl.h>		/* defines _USE_LFN */
+# define USE_LONG_FNAME _USE_LFN    /* decide at run time */
+# define USE_FNAME_CASE
+# define HAVE_PUTENV
+# define HAVE_STDARG_H
+#else
+# define SHORT_FNAME		/* always 8.3 file name */
+#endif
+#define HAVE_STDLIB_H
+#define HAVE_STRING_H
+#define HAVE_FCNTL_H
+#define HAVE_STRCSPN
+#define HAVE_STRICMP
+#define HAVE_STRFTIME		/* guessed */
+#define HAVE_STRNICMP
+#define HAVE_MEMSET
+#define HAVE_QSORT
+#define HAVE_ST_MODE		/* have stat.st_mode */
+#define HAVE_MATH_H
+#if defined(__DATE__) && defined(__TIME__)
+# define HAVE_DATE_TIME
+#endif
+#define BREAKCHECK_SKIP	    1	/* call mch_breakcheck() each time, it's fast */
+#define HAVE_AVAIL_MEM
+
+/*
+ * Borland C++ 3.1 doesn't have _RTLENTRYF
+ */
+#ifdef __BORLANDC__
+# if __BORLANDC__ < 0x450
+#  define _RTLENTRYF
+# endif
+#endif
+
+#define FNAME_ILLEGAL "\"*?><|" /* illegal characters in a file name */
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+# include <dos.h>
+# include <dir.h>
+# include <time.h>
+#endif
+
+#ifdef DJGPP
+# include <unistd.h>
+# define HAVE_LOCALE_H
+# define setlocale(c, p)    djgpp_setlocale()
+#endif
+
+#ifndef DJGPP
+typedef long off_t;
+#endif
+
+/*
+ * Try several directories to put the temp files.
+ */
+#define TEMPDIRNAMES	"$TMP", "$TEMP", "c:\\TMP", "c:\\TEMP", ""
+#define TEMPNAMELEN	128
+
+#ifndef DFLT_MAXMEM
+# define DFLT_MAXMEM	256		/* use up to 256Kbyte for buffer */
+#endif
+#ifndef DFLT_MAXMEMTOT
+# define DFLT_MAXMEMTOT	0		/* decide in set_init */
+#endif
+
+#ifdef DJGPP
+# define BASENAMELEN  (_USE_LFN?250:8)	/* length of base of file name */
+#else
+# define BASENAMELEN	    8		/* length of base of file name */
+#endif
+
+/* codes for msdos mouse event */
+#define MSDOS_MOUSE_LEFT	0x01
+#define MSDOS_MOUSE_RIGHT	0x02
+#define MSDOS_MOUSE_MIDDLE	0x04
+
+#ifdef DJGPP
+int mch_rename(const char *OldFile, const char *NewFile);
+#else
+# define mch_rename(src, dst) rename(src, dst)
+#endif
+
+#ifdef DJGPP
+# define vim_mkdir(x, y) mkdir((char *)(x), y)
+#else
+# define vim_mkdir(x, y) mkdir((char *)(x))
+#endif
+#define mch_rmdir(x) rmdir((char *)(x))
+
+#define mch_setenv(name, val, x) setenv(name, val, x)
diff -urN vim-src/src/os_mswin.c vim-qt-src/src/os_mswin.c
--- vim-src/src/os_mswin.c	2016-06-08 06:34:09.814884954 +0200
+++ vim-qt-src/src/os_mswin.c	2016-06-08 06:40:09.645637469 +0200
@@ -138,7 +138,7 @@
 extern char g_szOrigTitle[];
 #endif
 
-#ifdef FEAT_GUI
+#if defined(FEAT_GUI) && !defined(FEAT_GUI_QT)
 extern HWND s_hwnd;
 #else
 static HWND s_hwnd = 0;	    /* console window handle, set by GetConsoleHwnd() */
diff -urN vim-src/src/os_unix.c vim-qt-src/src/os_unix.c
--- vim-src/src/os_unix.c	2016-06-08 06:34:09.816884969 +0200
+++ vim-qt-src/src/os_unix.c	2016-06-08 06:40:09.646637477 +0200
@@ -2156,7 +2156,7 @@
     if (get_x11_windis() == OK)
 	type = 1;
 #else
-# if defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK)
+# if defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     if (gui.in_use)
 	type = 1;
 # endif
@@ -2168,6 +2168,7 @@
      */
     if ((type || *T_TS != NUL) && title != NULL)
     {
+
 	if (oldtitle == NULL
 #ifdef FEAT_GUI
 		&& !gui.in_use
@@ -2185,7 +2186,7 @@
 	    set_x11_title(title);		/* x11 */
 #endif
 #if defined(FEAT_GUI_GTK) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT)
 	else
 	    gui_mch_settitle(title, icon);
 #endif
diff -urN vim-src/src/os_win16.c vim-qt-src/src/os_win16.c
--- vim-src/src/os_win16.c	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/os_win16.c	2016-06-08 06:39:27.756315418 +0200
@@ -0,0 +1,427 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+/*
+ * os_win16.c
+ *
+ * Win16 (Windows 3.1x) system-dependent routines.
+ * Carved brutally from os_win32.c by Vince Negri <vn@aslnet.co.uk>
+ */
+#ifdef __BORLANDC__
+# pragma warn -par
+# pragma warn -ucp
+# pragma warn -use
+# pragma warn -aus
+# pragma warn -obs
+#endif
+
+#include "vim.h"
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+# include <dos.h>
+#endif
+
+#include <string.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <limits.h>
+
+#ifndef PROTO
+# include <process.h>
+
+# undef chdir
+# include <direct.h>
+# include <shellapi.h>	/* required for FindExecutable() */
+#endif
+
+
+/* Record all output and all keyboard & mouse input */
+/* #define MCH_WRITE_DUMP */
+
+#ifdef MCH_WRITE_DUMP
+FILE* fdDump = NULL;
+#endif
+
+
+/*
+ * When generating prototypes for Win32 on Unix, these lines make the syntax
+ * errors disappear.  They do not need to be correct.
+ */
+#ifdef PROTO
+typedef int HANDLE;
+typedef int SMALL_RECT;
+typedef int COORD;
+typedef int SHORT;
+typedef int WORD;
+typedef int DWORD;
+typedef int BOOL;
+typedef int LPSTR;
+typedef int LPTSTR;
+typedef int KEY_EVENT_RECORD;
+typedef int MOUSE_EVENT_RECORD;
+# define WINAPI
+typedef int CONSOLE_CURSOR_INFO;
+typedef char * LPCSTR;
+# define WINBASEAPI
+typedef int INPUT_RECORD;
+# define _cdecl
+#endif
+
+#ifdef __BORLANDC__
+/* being a more ANSI compliant compiler, BorlandC doesn't define _stricoll:
+ * but it does in BC 5.02! */
+# if __BORLANDC__ < 0x502
+int _stricoll(char *a, char *b);
+# endif
+#endif
+
+/* cproto doesn't create a prototype for main() */
+int _cdecl
+VimMain
+__ARGS((int argc, char **argv));
+static int (_cdecl *pmain)(int, char **);
+
+#ifndef PROTO
+void _cdecl SaveInst(HINSTANCE hInst);
+static void (_cdecl *pSaveInst)(HINSTANCE);
+
+int WINAPI
+WinMain(
+    HINSTANCE	hInstance,
+    HINSTANCE	hPrevInst,
+    LPSTR	lpszCmdLine,
+    int		nCmdShow)
+{
+    int		argc;
+    char	**argv;
+    char	*tofree;
+    char	prog[256];
+
+    /*
+     * Ron: added full path name so that the $VIM variable will get set to our
+     * startup path (so the .vimrc file can be found w/o a VIM env. var.)
+     * Remove the ".exe" extension, and find the 1st non-space.
+     */
+    GetModuleFileName(hInstance, prog, 255);
+    if (*prog != NUL)
+	exe_name = FullName_save((char_u *)prog, FALSE);
+
+    /* Separate the command line into arguments. */
+    argc = get_cmd_args(prog, (char *)lpszCmdLine, &argv, &tofree);
+    if (argc == 0)
+    {
+	/* Error message? */
+	return 0;
+    }
+
+    pSaveInst = SaveInst;
+    pmain = VimMain;
+    pSaveInst(hInstance);
+    pmain(argc, argv);
+
+    free(argv);
+    if (tofree != NULL)
+	free(tofree);
+
+    return 0;
+}
+#endif
+
+
+
+
+
+
+#ifdef FEAT_MOUSE
+
+/*
+ * For the GUI the mouse handling is in gui_w32.c.
+ */
+    void
+mch_setmouse(
+    int on)
+{
+}
+#endif /* FEAT_MOUSE */
+
+
+
+/*
+ * GUI version of mch_init().
+ */
+    void
+mch_init()
+{
+    extern int _fmode;
+
+
+    /* Let critical errors result in a failure, not in a dialog box.  Required
+     * for the timestamp test to work on removed floppies. */
+    SetErrorMode(SEM_FAILCRITICALERRORS);
+
+    _fmode = O_BINARY;		/* we do our own CR-LF translation */
+
+    /* Specify window size.  Is there a place to get the default from? */
+    Rows = 25;
+    Columns = 80;
+
+
+    set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
+
+#ifdef FEAT_CLIPBOARD
+    clip_init(TRUE);
+
+    /*
+     * Vim's own clipboard format recognises whether the text is char, line,
+     * or rectangular block.  Only useful for copying between two Vims.
+     * "VimClipboard" was used for previous versions, using the first
+     * character to specify MCHAR, MLINE or MBLOCK.
+     */
+    clip_star.format = RegisterClipboardFormat("VimClipboard2");
+    clip_star.format_raw = RegisterClipboardFormat("VimRawBytes");
+#endif
+}
+
+
+
+/*
+ * Do we have an interactive window?
+ */
+    int
+mch_check_win(
+    int argc,
+    char **argv)
+{
+    return OK;	    /* GUI always has a tty */
+}
+
+
+/*
+ * return process ID
+ */
+    long
+mch_get_pid()
+{
+    return (long)GetCurrentTask();
+}
+
+
+/*
+ * Specialised version of system().
+ * This version proceeds as follows:
+ *    1. Start the program with WinExec
+ *    2. Wait for the module use count of the program to go to 0
+ *	 (This is the best way of detecting the program has finished)
+ */
+
+    static int
+mch_system(char *cmd, int options)
+{
+    DWORD		ret = 0;
+    UINT		wShowWindow;
+    UINT		h_module;
+    MSG			msg;
+    BOOL		again = TRUE;
+
+    /*
+     * It's nicer to run a filter command in a minimized window, but in
+     */
+    if (options & SHELL_DOOUT)
+	wShowWindow = SW_SHOWMINIMIZED;
+    else
+	wShowWindow = SW_SHOWNORMAL;
+
+    /* Now, run the command */
+    h_module = WinExec((LPCSTR)cmd, wShowWindow);
+
+    if (h_module < 32)
+    {
+	/*error*/
+	ret = -h_module;
+    }
+    else
+    {
+	/* Wait for the command to terminate before continuing */
+	while (GetModuleUsage((HINSTANCE)h_module) > 0 && again )
+	{
+	    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && again)
+	    {
+		if (msg.message == WM_QUIT)
+
+		{
+		    PostQuitMessage(msg.wParam);
+		    again = FALSE;
+		}
+		TranslateMessage(&msg);
+		DispatchMessage(&msg);
+	    }
+	}
+    }
+
+    return ret;
+}
+
+/*
+ * Either execute a command by calling the shell or start a new shell
+ */
+    int
+mch_call_shell(
+    char_u *cmd,
+    int options)	    /* SHELL_, see vim.h */
+{
+    int		x;
+    int		tmode = cur_tmode;
+
+    out_flush();
+
+
+#ifdef MCH_WRITE_DUMP
+    if (fdDump)
+    {
+	fprintf(fdDump, "mch_call_shell(\"%s\", %d)\n", cmd, options);
+	fflush(fdDump);
+    }
+#endif
+
+    /*
+     * Catch all deadly signals while running the external command, because a
+     * CTRL-C, Ctrl-Break or illegal instruction  might otherwise kill us.
+     */
+    signal(SIGINT, SIG_IGN);
+    signal(SIGILL, SIG_IGN);
+    signal(SIGFPE, SIG_IGN);
+    signal(SIGSEGV, SIG_IGN);
+    signal(SIGTERM, SIG_IGN);
+    signal(SIGABRT, SIG_IGN);
+
+    if (options & SHELL_COOKED)
+	settmode(TMODE_COOK);	/* set to normal mode */
+
+    if (cmd == NULL)
+    {
+	x = mch_system(p_sh, options);
+    }
+    else
+    {
+	/* we use "command" or "cmd" to start the shell; slow but easy */
+	char_u *newcmd;
+
+	newcmd = lalloc(
+		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10, TRUE);
+	if (newcmd != NULL)
+	{
+	    if (STRNICMP(cmd, "start ", 6) == 0)
+	    {
+		sprintf((char *)newcmd, "%s\0", cmd+6);
+		if (WinExec((LPCSTR)newcmd, SW_SHOWNORMAL) > 31)
+		    x = 0;
+		else
+		    x = -1;
+	    }
+	    else
+	    {
+		sprintf((char *)newcmd, "%s%s %s %s",
+			"",
+			p_sh,
+			p_shcf,
+			cmd);
+		x = mch_system((char *)newcmd, options);
+	    }
+	    vim_free(newcmd);
+	}
+    }
+
+    if (tmode == TMODE_RAW)
+	settmode(TMODE_RAW);	/* set to raw mode */
+
+    if (x && !(options & SHELL_SILENT) && !emsg_silent)
+    {
+	smsg(_("shell returned %d"), x);
+	msg_putchar('\n');
+    }
+#ifdef FEAT_TITLE
+    resettitle();
+#endif
+
+    signal(SIGINT, SIG_DFL);
+    signal(SIGILL, SIG_DFL);
+    signal(SIGFPE, SIG_DFL);
+    signal(SIGSEGV, SIG_DFL);
+    signal(SIGTERM, SIG_DFL);
+    signal(SIGABRT, SIG_DFL);
+
+
+    return x;
+}
+
+
+/*
+ * Delay for half a second.
+ */
+    void
+mch_delay(
+    long    msec,
+    int	    ignoreinput)
+{
+#ifdef MUST_FIX
+    Sleep((int)msec);	    /* never wait for input */
+#endif
+}
+
+
+/*
+ * check for an "interrupt signal": CTRL-break or CTRL-C
+ */
+    void
+mch_breakcheck()
+{
+    /* never used */
+}
+
+
+/*
+ * How much memory is available in Kbyte?
+ */
+    long_u
+mch_avail_mem(
+    int special)
+{
+    return GetFreeSpace(0) >> 10;
+}
+
+
+/*
+ * Like rename(), returns 0 upon success, non-zero upon failure.
+ * Should probably set errno appropriately when errors occur.
+ */
+    int
+mch_rename(
+    const char	*pszOldFile,
+    const char	*pszNewFile)
+{
+
+    /*
+     * No need to play tricks, this isn't rubbish like Windows 95 <g>
+     */
+    return rename(pszOldFile, pszNewFile);
+
+}
+
+/*
+ * Get the default shell for the current hardware platform
+ */
+    char*
+default_shell()
+{
+    char* psz = NULL;
+
+    psz = "command.com";
+
+    return psz;
+}
diff -urN vim-src/src/os_win16.h vim-qt-src/src/os_win16.h
--- vim-src/src/os_win16.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/os_win16.h	2016-06-08 06:39:27.756315418 +0200
@@ -0,0 +1,143 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * Win16 (Windows 3.1x) machine-dependent things.
+ */
+
+#include "os_dos.h"		/* common MS-DOS and Windows stuff */
+
+#define BINARY_FILE_IO
+#define USE_EXE_NAME		/* use argv[0] for $VIM */
+#define SYNC_DUP_CLOSE		/* sync() a file with dup() and close() */
+#define USE_TERM_CONSOLE
+#define HAVE_STRING_H
+#define HAVE_STRCSPN
+#define HAVE_STRICMP
+#define HAVE_STRNICMP
+#define HAVE_STRFTIME		/* guessed */
+#define HAVE_MEMSET
+#define USE_TMPNAM		/* use tmpnam() instead of mktemp() */
+#define HAVE_LOCALE_H
+#define HAVE_FCNTL_H
+#define HAVE_QSORT
+#define HAVE_ST_MODE		/* have stat.st_mode */
+#define HAVE_MATH_H
+//#define USE_FNAME_CASE	/* adjust case of file names */
+#ifndef FEAT_CLIPBOARD
+# define FEAT_CLIPBOARD		/* include clipboard support */
+#endif
+#if defined(__DATE__) && defined(__TIME__)
+# define HAVE_DATE_TIME
+#endif
+#define HAVE_AVAIL_MEM
+
+#define SHORT_FNAME		/* always 8.3 file name */
+
+#define SMALL_MALLOC		/* 16 bit storage allocation */
+
+#ifdef __BORLANDC__
+# define HAVE_PUTENV		/* at least Bcc 5.2 has it */
+#endif
+
+#ifdef FEAT_GUI_W16
+# define NO_CONSOLE		/* don't included console-only code */
+#endif
+
+/* toupper() is not really broken, but it's very slow.	Probably because of
+ * using unicode characters on Windows NT */
+#define BROKEN_TOUPPER
+
+#define FNAME_ILLEGAL "\"*?><|" /* illegal characters in a file name */
+
+#ifndef VIM_SIZEOF_INT
+# define VIM_SIZEOF_INT 2
+#endif
+
+typedef long off_t;
+
+#include <stdlib.h>
+#include <time.h>
+
+/* cproto fails on missing include files */
+#ifndef PROTO
+# include <dos.h>
+# include <dir.h>
+
+# ifndef STRICT
+#  define STRICT
+# endif
+# ifndef COBJMACROS
+#  define COBJMACROS	/* For OLE: Enable "friendlier" access to objects */
+# endif
+# include <windows.h>
+
+#endif /* PROTO */
+
+/*
+ *  plenty of memory, use large buffers
+ */
+#define CMDBUFFSIZE 1024	/* size of the command processing buffer */
+
+
+#define BASENAMELEN	(MAXPATHL-5)	/* length of base of file name */
+
+#ifndef DFLT_MAXMEM
+# define DFLT_MAXMEM	(256)    /* use up to 256K for a buffer*/
+#endif
+
+#ifndef DFLT_MAXMEMTOT
+# define DFLT_MAXMEMTOT	(5*1024)    /* use up to 5 Mbyte for Vim */
+#endif
+
+/*
+ * Some simple debugging macros that look and behave a lot like their
+ * namesakes in MFC.
+ */
+
+#ifdef _DEBUG
+
+# if defined(_MSC_VER)	&&  (_MSC_VER >= 1000)
+   /* Use the new debugging tools in Visual C++ 4.x */
+#  include <crtdbg.h>
+#  define ASSERT(f) _ASSERT(f)
+# else
+#  include <assert.h>
+#  define ASSERT(f) assert(f)
+# endif
+
+# define TRACE			Trace
+# define TRACE0(sz)		Trace(_T("%s"), _T(sz))
+# define TRACE1(sz, p1)		Trace(_T(sz), p1)
+# define TRACE2(sz, p1, p2)	Trace(_T(sz), p1, p2)
+# define TRACE3(sz, p1, p2, p3) Trace(_T(sz), p1, p2, p3)
+
+/* In debug version, writes trace messages to debug stream */
+void __cdecl
+Trace(char *pszFormat, ...);
+
+#else /* !_DEBUG */
+
+  /* These macros should all compile away to nothing */
+# define ASSERT(f)		((void)0)
+# define TRACE			1 ? (void)0 : printf
+# define TRACE0(sz)
+# define TRACE1(sz, p1)
+# define TRACE2(sz, p1, p2)
+# define TRACE3(sz, p1, p2, p3)
+
+#endif /* !_DEBUG */
+
+
+#define ASSERT_POINTER(p, type) \
+    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))
+
+#define ASSERT_NULL_OR_POINTER(p, type) \
+    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))
+
+#define mch_setenv(name, val, x) setenv(name, val, x)
diff -urN vim-src/src/os_win32.c vim-qt-src/src/os_win32.c
--- vim-src/src/os_win32.c	2016-06-08 06:34:09.817884977 +0200
+++ vim-qt-src/src/os_win32.c	2016-06-08 06:40:09.648637492 +0200
@@ -2087,9 +2087,9 @@
     if (!executable_exists("findstr.exe", NULL))
 	set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
     win_clip_init();
-#endif
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 }
 
 
@@ -2570,9 +2570,9 @@
     g_fMouseAvail = GetSystemMetrics(SM_MOUSEPRESENT);
 #endif
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
     win_clip_init();
-#endif
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 
     /* This will be NULL on anything but NT 4.0 */
     s_pfnGetConsoleKeyboardLayoutName =
diff -urN vim-src/src/pathdef.cmake.in vim-qt-src/src/pathdef.cmake.in
--- vim-src/src/pathdef.cmake.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/pathdef.cmake.in	2016-06-08 06:39:27.757315426 +0200
@@ -0,0 +1,7 @@
+#include "vim.h"
+char_u *default_vim_dir = (char_u *)"${CMAKE_INSTALL_PREFIX}/share/vim/current";
+char_u *default_vimruntime_dir = (char_u *)"";
+char_u *all_cflags = (char_u *)"gcc -c -I. -Iproto -DHAVE_CONFIG_H -DFEAT_GUI_ATHENA -DFUNCPROTO=15 -DNARROWPROTO    -g -O2 -D_FORTIFY_SOURCE=1      ";
+char_u *all_lflags = (char_u *)"gcc   -L/usr/local/lib -o vim -lXaw -lXmu -lXext -lXt -lSM -lICE -lXpm -lXt -lX11 -lXdmcp -lSM -lICE -ldl -lm -lncurses -lnsl  -lacl -lattr -lgpm          ";
+char_u *compiled_user = (char_u *)"raf-r";
+char_u *compiled_sys = (char_u *)"${SITE_NAME}";
diff -urN vim-src/src/proto/gui_qt.pro vim-qt-src/src/proto/gui_qt.pro
--- vim-src/src/proto/gui_qt.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/proto/gui_qt.pro	2016-06-08 06:40:09.657637562 +0200
@@ -0,0 +1,84 @@
+
+/* Prototypes - I am probably missing something here */
+
+char_u *gui_mch_get_fontname (GuiFont font, char_u *name);
+int gui_mch_get_winpos (int *x, int *y);
+void gui_mch_set_winpos (int x, int y);
+GuiFont gui_mch_get_font (char_u *name, int giveErrorIfMissing);
+void gui_mch_set_foreground (void);
+void gui_mch_enable_scrollbar (scrollbar_T *sb, int flag);
+void gui_mch_free_font (GuiFont font);
+void gui_mch_set_curtab (int nr);
+void gui_mch_setmouse (int x, int y);
+void gui_mch_settitle (char_u *title, char_u *icon);
+void gui_mch_add_menu_item (vimmenu_T *menu, int idx);
+void gui_mch_add_menu (vimmenu_T *menu, int pos);
+void gui_mch_destroy_menu (vimmenu_T *menu);
+void gui_mch_draw_menubar (void);
+void gui_mch_show_popupmenu (vimmenu_T *menu);
+int gui_mch_dialog (int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd);
+char_u *gui_mch_browse (int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter);
+void gui_mch_menu_hidden (vimmenu_T *menu, int hidden);
+void gui_mch_menu_grey (vimmenu_T *menu, int grey);
+void gui_mch_update_tabline (void);
+void gui_mch_getmouse (int *x, int *y);
+int gui_mch_adjust_charheight (void);
+void gui_mch_update (void);
+void gui_mch_prepare (int *argc, char **argv);
+int gui_mch_init_check (void);
+int gui_mch_init (void);
+int gui_mch_open (void);
+void gui_mch_exit (int);
+int gui_mch_init_font (char_u *font_name, int fontset);
+void gui_mch_set_font (GuiFont font);
+void gui_mch_iconify (void);
+void gui_mch_invert_rectangle (int r, int c, int nr, int nc);
+void clip_mch_lose_selection (VimClipboard *cbd);
+void clip_mch_request_selection (VimClipboard *cbd);
+void clip_mch_set_selection (VimClipboard *cbd);
+int clip_mch_own_selection (VimClipboard *cbd);
+void gui_mch_enable_scrollbar (scrollbar_T *sb, int flag);
+void gui_mch_set_scrollbar_thumb (scrollbar_T *sb, long val, long size, long max);
+void gui_mch_set_scrollbar_pos (scrollbar_T *sb, int x, int y, int w, int h);
+void gui_mch_create_scrollbar (scrollbar_T *sb, int orient);
+void gui_mch_destroy_scrollbar (scrollbar_T *sb);
+guicolor_T gui_mch_get_color (char_u *name);
+void gui_mch_mousehide (int hide);
+void gui_mch_flush (void);
+int gui_mch_haskey (char_u *name);
+void gui_mch_beep (void);
+void gui_mch_flash (int msec);
+int gui_mch_is_blinking(void);
+void gui_mch_set_blinking (long wait, long on, long off);
+void gui_mch_stop_blink (void);
+void gui_mch_start_blink (void);
+void mch_set_mouse_shape (int shape);
+char_u *gui_mch_font_dialog (char_u *oldval);
+void gui_mch_show_toolbar (int showit);
+void gui_mch_new_colors (void);
+long_u gui_mch_get_rgb (guicolor_T pixel);
+int gui_mch_wait_for_chars (long int wtime);
+void gui_mch_draw_hollow_cursor (guicolor_T color);
+void gui_mch_draw_part_cursor (int w, int h, guicolor_T color);
+void gui_mch_set_menu_pos (int x, int y, int w, int h);
+void gui_mch_set_text_area_pos (int x, int y, int w, int h);
+void gui_mch_get_screen_dimensions (int *screen_w, int *screen_h);
+void gui_mch_set_shellsize (int width, int height, int min_width, int min_height, int base_width, int base_height, int direction);
+void gui_mch_clear_block (int row1, int col1, int row2, int col2);
+void gui_mch_set_fg_color (guicolor_T color);
+void gui_mch_set_bg_color (guicolor_T color);
+void gui_mch_set_sp_color (guicolor_T color);
+void gui_mch_delete_lines (int row, int num_lines);
+void gui_mch_insert_lines (int row, int num_lines);
+void gui_mch_clear_all (void);
+void gui_mch_draw_string (int row, int col, char_u *s, int len, int flags);
+int gui_mch_showing_tabline (void);
+void gui_mch_enable_menu (int flag);
+void gui_mch_show_tabline (int showit);
+void gui_mch_enter_fullscreen (void);
+void gui_mch_leave_fullscreen (void);
+void* gui_mch_register_sign (char_u *signfile);
+void gui_mch_destroy_sign (void *sign);
+void gui_mch_drawsign (int row, int col, int typenr);
+void gui_mch_update_fuoptions (char_u *optstr);
+
diff -urN vim-src/src/proto/gui_w16.pro vim-qt-src/src/proto/gui_w16.pro
--- vim-src/src/proto/gui_w16.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/proto/gui_w16.pro	2016-06-08 06:39:27.795315718 +0200
@@ -0,0 +1,80 @@
+/* gui_w16.c */
+void gui_mch_set_blinking __ARGS((long wait, long on, long off));
+void gui_mch_stop_blink __ARGS((void));
+void gui_mch_start_blink __ARGS((void));
+LRESULT WINAPI vim_WindowProc __ARGS((HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam));
+void gui_mch_new_colors __ARGS((void));
+void gui_mch_def_colors __ARGS((void));
+int gui_mch_open __ARGS((void));
+int gui_mch_get_winpos __ARGS((int *x, int *y));
+void gui_mch_set_winpos __ARGS((int x, int y));
+void gui_mch_set_text_area_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_enable_scrollbar __ARGS((scrollbar_T *sb, int flag));
+void gui_mch_set_scrollbar_pos __ARGS((scrollbar_T *sb, int x, int y, int w, int h));
+void gui_mch_create_scrollbar __ARGS((scrollbar_T *sb, int orient));
+int gui_mch_adjust_charheight __ARGS((void));
+GuiFont gui_mch_get_font __ARGS((char_u *name, int giveErrorIfMissing));
+char_u *gui_mch_get_fontname __ARGS((GuiFont font, char_u *name));
+void gui_mch_free_font __ARGS((GuiFont font));
+guicolor_T gui_mch_get_color __ARGS((char_u *name));
+int gui_mch_haskey __ARGS((char_u *name));
+void gui_mch_beep __ARGS((void));
+void gui_mch_invert_rectangle __ARGS((int r, int c, int nr, int nc));
+void gui_mch_iconify __ARGS((void));
+void gui_mch_draw_hollow_cursor __ARGS((guicolor_T color));
+void gui_mch_draw_part_cursor __ARGS((int w, int h, guicolor_T color));
+void gui_mch_update __ARGS((void));
+int gui_mch_wait_for_chars __ARGS((int wtime));
+void gui_mch_clear_block __ARGS((int row1, int col1, int row2, int col2));
+void gui_mch_clear_all __ARGS((void));
+void gui_mch_enable_menu __ARGS((int flag));
+void gui_mch_set_menu_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_menu_hidden __ARGS((vimmenu_T *menu, int hidden));
+void gui_mch_draw_menubar __ARGS((void));
+long_u gui_mch_get_rgb __ARGS((guicolor_T pixel));
+void gui_mch_activate_window __ARGS((void));
+void gui_mch_show_toolbar __ARGS((int showit));
+void gui_mch_show_tabline __ARGS((int showit));
+int gui_mch_showing_tabline __ARGS((void));
+void gui_mch_update_tabline __ARGS((void));
+void gui_mch_set_curtab __ARGS((int nr));
+void ex_simalt __ARGS((exarg_T *eap));
+void gui_mch_find_dialog __ARGS((exarg_T *eap));
+void gui_mch_replace_dialog __ARGS((exarg_T *eap));
+void gui_mch_mousehide __ARGS((int hide));
+void gui_mch_destroy_scrollbar __ARGS((scrollbar_T *sb));
+void gui_mch_getmouse __ARGS((int *x, int *y));
+void gui_mch_setmouse __ARGS((int x, int y));
+void gui_mch_flash __ARGS((int msec));
+void gui_mch_delete_lines __ARGS((int row, int num_lines));
+void gui_mch_insert_lines __ARGS((int row, int num_lines));
+void gui_mch_exit __ARGS((int rc));
+void gui_mch_wide_font_changed __ARGS((void));
+int gui_mch_init_font __ARGS((char_u *font_name, int fontset));
+int gui_mch_maximized __ARGS((void));
+void gui_mch_newfont __ARGS((void));
+void gui_mch_settitle __ARGS((char_u *title, char_u *icon));
+void mch_set_mouse_shape __ARGS((int shape));
+char_u *gui_mch_browsedir __ARGS((char_u *title, char_u *initdir));
+char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
+int get_cmd_args __ARGS((char *prog, char *cmdline, char ***argvp, char **tofree));
+void gui_mch_prepare __ARGS((int *argc, char **argv));
+int gui_mch_init __ARGS((void));
+void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
+void gui_mch_set_scrollbar_thumb __ARGS((scrollbar_T *sb, long val, long size, long max));
+void gui_mch_set_font __ARGS((GuiFont font));
+void gui_mch_set_fg_color __ARGS((guicolor_T color));
+void gui_mch_set_bg_color __ARGS((guicolor_T color));
+void gui_mch_set_sp_color __ARGS((guicolor_T color));
+void gui_mch_draw_string __ARGS((int row, int col, char_u *text, int len, int flags));
+void gui_mch_flush __ARGS((void));
+void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
+void gui_mch_add_menu __ARGS((vimmenu_T *menu, int pos));
+void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
+void gui_make_popup __ARGS((char_u *path_name, int mouse_pos));
+void gui_mch_add_menu_item __ARGS((vimmenu_T *menu, int idx));
+void gui_mch_destroy_menu __ARGS((vimmenu_T *menu));
+void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
+void gui_mch_set_foreground __ARGS((void));
+/* vim: set ft=c : */
diff -urN vim-src/src/proto/os_msdos.pro vim-qt-src/src/proto/os_msdos.pro
--- vim-src/src/proto/os_msdos.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/proto/os_msdos.pro	2016-06-08 06:39:27.796315726 +0200
@@ -0,0 +1,48 @@
+/* os_msdos.c */
+void mch_set_normal_colors __ARGS((void));
+void mch_update_cursor __ARGS((void));
+long_u mch_avail_mem __ARGS((int special));
+void mch_delay __ARGS((long msec, int ignoreinput));
+void mch_write __ARGS((char_u *s, int len));
+int mch_inchar __ARGS((char_u *buf, int maxlen, long time, int tb_change_cnt));
+int mch_char_avail __ARGS((void));
+void mch_suspend __ARGS((void));
+void mch_init __ARGS((void));
+int mch_check_win __ARGS((int argc, char **argv));
+int mch_input_isatty __ARGS((void));
+void fname_case __ARGS((char_u *name, int len));
+long mch_get_pid __ARGS((void));
+int mch_FullName __ARGS((char_u *fname, char_u *buf, int len, int force));
+void slash_adjust __ARGS((char_u *p));
+int mch_isFullName __ARGS((char_u *fname));
+void mch_early_init __ARGS((void));
+void mch_exit __ARGS((int r));
+void mch_settmode __ARGS((int tmode));
+void mch_setmouse __ARGS((int on));
+int mch_screenmode __ARGS((char_u *arg));
+int mch_get_shellsize __ARGS((void));
+void mch_set_shellsize __ARGS((void));
+void mch_new_shellsize __ARGS((void));
+void mch_check_columns __ARGS((void));
+int mch_call_shell __ARGS((char_u *cmd, int options));
+void mch_breakcheck __ARGS((void));
+int mch_has_exp_wildcard __ARGS((char_u *p));
+int mch_has_wildcard __ARGS((char_u *p));
+int mch_chdir __ARGS((char *path));
+char *djgpp_setlocale __ARGS((void));
+int clip_mch_own_selection __ARGS((VimClipboard *cbd));
+void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
+void clip_mch_request_selection __ARGS((VimClipboard *cbd));
+void clip_mch_set_selection __ARGS((VimClipboard *cbd));
+long mch_getperm __ARGS((char_u *name));
+int mch_setperm __ARGS((char_u *name, long perm));
+void mch_hide __ARGS((char_u *name));
+int mch_isdir __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name, char_u **path, int use_path));
+int mch_nodetype __ARGS((char_u *name));
+int mch_dirname __ARGS((char_u *buf, int len));
+int mch_remove __ARGS((char_u *name));
+char_u *mch_getenv __ARGS((char_u *name));
+int mch_get_user_name __ARGS((char_u *s, int len));
+void mch_get_host_name __ARGS((char_u *s, int len));
+/* vim: set ft=c : */
diff -urN vim-src/src/proto/os_win16.pro vim-qt-src/src/proto/os_win16.pro
--- vim-src/src/proto/os_win16.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/proto/os_win16.pro	2016-06-08 06:39:27.796315726 +0200
@@ -0,0 +1,12 @@
+/* os_win16.c */
+void mch_setmouse __ARGS((int on));
+void mch_init __ARGS((void));
+int mch_check_win __ARGS((int argc, char **argv));
+long mch_get_pid __ARGS((void));
+int mch_call_shell __ARGS((char_u *cmd, int options));
+void mch_delay __ARGS((long msec, int ignoreinput));
+void mch_breakcheck __ARGS((void));
+long_u mch_avail_mem __ARGS((int special));
+int mch_rename __ARGS((const char *pszOldFile, const char *pszNewFile));
+char *default_shell __ARGS((void));
+/* vim: set ft=c : */
diff -urN vim-src/src/proto.h vim-qt-src/src/proto.h
--- vim-src/src/proto.h	2016-03-27 19:08:37.234722867 +0200
+++ vim-qt-src/src/proto.h	2016-06-08 06:40:09.653637531 +0200
@@ -237,6 +237,9 @@
 #  ifdef FEAT_SUN_WORKSHOP
 #   include "workshop.pro"
 #  endif
+#  ifdef FEAT_GUI_QT
+#   include "gui_qt.pro"
+#  endif
 # endif	/* FEAT_GUI */
 
 # ifdef FEAT_OLE
diff -urN vim-src/src/qt/colortable.cpp vim-qt-src/src/qt/colortable.cpp
--- vim-src/src/qt/colortable.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/colortable.cpp	2016-06-08 06:39:27.797315734 +0200
@@ -0,0 +1,697 @@
+#include "colortable.h"
+
+
+ColorTable ColorTable::m_instance;
+
+ColorTable::ColorTable()
+{
+	ColorTable& m_colorMap = m_instance;
+
+	/*
+	 * For some reason these are not in rgb.txt
+	 */
+	m_colorMap["lightmagenta"] = QColor(255, 160, 240);
+	m_colorMap["lightred"] = QColor(255, 160, 160);
+
+	/*
+	 * DONT EDIT - auto generated from rgb.txt
+	 */
+	m_colorMap["snow"] = QColor(255, 250, 250);
+	m_colorMap["ghostwhite"] = QColor(248, 248, 255);
+	m_colorMap["whitesmoke"] = QColor(245, 245, 245);
+	m_colorMap["gainsboro"] = QColor(220, 220, 220);
+	m_colorMap["floralwhite"] = QColor(255, 250, 240);
+	m_colorMap["oldlace"] = QColor(253, 245, 230);
+	m_colorMap["linen"] = QColor(250, 240, 230);
+	m_colorMap["antiquewhite"] = QColor(250, 235, 215);
+	m_colorMap["papayawhip"] = QColor(255, 239, 213);
+	m_colorMap["blanchedalmond"] = QColor(255, 235, 205);
+	m_colorMap["bisque"] = QColor(255, 228, 196);
+	m_colorMap["peachpuff"] = QColor(255, 218, 185);
+	m_colorMap["navajowhite"] = QColor(255, 222, 173);
+	m_colorMap["moccasin"] = QColor(255, 228, 181);
+	m_colorMap["cornsilk"] = QColor(255, 248, 220);
+	m_colorMap["ivory"] = QColor(255, 255, 240);
+	m_colorMap["lemonchiffon"] = QColor(255, 250, 205);
+	m_colorMap["seashell"] = QColor(255, 245, 238);
+	m_colorMap["honeydew"] = QColor(240, 255, 240);
+	m_colorMap["mintcream"] = QColor(245, 255, 250);
+	m_colorMap["azure"] = QColor(240, 255, 255);
+	m_colorMap["aliceblue"] = QColor(240, 248, 255);
+	m_colorMap["lavender"] = QColor(230, 230, 250);
+	m_colorMap["lavenderblush"] = QColor(255, 240, 245);
+	m_colorMap["mistyrose"] = QColor(255, 228, 225);
+	m_colorMap["white"] = QColor(255, 255, 255);
+	m_colorMap["black"] = QColor(0, 0, 0);
+	m_colorMap["darkslategray"] = QColor(47, 79, 79);
+	m_colorMap["darkslategrey"] = QColor(47, 79, 79);
+	m_colorMap["dimgray"] = QColor(105, 105, 105);
+	m_colorMap["dimgrey"] = QColor(105, 105, 105);
+	m_colorMap["slategray"] = QColor(112, 128, 144);
+	m_colorMap["slategrey"] = QColor(112, 128, 144);
+	m_colorMap["lightslategray"] = QColor(119, 136, 153);
+	m_colorMap["lightslategrey"] = QColor(119, 136, 153);
+	m_colorMap["gray"] = QColor(190, 190, 190);
+	m_colorMap["grey"] = QColor(190, 190, 190);
+	m_colorMap["lightgrey"] = QColor(211, 211, 211);
+	m_colorMap["lightgray"] = QColor(211, 211, 211);
+	m_colorMap["midnightblue"] = QColor(25, 25, 112);
+	m_colorMap["navy"] = QColor(0, 0, 128);
+	m_colorMap["navyblue"] = QColor(0, 0, 128);
+	m_colorMap["cornflowerblue"] = QColor(100, 149, 237);
+	m_colorMap["darkslateblue"] = QColor(72, 61, 139);
+	m_colorMap["slateblue"] = QColor(106, 90, 205);
+	m_colorMap["mediumslateblue"] = QColor(123, 104, 238);
+	m_colorMap["lightslateblue"] = QColor(132, 112, 255);
+	m_colorMap["mediumblue"] = QColor(0, 0, 205);
+	m_colorMap["royalblue"] = QColor(65, 105, 225);
+	m_colorMap["blue"] = QColor(0, 0, 255);
+	m_colorMap["dodgerblue"] = QColor(30, 144, 255);
+	m_colorMap["deepskyblue"] = QColor(0, 191, 255);
+	m_colorMap["skyblue"] = QColor(135, 206, 235);
+	m_colorMap["lightskyblue"] = QColor(135, 206, 250);
+	m_colorMap["steelblue"] = QColor(70, 130, 180);
+	m_colorMap["lightsteelblue"] = QColor(176, 196, 222);
+	m_colorMap["lightblue"] = QColor(173, 216, 230);
+	m_colorMap["powderblue"] = QColor(176, 224, 230);
+	m_colorMap["paleturquoise"] = QColor(175, 238, 238);
+	m_colorMap["darkturquoise"] = QColor(0, 206, 209);
+	m_colorMap["mediumturquoise"] = QColor(72, 209, 204);
+	m_colorMap["turquoise"] = QColor(64, 224, 208);
+	m_colorMap["cyan"] = QColor(0, 255, 255);
+	m_colorMap["lightcyan"] = QColor(224, 255, 255);
+	m_colorMap["cadetblue"] = QColor(95, 158, 160);
+	m_colorMap["mediumaquamarine"] = QColor(102, 205, 170);
+	m_colorMap["aquamarine"] = QColor(127, 255, 212);
+	m_colorMap["darkgreen"] = QColor(0, 100, 0);
+	m_colorMap["darkolivegreen"] = QColor(85, 107, 47);
+	m_colorMap["darkseagreen"] = QColor(143, 188, 143);
+	m_colorMap["seagreen"] = QColor(46, 139, 87);
+	m_colorMap["mediumseagreen"] = QColor(60, 179, 113);
+	m_colorMap["lightseagreen"] = QColor(32, 178, 170);
+	m_colorMap["palegreen"] = QColor(152, 251, 152);
+	m_colorMap["springgreen"] = QColor(0, 255, 127);
+	m_colorMap["lawngreen"] = QColor(124, 252, 0);
+	m_colorMap["green"] = QColor(0, 255, 0);
+	m_colorMap["chartreuse"] = QColor(127, 255, 0);
+	m_colorMap["mediumspringgreen"] = QColor(0, 250, 154);
+	m_colorMap["greenyellow"] = QColor(173, 255, 47);
+	m_colorMap["limegreen"] = QColor(50, 205, 50);
+	m_colorMap["yellowgreen"] = QColor(154, 205, 50);
+	m_colorMap["forestgreen"] = QColor(34, 139, 34);
+	m_colorMap["olivedrab"] = QColor(107, 142, 35);
+	m_colorMap["darkkhaki"] = QColor(189, 183, 107);
+	m_colorMap["khaki"] = QColor(240, 230, 140);
+	m_colorMap["palegoldenrod"] = QColor(238, 232, 170);
+	m_colorMap["lightgoldenrodyellow"] = QColor(250, 250, 210);
+	m_colorMap["lightyellow"] = QColor(255, 255, 224);
+	m_colorMap["yellow"] = QColor(255, 255, 0);
+	m_colorMap["gold"] = QColor(255, 215, 0);
+	m_colorMap["lightgoldenrod"] = QColor(238, 221, 130);
+	m_colorMap["goldenrod"] = QColor(218, 165, 32);
+	m_colorMap["darkgoldenrod"] = QColor(184, 134, 11);
+	m_colorMap["rosybrown"] = QColor(188, 143, 143);
+	m_colorMap["indianred"] = QColor(205, 92, 92);
+	m_colorMap["saddlebrown"] = QColor(139, 69, 19);
+	m_colorMap["sienna"] = QColor(160, 82, 45);
+	m_colorMap["peru"] = QColor(205, 133, 63);
+	m_colorMap["burlywood"] = QColor(222, 184, 135);
+	m_colorMap["beige"] = QColor(245, 245, 220);
+	m_colorMap["wheat"] = QColor(245, 222, 179);
+	m_colorMap["sandybrown"] = QColor(244, 164, 96);
+	m_colorMap["tan"] = QColor(210, 180, 140);
+	m_colorMap["chocolate"] = QColor(210, 105, 30);
+	m_colorMap["firebrick"] = QColor(178, 34, 34);
+	m_colorMap["brown"] = QColor(165, 42, 42);
+	m_colorMap["darksalmon"] = QColor(233, 150, 122);
+	m_colorMap["salmon"] = QColor(250, 128, 114);
+	m_colorMap["lightsalmon"] = QColor(255, 160, 122);
+	m_colorMap["orange"] = QColor(255, 165, 0);
+	m_colorMap["darkorange"] = QColor(255, 140, 0);
+	m_colorMap["coral"] = QColor(255, 127, 80);
+	m_colorMap["lightcoral"] = QColor(240, 128, 128);
+	m_colorMap["tomato"] = QColor(255, 99, 71);
+	m_colorMap["orangered"] = QColor(255, 69, 0);
+	m_colorMap["red"] = QColor(255, 0, 0);
+	m_colorMap["hotpink"] = QColor(255, 105, 180);
+	m_colorMap["deeppink"] = QColor(255, 20, 147);
+	m_colorMap["pink"] = QColor(255, 192, 203);
+	m_colorMap["lightpink"] = QColor(255, 182, 193);
+	m_colorMap["palevioletred"] = QColor(219, 112, 147);
+	m_colorMap["maroon"] = QColor(176, 48, 96);
+	m_colorMap["mediumvioletred"] = QColor(199, 21, 133);
+	m_colorMap["violetred"] = QColor(208, 32, 144);
+	m_colorMap["magenta"] = QColor(255, 0, 255);
+	m_colorMap["violet"] = QColor(238, 130, 238);
+	m_colorMap["plum"] = QColor(221, 160, 221);
+	m_colorMap["orchid"] = QColor(218, 112, 214);
+	m_colorMap["mediumorchid"] = QColor(186, 85, 211);
+	m_colorMap["darkorchid"] = QColor(153, 50, 204);
+	m_colorMap["darkviolet"] = QColor(148, 0, 211);
+	m_colorMap["blueviolet"] = QColor(138, 43, 226);
+	m_colorMap["purple"] = QColor(160, 32, 240);
+	m_colorMap["mediumpurple"] = QColor(147, 112, 219);
+	m_colorMap["thistle"] = QColor(216, 191, 216);
+	m_colorMap["snow1"] = QColor(255, 250, 250);
+	m_colorMap["snow2"] = QColor(238, 233, 233);
+	m_colorMap["snow3"] = QColor(205, 201, 201);
+	m_colorMap["snow4"] = QColor(139, 137, 137);
+	m_colorMap["seashell1"] = QColor(255, 245, 238);
+	m_colorMap["seashell2"] = QColor(238, 229, 222);
+	m_colorMap["seashell3"] = QColor(205, 197, 191);
+	m_colorMap["seashell4"] = QColor(139, 134, 130);
+	m_colorMap["antiquewhite1"] = QColor(255, 239, 219);
+	m_colorMap["antiquewhite2"] = QColor(238, 223, 204);
+	m_colorMap["antiquewhite3"] = QColor(205, 192, 176);
+	m_colorMap["antiquewhite4"] = QColor(139, 131, 120);
+	m_colorMap["bisque1"] = QColor(255, 228, 196);
+	m_colorMap["bisque2"] = QColor(238, 213, 183);
+	m_colorMap["bisque3"] = QColor(205, 183, 158);
+	m_colorMap["bisque4"] = QColor(139, 125, 107);
+	m_colorMap["peachpuff1"] = QColor(255, 218, 185);
+	m_colorMap["peachpuff2"] = QColor(238, 203, 173);
+	m_colorMap["peachpuff3"] = QColor(205, 175, 149);
+	m_colorMap["peachpuff4"] = QColor(139, 119, 101);
+	m_colorMap["navajowhite1"] = QColor(255, 222, 173);
+	m_colorMap["navajowhite2"] = QColor(238, 207, 161);
+	m_colorMap["navajowhite3"] = QColor(205, 179, 139);
+	m_colorMap["navajowhite4"] = QColor(139, 121, 94);
+	m_colorMap["lemonchiffon1"] = QColor(255, 250, 205);
+	m_colorMap["lemonchiffon2"] = QColor(238, 233, 191);
+	m_colorMap["lemonchiffon3"] = QColor(205, 201, 165);
+	m_colorMap["lemonchiffon4"] = QColor(139, 137, 112);
+	m_colorMap["cornsilk1"] = QColor(255, 248, 220);
+	m_colorMap["cornsilk2"] = QColor(238, 232, 205);
+	m_colorMap["cornsilk3"] = QColor(205, 200, 177);
+	m_colorMap["cornsilk4"] = QColor(139, 136, 120);
+	m_colorMap["ivory1"] = QColor(255, 255, 240);
+	m_colorMap["ivory2"] = QColor(238, 238, 224);
+	m_colorMap["ivory3"] = QColor(205, 205, 193);
+	m_colorMap["ivory4"] = QColor(139, 139, 131);
+	m_colorMap["honeydew1"] = QColor(240, 255, 240);
+	m_colorMap["honeydew2"] = QColor(224, 238, 224);
+	m_colorMap["honeydew3"] = QColor(193, 205, 193);
+	m_colorMap["honeydew4"] = QColor(131, 139, 131);
+	m_colorMap["lavenderblush1"] = QColor(255, 240, 245);
+	m_colorMap["lavenderblush2"] = QColor(238, 224, 229);
+	m_colorMap["lavenderblush3"] = QColor(205, 193, 197);
+	m_colorMap["lavenderblush4"] = QColor(139, 131, 134);
+	m_colorMap["mistyrose1"] = QColor(255, 228, 225);
+	m_colorMap["mistyrose2"] = QColor(238, 213, 210);
+	m_colorMap["mistyrose3"] = QColor(205, 183, 181);
+	m_colorMap["mistyrose4"] = QColor(139, 125, 123);
+	m_colorMap["azure1"] = QColor(240, 255, 255);
+	m_colorMap["azure2"] = QColor(224, 238, 238);
+	m_colorMap["azure3"] = QColor(193, 205, 205);
+	m_colorMap["azure4"] = QColor(131, 139, 139);
+	m_colorMap["slateblue1"] = QColor(131, 111, 255);
+	m_colorMap["slateblue2"] = QColor(122, 103, 238);
+	m_colorMap["slateblue3"] = QColor(105, 89, 205);
+	m_colorMap["slateblue4"] = QColor(71, 60, 139);
+	m_colorMap["royalblue1"] = QColor(72, 118, 255);
+	m_colorMap["royalblue2"] = QColor(67, 110, 238);
+	m_colorMap["royalblue3"] = QColor(58, 95, 205);
+	m_colorMap["royalblue4"] = QColor(39, 64, 139);
+	m_colorMap["blue1"] = QColor(0, 0, 255);
+	m_colorMap["blue2"] = QColor(0, 0, 238);
+	m_colorMap["blue3"] = QColor(0, 0, 205);
+	m_colorMap["blue4"] = QColor(0, 0, 139);
+	m_colorMap["dodgerblue1"] = QColor(30, 144, 255);
+	m_colorMap["dodgerblue2"] = QColor(28, 134, 238);
+	m_colorMap["dodgerblue3"] = QColor(24, 116, 205);
+	m_colorMap["dodgerblue4"] = QColor(16, 78, 139);
+	m_colorMap["steelblue1"] = QColor(99, 184, 255);
+	m_colorMap["steelblue2"] = QColor(92, 172, 238);
+	m_colorMap["steelblue3"] = QColor(79, 148, 205);
+	m_colorMap["steelblue4"] = QColor(54, 100, 139);
+	m_colorMap["deepskyblue1"] = QColor(0, 191, 255);
+	m_colorMap["deepskyblue2"] = QColor(0, 178, 238);
+	m_colorMap["deepskyblue3"] = QColor(0, 154, 205);
+	m_colorMap["deepskyblue4"] = QColor(0, 104, 139);
+	m_colorMap["skyblue1"] = QColor(135, 206, 255);
+	m_colorMap["skyblue2"] = QColor(126, 192, 238);
+	m_colorMap["skyblue3"] = QColor(108, 166, 205);
+	m_colorMap["skyblue4"] = QColor(74, 112, 139);
+	m_colorMap["lightskyblue1"] = QColor(176, 226, 255);
+	m_colorMap["lightskyblue2"] = QColor(164, 211, 238);
+	m_colorMap["lightskyblue3"] = QColor(141, 182, 205);
+	m_colorMap["lightskyblue4"] = QColor(96, 123, 139);
+	m_colorMap["slategray1"] = QColor(198, 226, 255);
+	m_colorMap["slategray2"] = QColor(185, 211, 238);
+	m_colorMap["slategray3"] = QColor(159, 182, 205);
+	m_colorMap["slategray4"] = QColor(108, 123, 139);
+	m_colorMap["lightsteelblue1"] = QColor(202, 225, 255);
+	m_colorMap["lightsteelblue2"] = QColor(188, 210, 238);
+	m_colorMap["lightsteelblue3"] = QColor(162, 181, 205);
+	m_colorMap["lightsteelblue4"] = QColor(110, 123, 139);
+	m_colorMap["lightblue1"] = QColor(191, 239, 255);
+	m_colorMap["lightblue2"] = QColor(178, 223, 238);
+	m_colorMap["lightblue3"] = QColor(154, 192, 205);
+	m_colorMap["lightblue4"] = QColor(104, 131, 139);
+	m_colorMap["lightcyan1"] = QColor(224, 255, 255);
+	m_colorMap["lightcyan2"] = QColor(209, 238, 238);
+	m_colorMap["lightcyan3"] = QColor(180, 205, 205);
+	m_colorMap["lightcyan4"] = QColor(122, 139, 139);
+	m_colorMap["paleturquoise1"] = QColor(187, 255, 255);
+	m_colorMap["paleturquoise2"] = QColor(174, 238, 238);
+	m_colorMap["paleturquoise3"] = QColor(150, 205, 205);
+	m_colorMap["paleturquoise4"] = QColor(102, 139, 139);
+	m_colorMap["cadetblue1"] = QColor(152, 245, 255);
+	m_colorMap["cadetblue2"] = QColor(142, 229, 238);
+	m_colorMap["cadetblue3"] = QColor(122, 197, 205);
+	m_colorMap["cadetblue4"] = QColor(83, 134, 139);
+	m_colorMap["turquoise1"] = QColor(0, 245, 255);
+	m_colorMap["turquoise2"] = QColor(0, 229, 238);
+	m_colorMap["turquoise3"] = QColor(0, 197, 205);
+	m_colorMap["turquoise4"] = QColor(0, 134, 139);
+	m_colorMap["cyan1"] = QColor(0, 255, 255);
+	m_colorMap["cyan2"] = QColor(0, 238, 238);
+	m_colorMap["cyan3"] = QColor(0, 205, 205);
+	m_colorMap["cyan4"] = QColor(0, 139, 139);
+	m_colorMap["darkslategray1"] = QColor(151, 255, 255);
+	m_colorMap["darkslategray2"] = QColor(141, 238, 238);
+	m_colorMap["darkslategray3"] = QColor(121, 205, 205);
+	m_colorMap["darkslategray4"] = QColor(82, 139, 139);
+	m_colorMap["aquamarine1"] = QColor(127, 255, 212);
+	m_colorMap["aquamarine2"] = QColor(118, 238, 198);
+	m_colorMap["aquamarine3"] = QColor(102, 205, 170);
+	m_colorMap["aquamarine4"] = QColor(69, 139, 116);
+	m_colorMap["darkseagreen1"] = QColor(193, 255, 193);
+	m_colorMap["darkseagreen2"] = QColor(180, 238, 180);
+	m_colorMap["darkseagreen3"] = QColor(155, 205, 155);
+	m_colorMap["darkseagreen4"] = QColor(105, 139, 105);
+	m_colorMap["seagreen1"] = QColor(84, 255, 159);
+	m_colorMap["seagreen2"] = QColor(78, 238, 148);
+	m_colorMap["seagreen3"] = QColor(67, 205, 128);
+	m_colorMap["seagreen4"] = QColor(46, 139, 87);
+	m_colorMap["palegreen1"] = QColor(154, 255, 154);
+	m_colorMap["palegreen2"] = QColor(144, 238, 144);
+	m_colorMap["palegreen3"] = QColor(124, 205, 124);
+	m_colorMap["palegreen4"] = QColor(84, 139, 84);
+	m_colorMap["springgreen1"] = QColor(0, 255, 127);
+	m_colorMap["springgreen2"] = QColor(0, 238, 118);
+	m_colorMap["springgreen3"] = QColor(0, 205, 102);
+	m_colorMap["springgreen4"] = QColor(0, 139, 69);
+	m_colorMap["green1"] = QColor(0, 255, 0);
+	m_colorMap["green2"] = QColor(0, 238, 0);
+	m_colorMap["green3"] = QColor(0, 205, 0);
+	m_colorMap["green4"] = QColor(0, 139, 0);
+	m_colorMap["chartreuse1"] = QColor(127, 255, 0);
+	m_colorMap["chartreuse2"] = QColor(118, 238, 0);
+	m_colorMap["chartreuse3"] = QColor(102, 205, 0);
+	m_colorMap["chartreuse4"] = QColor(69, 139, 0);
+	m_colorMap["olivedrab1"] = QColor(192, 255, 62);
+	m_colorMap["olivedrab2"] = QColor(179, 238, 58);
+	m_colorMap["olivedrab3"] = QColor(154, 205, 50);
+	m_colorMap["olivedrab4"] = QColor(105, 139, 34);
+	m_colorMap["darkolivegreen1"] = QColor(202, 255, 112);
+	m_colorMap["darkolivegreen2"] = QColor(188, 238, 104);
+	m_colorMap["darkolivegreen3"] = QColor(162, 205, 90);
+	m_colorMap["darkolivegreen4"] = QColor(110, 139, 61);
+	m_colorMap["khaki1"] = QColor(255, 246, 143);
+	m_colorMap["khaki2"] = QColor(238, 230, 133);
+	m_colorMap["khaki3"] = QColor(205, 198, 115);
+	m_colorMap["khaki4"] = QColor(139, 134, 78);
+	m_colorMap["lightgoldenrod1"] = QColor(255, 236, 139);
+	m_colorMap["lightgoldenrod2"] = QColor(238, 220, 130);
+	m_colorMap["lightgoldenrod3"] = QColor(205, 190, 112);
+	m_colorMap["lightgoldenrod4"] = QColor(139, 129, 76);
+	m_colorMap["lightyellow1"] = QColor(255, 255, 224);
+	m_colorMap["lightyellow2"] = QColor(238, 238, 209);
+	m_colorMap["lightyellow3"] = QColor(205, 205, 180);
+	m_colorMap["lightyellow4"] = QColor(139, 139, 122);
+	m_colorMap["yellow1"] = QColor(255, 255, 0);
+	m_colorMap["yellow2"] = QColor(238, 238, 0);
+	m_colorMap["yellow3"] = QColor(205, 205, 0);
+	m_colorMap["yellow4"] = QColor(139, 139, 0);
+	m_colorMap["gold1"] = QColor(255, 215, 0);
+	m_colorMap["gold2"] = QColor(238, 201, 0);
+	m_colorMap["gold3"] = QColor(205, 173, 0);
+	m_colorMap["gold4"] = QColor(139, 117, 0);
+	m_colorMap["goldenrod1"] = QColor(255, 193, 37);
+	m_colorMap["goldenrod2"] = QColor(238, 180, 34);
+	m_colorMap["goldenrod3"] = QColor(205, 155, 29);
+	m_colorMap["goldenrod4"] = QColor(139, 105, 20);
+	m_colorMap["darkgoldenrod1"] = QColor(255, 185, 15);
+	m_colorMap["darkgoldenrod2"] = QColor(238, 173, 14);
+	m_colorMap["darkgoldenrod3"] = QColor(205, 149, 12);
+	m_colorMap["darkgoldenrod4"] = QColor(139, 101, 8);
+	m_colorMap["rosybrown1"] = QColor(255, 193, 193);
+	m_colorMap["rosybrown2"] = QColor(238, 180, 180);
+	m_colorMap["rosybrown3"] = QColor(205, 155, 155);
+	m_colorMap["rosybrown4"] = QColor(139, 105, 105);
+	m_colorMap["indianred1"] = QColor(255, 106, 106);
+	m_colorMap["indianred2"] = QColor(238, 99, 99);
+	m_colorMap["indianred3"] = QColor(205, 85, 85);
+	m_colorMap["indianred4"] = QColor(139, 58, 58);
+	m_colorMap["sienna1"] = QColor(255, 130, 71);
+	m_colorMap["sienna2"] = QColor(238, 121, 66);
+	m_colorMap["sienna3"] = QColor(205, 104, 57);
+	m_colorMap["sienna4"] = QColor(139, 71, 38);
+	m_colorMap["burlywood1"] = QColor(255, 211, 155);
+	m_colorMap["burlywood2"] = QColor(238, 197, 145);
+	m_colorMap["burlywood3"] = QColor(205, 170, 125);
+	m_colorMap["burlywood4"] = QColor(139, 115, 85);
+	m_colorMap["wheat1"] = QColor(255, 231, 186);
+	m_colorMap["wheat2"] = QColor(238, 216, 174);
+	m_colorMap["wheat3"] = QColor(205, 186, 150);
+	m_colorMap["wheat4"] = QColor(139, 126, 102);
+	m_colorMap["tan1"] = QColor(255, 165, 79);
+	m_colorMap["tan2"] = QColor(238, 154, 73);
+	m_colorMap["tan3"] = QColor(205, 133, 63);
+	m_colorMap["tan4"] = QColor(139, 90, 43);
+	m_colorMap["chocolate1"] = QColor(255, 127, 36);
+	m_colorMap["chocolate2"] = QColor(238, 118, 33);
+	m_colorMap["chocolate3"] = QColor(205, 102, 29);
+	m_colorMap["chocolate4"] = QColor(139, 69, 19);
+	m_colorMap["firebrick1"] = QColor(255, 48, 48);
+	m_colorMap["firebrick2"] = QColor(238, 44, 44);
+	m_colorMap["firebrick3"] = QColor(205, 38, 38);
+	m_colorMap["firebrick4"] = QColor(139, 26, 26);
+	m_colorMap["brown1"] = QColor(255, 64, 64);
+	m_colorMap["brown2"] = QColor(238, 59, 59);
+	m_colorMap["brown3"] = QColor(205, 51, 51);
+	m_colorMap["brown4"] = QColor(139, 35, 35);
+	m_colorMap["salmon1"] = QColor(255, 140, 105);
+	m_colorMap["salmon2"] = QColor(238, 130, 98);
+	m_colorMap["salmon3"] = QColor(205, 112, 84);
+	m_colorMap["salmon4"] = QColor(139, 76, 57);
+	m_colorMap["lightsalmon1"] = QColor(255, 160, 122);
+	m_colorMap["lightsalmon2"] = QColor(238, 149, 114);
+	m_colorMap["lightsalmon3"] = QColor(205, 129, 98);
+	m_colorMap["lightsalmon4"] = QColor(139, 87, 66);
+	m_colorMap["orange1"] = QColor(255, 165, 0);
+	m_colorMap["orange2"] = QColor(238, 154, 0);
+	m_colorMap["orange3"] = QColor(205, 133, 0);
+	m_colorMap["orange4"] = QColor(139, 90, 0);
+	m_colorMap["darkorange1"] = QColor(255, 127, 0);
+	m_colorMap["darkorange2"] = QColor(238, 118, 0);
+	m_colorMap["darkorange3"] = QColor(205, 102, 0);
+	m_colorMap["darkorange4"] = QColor(139, 69, 0);
+	m_colorMap["coral1"] = QColor(255, 114, 86);
+	m_colorMap["coral2"] = QColor(238, 106, 80);
+	m_colorMap["coral3"] = QColor(205, 91, 69);
+	m_colorMap["coral4"] = QColor(139, 62, 47);
+	m_colorMap["tomato1"] = QColor(255, 99, 71);
+	m_colorMap["tomato2"] = QColor(238, 92, 66);
+	m_colorMap["tomato3"] = QColor(205, 79, 57);
+	m_colorMap["tomato4"] = QColor(139, 54, 38);
+	m_colorMap["orangered1"] = QColor(255, 69, 0);
+	m_colorMap["orangered2"] = QColor(238, 64, 0);
+	m_colorMap["orangered3"] = QColor(205, 55, 0);
+	m_colorMap["orangered4"] = QColor(139, 37, 0);
+	m_colorMap["red1"] = QColor(255, 0, 0);
+	m_colorMap["red2"] = QColor(238, 0, 0);
+	m_colorMap["red3"] = QColor(205, 0, 0);
+	m_colorMap["red4"] = QColor(139, 0, 0);
+	m_colorMap["deeppink1"] = QColor(255, 20, 147);
+	m_colorMap["deeppink2"] = QColor(238, 18, 137);
+	m_colorMap["deeppink3"] = QColor(205, 16, 118);
+	m_colorMap["deeppink4"] = QColor(139, 10, 80);
+	m_colorMap["hotpink1"] = QColor(255, 110, 180);
+	m_colorMap["hotpink2"] = QColor(238, 106, 167);
+	m_colorMap["hotpink3"] = QColor(205, 96, 144);
+	m_colorMap["hotpink4"] = QColor(139, 58, 98);
+	m_colorMap["pink1"] = QColor(255, 181, 197);
+	m_colorMap["pink2"] = QColor(238, 169, 184);
+	m_colorMap["pink3"] = QColor(205, 145, 158);
+	m_colorMap["pink4"] = QColor(139, 99, 108);
+	m_colorMap["lightpink1"] = QColor(255, 174, 185);
+	m_colorMap["lightpink2"] = QColor(238, 162, 173);
+	m_colorMap["lightpink3"] = QColor(205, 140, 149);
+	m_colorMap["lightpink4"] = QColor(139, 95, 101);
+	m_colorMap["palevioletred1"] = QColor(255, 130, 171);
+	m_colorMap["palevioletred2"] = QColor(238, 121, 159);
+	m_colorMap["palevioletred3"] = QColor(205, 104, 137);
+	m_colorMap["palevioletred4"] = QColor(139, 71, 93);
+	m_colorMap["maroon1"] = QColor(255, 52, 179);
+	m_colorMap["maroon2"] = QColor(238, 48, 167);
+	m_colorMap["maroon3"] = QColor(205, 41, 144);
+	m_colorMap["maroon4"] = QColor(139, 28, 98);
+	m_colorMap["violetred1"] = QColor(255, 62, 150);
+	m_colorMap["violetred2"] = QColor(238, 58, 140);
+	m_colorMap["violetred3"] = QColor(205, 50, 120);
+	m_colorMap["violetred4"] = QColor(139, 34, 82);
+	m_colorMap["magenta1"] = QColor(255, 0, 255);
+	m_colorMap["magenta2"] = QColor(238, 0, 238);
+	m_colorMap["magenta3"] = QColor(205, 0, 205);
+	m_colorMap["magenta4"] = QColor(139, 0, 139);
+	m_colorMap["orchid1"] = QColor(255, 131, 250);
+	m_colorMap["orchid2"] = QColor(238, 122, 233);
+	m_colorMap["orchid3"] = QColor(205, 105, 201);
+	m_colorMap["orchid4"] = QColor(139, 71, 137);
+	m_colorMap["plum1"] = QColor(255, 187, 255);
+	m_colorMap["plum2"] = QColor(238, 174, 238);
+	m_colorMap["plum3"] = QColor(205, 150, 205);
+	m_colorMap["plum4"] = QColor(139, 102, 139);
+	m_colorMap["mediumorchid1"] = QColor(224, 102, 255);
+	m_colorMap["mediumorchid2"] = QColor(209, 95, 238);
+	m_colorMap["mediumorchid3"] = QColor(180, 82, 205);
+	m_colorMap["mediumorchid4"] = QColor(122, 55, 139);
+	m_colorMap["darkorchid1"] = QColor(191, 62, 255);
+	m_colorMap["darkorchid2"] = QColor(178, 58, 238);
+	m_colorMap["darkorchid3"] = QColor(154, 50, 205);
+	m_colorMap["darkorchid4"] = QColor(104, 34, 139);
+	m_colorMap["purple1"] = QColor(155, 48, 255);
+	m_colorMap["purple2"] = QColor(145, 44, 238);
+	m_colorMap["purple3"] = QColor(125, 38, 205);
+	m_colorMap["purple4"] = QColor(85, 26, 139);
+	m_colorMap["mediumpurple1"] = QColor(171, 130, 255);
+	m_colorMap["mediumpurple2"] = QColor(159, 121, 238);
+	m_colorMap["mediumpurple3"] = QColor(137, 104, 205);
+	m_colorMap["mediumpurple4"] = QColor(93, 71, 139);
+	m_colorMap["thistle1"] = QColor(255, 225, 255);
+	m_colorMap["thistle2"] = QColor(238, 210, 238);
+	m_colorMap["thistle3"] = QColor(205, 181, 205);
+	m_colorMap["thistle4"] = QColor(139, 123, 139);
+	m_colorMap["gray0"] = QColor(0, 0, 0);
+	m_colorMap["grey0"] = QColor(0, 0, 0);
+	m_colorMap["gray1"] = QColor(3, 3, 3);
+	m_colorMap["grey1"] = QColor(3, 3, 3);
+	m_colorMap["gray2"] = QColor(5, 5, 5);
+	m_colorMap["grey2"] = QColor(5, 5, 5);
+	m_colorMap["gray3"] = QColor(8, 8, 8);
+	m_colorMap["grey3"] = QColor(8, 8, 8);
+	m_colorMap["gray4"] = QColor(10, 10, 10);
+	m_colorMap["grey4"] = QColor(10, 10, 10);
+	m_colorMap["gray5"] = QColor(13, 13, 13);
+	m_colorMap["grey5"] = QColor(13, 13, 13);
+	m_colorMap["gray6"] = QColor(15, 15, 15);
+	m_colorMap["grey6"] = QColor(15, 15, 15);
+	m_colorMap["gray7"] = QColor(18, 18, 18);
+	m_colorMap["grey7"] = QColor(18, 18, 18);
+	m_colorMap["gray8"] = QColor(20, 20, 20);
+	m_colorMap["grey8"] = QColor(20, 20, 20);
+	m_colorMap["gray9"] = QColor(23, 23, 23);
+	m_colorMap["grey9"] = QColor(23, 23, 23);
+	m_colorMap["gray10"] = QColor(26, 26, 26);
+	m_colorMap["grey10"] = QColor(26, 26, 26);
+	m_colorMap["gray11"] = QColor(28, 28, 28);
+	m_colorMap["grey11"] = QColor(28, 28, 28);
+	m_colorMap["gray12"] = QColor(31, 31, 31);
+	m_colorMap["grey12"] = QColor(31, 31, 31);
+	m_colorMap["gray13"] = QColor(33, 33, 33);
+	m_colorMap["grey13"] = QColor(33, 33, 33);
+	m_colorMap["gray14"] = QColor(36, 36, 36);
+	m_colorMap["grey14"] = QColor(36, 36, 36);
+	m_colorMap["gray15"] = QColor(38, 38, 38);
+	m_colorMap["grey15"] = QColor(38, 38, 38);
+	m_colorMap["gray16"] = QColor(41, 41, 41);
+	m_colorMap["grey16"] = QColor(41, 41, 41);
+	m_colorMap["gray17"] = QColor(43, 43, 43);
+	m_colorMap["grey17"] = QColor(43, 43, 43);
+	m_colorMap["gray18"] = QColor(46, 46, 46);
+	m_colorMap["grey18"] = QColor(46, 46, 46);
+	m_colorMap["gray19"] = QColor(48, 48, 48);
+	m_colorMap["grey19"] = QColor(48, 48, 48);
+	m_colorMap["gray20"] = QColor(51, 51, 51);
+	m_colorMap["grey20"] = QColor(51, 51, 51);
+	m_colorMap["gray21"] = QColor(54, 54, 54);
+	m_colorMap["grey21"] = QColor(54, 54, 54);
+	m_colorMap["gray22"] = QColor(56, 56, 56);
+	m_colorMap["grey22"] = QColor(56, 56, 56);
+	m_colorMap["gray23"] = QColor(59, 59, 59);
+	m_colorMap["grey23"] = QColor(59, 59, 59);
+	m_colorMap["gray24"] = QColor(61, 61, 61);
+	m_colorMap["grey24"] = QColor(61, 61, 61);
+	m_colorMap["gray25"] = QColor(64, 64, 64);
+	m_colorMap["grey25"] = QColor(64, 64, 64);
+	m_colorMap["gray26"] = QColor(66, 66, 66);
+	m_colorMap["grey26"] = QColor(66, 66, 66);
+	m_colorMap["gray27"] = QColor(69, 69, 69);
+	m_colorMap["grey27"] = QColor(69, 69, 69);
+	m_colorMap["gray28"] = QColor(71, 71, 71);
+	m_colorMap["grey28"] = QColor(71, 71, 71);
+	m_colorMap["gray29"] = QColor(74, 74, 74);
+	m_colorMap["grey29"] = QColor(74, 74, 74);
+	m_colorMap["gray30"] = QColor(77, 77, 77);
+	m_colorMap["grey30"] = QColor(77, 77, 77);
+	m_colorMap["gray31"] = QColor(79, 79, 79);
+	m_colorMap["grey31"] = QColor(79, 79, 79);
+	m_colorMap["gray32"] = QColor(82, 82, 82);
+	m_colorMap["grey32"] = QColor(82, 82, 82);
+	m_colorMap["gray33"] = QColor(84, 84, 84);
+	m_colorMap["grey33"] = QColor(84, 84, 84);
+	m_colorMap["gray34"] = QColor(87, 87, 87);
+	m_colorMap["grey34"] = QColor(87, 87, 87);
+	m_colorMap["gray35"] = QColor(89, 89, 89);
+	m_colorMap["grey35"] = QColor(89, 89, 89);
+	m_colorMap["gray36"] = QColor(92, 92, 92);
+	m_colorMap["grey36"] = QColor(92, 92, 92);
+	m_colorMap["gray37"] = QColor(94, 94, 94);
+	m_colorMap["grey37"] = QColor(94, 94, 94);
+	m_colorMap["gray38"] = QColor(97, 97, 97);
+	m_colorMap["grey38"] = QColor(97, 97, 97);
+	m_colorMap["gray39"] = QColor(99, 99, 99);
+	m_colorMap["grey39"] = QColor(99, 99, 99);
+	m_colorMap["gray40"] = QColor(102, 102, 102);
+	m_colorMap["grey40"] = QColor(102, 102, 102);
+	m_colorMap["gray41"] = QColor(105, 105, 105);
+	m_colorMap["grey41"] = QColor(105, 105, 105);
+	m_colorMap["gray42"] = QColor(107, 107, 107);
+	m_colorMap["grey42"] = QColor(107, 107, 107);
+	m_colorMap["gray43"] = QColor(110, 110, 110);
+	m_colorMap["grey43"] = QColor(110, 110, 110);
+	m_colorMap["gray44"] = QColor(112, 112, 112);
+	m_colorMap["grey44"] = QColor(112, 112, 112);
+	m_colorMap["gray45"] = QColor(115, 115, 115);
+	m_colorMap["grey45"] = QColor(115, 115, 115);
+	m_colorMap["gray46"] = QColor(117, 117, 117);
+	m_colorMap["grey46"] = QColor(117, 117, 117);
+	m_colorMap["gray47"] = QColor(120, 120, 120);
+	m_colorMap["grey47"] = QColor(120, 120, 120);
+	m_colorMap["gray48"] = QColor(122, 122, 122);
+	m_colorMap["grey48"] = QColor(122, 122, 122);
+	m_colorMap["gray49"] = QColor(125, 125, 125);
+	m_colorMap["grey49"] = QColor(125, 125, 125);
+	m_colorMap["gray50"] = QColor(127, 127, 127);
+	m_colorMap["grey50"] = QColor(127, 127, 127);
+	m_colorMap["gray51"] = QColor(130, 130, 130);
+	m_colorMap["grey51"] = QColor(130, 130, 130);
+	m_colorMap["gray52"] = QColor(133, 133, 133);
+	m_colorMap["grey52"] = QColor(133, 133, 133);
+	m_colorMap["gray53"] = QColor(135, 135, 135);
+	m_colorMap["grey53"] = QColor(135, 135, 135);
+	m_colorMap["gray54"] = QColor(138, 138, 138);
+	m_colorMap["grey54"] = QColor(138, 138, 138);
+	m_colorMap["gray55"] = QColor(140, 140, 140);
+	m_colorMap["grey55"] = QColor(140, 140, 140);
+	m_colorMap["gray56"] = QColor(143, 143, 143);
+	m_colorMap["grey56"] = QColor(143, 143, 143);
+	m_colorMap["gray57"] = QColor(145, 145, 145);
+	m_colorMap["grey57"] = QColor(145, 145, 145);
+	m_colorMap["gray58"] = QColor(148, 148, 148);
+	m_colorMap["grey58"] = QColor(148, 148, 148);
+	m_colorMap["gray59"] = QColor(150, 150, 150);
+	m_colorMap["grey59"] = QColor(150, 150, 150);
+	m_colorMap["gray60"] = QColor(153, 153, 153);
+	m_colorMap["grey60"] = QColor(153, 153, 153);
+	m_colorMap["gray61"] = QColor(156, 156, 156);
+	m_colorMap["grey61"] = QColor(156, 156, 156);
+	m_colorMap["gray62"] = QColor(158, 158, 158);
+	m_colorMap["grey62"] = QColor(158, 158, 158);
+	m_colorMap["gray63"] = QColor(161, 161, 161);
+	m_colorMap["grey63"] = QColor(161, 161, 161);
+	m_colorMap["gray64"] = QColor(163, 163, 163);
+	m_colorMap["grey64"] = QColor(163, 163, 163);
+	m_colorMap["gray65"] = QColor(166, 166, 166);
+	m_colorMap["grey65"] = QColor(166, 166, 166);
+	m_colorMap["gray66"] = QColor(168, 168, 168);
+	m_colorMap["grey66"] = QColor(168, 168, 168);
+	m_colorMap["gray67"] = QColor(171, 171, 171);
+	m_colorMap["grey67"] = QColor(171, 171, 171);
+	m_colorMap["gray68"] = QColor(173, 173, 173);
+	m_colorMap["grey68"] = QColor(173, 173, 173);
+	m_colorMap["gray69"] = QColor(176, 176, 176);
+	m_colorMap["grey69"] = QColor(176, 176, 176);
+	m_colorMap["gray70"] = QColor(179, 179, 179);
+	m_colorMap["grey70"] = QColor(179, 179, 179);
+	m_colorMap["gray71"] = QColor(181, 181, 181);
+	m_colorMap["grey71"] = QColor(181, 181, 181);
+	m_colorMap["gray72"] = QColor(184, 184, 184);
+	m_colorMap["grey72"] = QColor(184, 184, 184);
+	m_colorMap["gray73"] = QColor(186, 186, 186);
+	m_colorMap["grey73"] = QColor(186, 186, 186);
+	m_colorMap["gray74"] = QColor(189, 189, 189);
+	m_colorMap["grey74"] = QColor(189, 189, 189);
+	m_colorMap["gray75"] = QColor(191, 191, 191);
+	m_colorMap["grey75"] = QColor(191, 191, 191);
+	m_colorMap["gray76"] = QColor(194, 194, 194);
+	m_colorMap["grey76"] = QColor(194, 194, 194);
+	m_colorMap["gray77"] = QColor(196, 196, 196);
+	m_colorMap["grey77"] = QColor(196, 196, 196);
+	m_colorMap["gray78"] = QColor(199, 199, 199);
+	m_colorMap["grey78"] = QColor(199, 199, 199);
+	m_colorMap["gray79"] = QColor(201, 201, 201);
+	m_colorMap["grey79"] = QColor(201, 201, 201);
+	m_colorMap["gray80"] = QColor(204, 204, 204);
+	m_colorMap["grey80"] = QColor(204, 204, 204);
+	m_colorMap["gray81"] = QColor(207, 207, 207);
+	m_colorMap["grey81"] = QColor(207, 207, 207);
+	m_colorMap["gray82"] = QColor(209, 209, 209);
+	m_colorMap["grey82"] = QColor(209, 209, 209);
+	m_colorMap["gray83"] = QColor(212, 212, 212);
+	m_colorMap["grey83"] = QColor(212, 212, 212);
+	m_colorMap["gray84"] = QColor(214, 214, 214);
+	m_colorMap["grey84"] = QColor(214, 214, 214);
+	m_colorMap["gray85"] = QColor(217, 217, 217);
+	m_colorMap["grey85"] = QColor(217, 217, 217);
+	m_colorMap["gray86"] = QColor(219, 219, 219);
+	m_colorMap["grey86"] = QColor(219, 219, 219);
+	m_colorMap["gray87"] = QColor(222, 222, 222);
+	m_colorMap["grey87"] = QColor(222, 222, 222);
+	m_colorMap["gray88"] = QColor(224, 224, 224);
+	m_colorMap["grey88"] = QColor(224, 224, 224);
+	m_colorMap["gray89"] = QColor(227, 227, 227);
+	m_colorMap["grey89"] = QColor(227, 227, 227);
+	m_colorMap["gray90"] = QColor(229, 229, 229);
+	m_colorMap["grey90"] = QColor(229, 229, 229);
+	m_colorMap["gray91"] = QColor(232, 232, 232);
+	m_colorMap["grey91"] = QColor(232, 232, 232);
+	m_colorMap["gray92"] = QColor(235, 235, 235);
+	m_colorMap["grey92"] = QColor(235, 235, 235);
+	m_colorMap["gray93"] = QColor(237, 237, 237);
+	m_colorMap["grey93"] = QColor(237, 237, 237);
+	m_colorMap["gray94"] = QColor(240, 240, 240);
+	m_colorMap["grey94"] = QColor(240, 240, 240);
+	m_colorMap["gray95"] = QColor(242, 242, 242);
+	m_colorMap["grey95"] = QColor(242, 242, 242);
+	m_colorMap["gray96"] = QColor(245, 245, 245);
+	m_colorMap["grey96"] = QColor(245, 245, 245);
+	m_colorMap["gray97"] = QColor(247, 247, 247);
+	m_colorMap["grey97"] = QColor(247, 247, 247);
+	m_colorMap["gray98"] = QColor(250, 250, 250);
+	m_colorMap["grey98"] = QColor(250, 250, 250);
+	m_colorMap["gray99"] = QColor(252, 252, 252);
+	m_colorMap["grey99"] = QColor(252, 252, 252);
+	m_colorMap["gray100"] = QColor(255, 255, 255);
+	m_colorMap["grey100"] = QColor(255, 255, 255);
+	m_colorMap["darkgrey"] = QColor(169, 169, 169);
+	m_colorMap["darkgray"] = QColor(169, 169, 169);
+	m_colorMap["darkblue"] = QColor(0, 0, 139);
+	m_colorMap["darkcyan"] = QColor(0, 139, 139);
+	m_colorMap["darkmagenta"] = QColor(139, 0, 139);
+	m_colorMap["darkred"] = QColor(139, 0, 0);
+	m_colorMap["lightgreen"] = QColor(144, 238, 144);
+}
+
+/**
+ * Get a color by name
+ *
+ * The color name can be any Vim or Qt color including html #colors.
+ * Color names are case and space insensitive, i.e. "Dark Blue" 
+ * and "darkblue" are the same color.
+ *
+ */
+QColor ColorTable::get(const QString& name, const QColor& fallback)
+{
+	QString cname = name.toLower().remove(' ');
+	QColor c = m_instance.value(cname, QColor());
+	if ( !c.isValid() && cname != "transparent" ) {
+		c.setNamedColor(cname);
+	}
+
+	return c;
+}
+
+
diff -urN vim-src/src/qt/colortable.h vim-qt-src/src/qt/colortable.h
--- vim-src/src/qt/colortable.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/colortable.h	2016-06-08 06:39:27.797315734 +0200
@@ -0,0 +1,20 @@
+#ifndef VIM_QT_COLORTABLE
+#define VIM_QT_COLORTABLE
+
+#include <QColor>
+#include <QString>
+#include <QHash>
+
+class ColorTable: public QHash<QString, QColor>
+{
+public:
+	static QColor get(const QString& name, const QColor &fallback=QColor());
+
+protected:
+	ColorTable();
+	
+private:
+	static ColorTable m_instance;
+};
+
+#endif
diff -urN vim-src/src/qt/fontdialog.cpp vim-qt-src/src/qt/fontdialog.cpp
--- vim-src/src/qt/fontdialog.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/fontdialog.cpp	2016-06-08 06:39:27.797315734 +0200
@@ -0,0 +1,226 @@
+#include "fontdialog.moc"
+
+#include <QLineEdit>
+#include <QPushButton>
+#include <QFontDialog>
+
+// some of the style names which could indicate the "regular" one
+const QRegExp FontDialog::regular_rx = QRegExp("Regular|Normal|Book|Roman|Plain|Upright|Medium|Light|Sans");
+
+/**
+ * Custom font dialog
+ *
+ * This custom font selection dialog allows us to do
+ * things the regular one does not:
+ * - Enforce use of fixed-pitch fonts
+ * - Enforce the selected font style to "regular" style
+ *
+ *  ____________________________
+ * |         |       | Styles   |
+ * | Family  | Font  | ----     |
+ * |  List   | Sizes | Scripts  |
+ * |_________|_______|__________|
+ * |                            |
+ * |   Preview font text line   |
+ * |____________________________|
+ * |          OK/Cancel buttons |
+ * |____________________________|
+ *
+ * TODO:
+ *  - list non-scalable fonts after scalable
+ *  - remove the requirement to select size each time
+ * TODO?:
+ *  - allow translation of "Styles and Scripts"
+ *  - add preview of other styles
+ */
+
+
+FontDialog::FontDialog(QWidget *parent)
+:QDialog(parent)
+{
+	// 1. Initialize data holders
+	// fontDatabase is declared/initialized in the header file
+	regularStyle = "";      // to store the name of the "regular" style
+
+	// 2. Construct all widgets and layouts
+	vlayout  = new QVBoxLayout(this);     //top layout
+	hlayout  = new QHBoxLayout();           //inside vlayout
+	// font family and size lists (with selectable items)
+	fontList = new QListWidget(this);     //top sub-widget 1
+	sizeList = new QListWidget(this);     //top sub-widget 2
+
+	// style and writing info: three Labels wrapped in GroupBox and ScrollArea
+	scrollInfo   = new QScrollArea(this); //top sub-widget 3
+	groupboxInfo = new QGroupBox("Styles and Scripts", scrollInfo);
+	vlayoutInfo  = new QVBoxLayout(groupboxInfo);  //inside groupboxInfo
+
+	styleInfo     = new QLabel(groupboxInfo);
+	separatorInfo = new QLabel(groupboxInfo);
+	writingInfo   = new QLabel(groupboxInfo);
+
+	// font preview line
+	preview = new QLineEdit(this);        //top sub-widget 4
+	// dialog buttons
+	buttons = new QDialogButtonBox( QDialogButtonBox::Ok | QDialogButtonBox::Cancel, Qt::Horizontal, this);   //top sub-widget 5
+
+
+	// 3. Nest and connect widgets and layouts, set formatting details
+	// font family list
+	foreach (QString family, fontDatabase.families()) {
+		if ( fontDatabase.isFixedPitch(family) ) {
+			QListWidgetItem *item = new QListWidgetItem(fontList);
+			item->setText(family);
+		}
+	}
+	fontList->setMinimumWidth(80);  // to reduce stretching
+	connect(fontList, SIGNAL(itemSelectionChanged()),
+			this, SLOT(updateFonts()));
+	hlayout->addWidget(fontList,5);
+	// font size list (filled later in updateFonts())
+	sizeList->setMinimumWidth(40);  // to reduce stretching
+	sizeList->setMaximumWidth(60);
+	connect(sizeList, SIGNAL(itemSelectionChanged()),
+			this, SLOT(fontSelected()));
+	hlayout->addWidget(sizeList,1);
+	// font family info: styles, separator, scripts (see updateFonts())
+	// styles
+	styleInfo->setWordWrap(true);
+	styleInfo->setAlignment(Qt::AlignTop);
+	vlayoutInfo->addWidget(styleInfo);
+	// separator
+	separatorInfo->setFrameStyle(QFrame::HLine);
+	vlayoutInfo->addWidget(separatorInfo);
+	// scripts (writing systems)
+	writingInfo->setWordWrap(true);
+	vlayoutInfo->addWidget(writingInfo);
+	groupboxInfo->setLayout(vlayoutInfo);
+	scrollInfo->setWidget(groupboxInfo);
+	scrollInfo->setWidgetResizable(true);
+	scrollInfo->setFocusPolicy(Qt::NoFocus);
+	scrollInfo->setMinimumWidth(80);  // to reduce stretching
+	hlayout->addWidget(scrollInfo,5);
+	vlayout->addLayout(hlayout);
+	// font preview line
+	preview->setText("The quick brown fox jumps over the lazy dog");
+	preview->setAlignment(Qt::AlignCenter | Qt::AlignBottom);
+	preview->setEnabled(false);
+	preview->setMinimumHeight(40);  // to reduce vertical resizing
+	vlayout->addWidget(preview);
+	// dialog OK and Cancel buttons
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
+
+	connect( buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
+			this, SLOT(accept()));
+	connect( buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
+			this, SLOT(reject()));
+	vlayout->addWidget(buttons);
+
+	this->setLayout(vlayout);
+}
+
+/** update the list of sizes available for the given family
+ *  and the name of the "regular" style in regularStyle
+ *  and the styleInfo
+ */
+
+void FontDialog::updateFonts()
+{
+	sizeList->clear();
+
+	QString family;
+	if ( fontList->currentItem() == NULL ) {
+		return;
+	} else {
+		family = fontList->currentItem()->text();
+	}
+
+	QStringList styles = fontDatabase.styles(family);
+	// try to guess which of the styles is the "regular" one
+	//int match_idx = styles.indexOf(QRegExp("Regular|Normal|Book|Roman|Plain|Upright|Medium|Light|Sans"));
+	int match_idx = styles.indexOf(regular_rx);
+	regularStyle = match_idx == -1 ? styles.at(0) : styles.at(match_idx);
+
+	// offer sizes for the regular style
+	QList<int> fsizes = fontDatabase.smoothSizes(family, regularStyle);
+	if ( fsizes.isEmpty() ) {
+		fsizes = fontDatabase.pointSizes(family, regularStyle);
+	}
+	// or simply all sizes(?), if the above fails
+	if ( fsizes.isEmpty() ) {
+		fsizes = fontDatabase.standardSizes();
+	}
+
+	// fill the size list for the selected family
+	foreach ( int points, fsizes ) {
+		QListWidgetItem *item = new QListWidgetItem(sizeList);
+		item->setText(QString::number(points));
+	}
+
+	// scripts (writing systems) supported by the family
+	QString wsystems = "";
+	foreach ( const QFontDatabase::WritingSystem &writing, fontDatabase.writingSystems(family) ) {
+	    wsystems += fontDatabase.writingSystemName(writing) + ", ";
+	}
+	wsystems.chop(2);   // no trailing comma
+
+	// update the info widgets, buttons and preview
+	styleInfo->setText(styles.join("\n") );
+	writingInfo->setText(wsystems);
+
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
+	preview->setEnabled(false);
+}
+
+void FontDialog::fontSelected()
+{
+	QListWidgetItem *currentF = fontList->currentItem();
+	QListWidgetItem *currentS = sizeList->currentItem();
+
+	if ( currentF == NULL || currentS == NULL ) {
+		return;
+	}
+
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(true);
+
+	QFont f = fontDatabase.font( currentF->text(),
+			regularStyle, currentS->text().toInt());
+	preview->setFont(f);
+	preview->setEnabled(true);
+}
+
+QFont FontDialog::selectedFont()
+{
+	if ( fontList->currentItem() && sizeList->currentItem() ) {
+		return QFont( fontList->currentItem()->text(), sizeList->currentItem()->text().toInt() );
+	}
+
+	return QFont();
+}
+
+QFont FontDialog::getFont(bool *ok, const QFont& oldfont, QWidget *parent)
+{
+	FontDialog dialog;
+	dialog.selectCurrentFont(oldfont);
+
+	if ( dialog.exec() == QDialog::Accepted ) {
+		*ok = true;
+		return dialog.selectedFont();
+	}
+
+	*ok = false;
+	return QFont();
+}
+
+void FontDialog::selectCurrentFont(const QFont& f)
+{
+	QList<QListWidgetItem *> items = fontList->findItems(f.family(), Qt::MatchFixedString);
+	if ( items.size() > 0 ) {
+		fontList->setCurrentItem(items.at(0));
+
+		QList<QListWidgetItem *> sizeItems = sizeList->findItems(QString::number(f.pointSize()), Qt::MatchFixedString);
+		if ( sizeItems.size() > 0 ) {
+			sizeList->setCurrentItem(sizeItems.at(0));
+		}
+	}
+}
+
diff -urN vim-src/src/qt/fontdialog.h vim-qt-src/src/qt/fontdialog.h
--- vim-src/src/qt/fontdialog.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/fontdialog.h	2016-06-08 06:39:27.797315734 +0200
@@ -0,0 +1,48 @@
+#ifndef __VIM_QT_FONTDIALOG__
+#define __VIM_QT_FONTDIALOG__
+
+#include <QDialog>
+#include <QHBoxLayout>
+#include <QListWidget>
+#include <QFontDatabase>
+#include <QDialogButtonBox>
+#include <QScrollArea>
+#include <QGroupBox>
+#include <QLabel>
+
+class FontDialog: public QDialog
+{
+	Q_OBJECT
+public:
+	FontDialog(QWidget *parent=0);
+	QFont selectedFont();
+
+	static QFont getFont(bool *ok, const QFont &, QWidget *parent=0);
+	void selectCurrentFont(const QFont&);
+
+protected slots:
+	void updateFonts();
+	void fontSelected();
+
+private:
+	// layouts and widgets
+	QHBoxLayout   *hlayout;
+	QVBoxLayout   *vlayout;
+	QVBoxLayout   *vlayoutInfo;
+	QListWidget   *fontList;
+	QListWidget   *sizeList;
+	QDialogButtonBox *buttons;
+	QLineEdit     *preview;
+	QScrollArea   *scrollInfo;
+	QGroupBox     *groupboxInfo;
+	QLabel        *styleInfo;
+	QLabel        *writingInfo;
+	QLabel        *separatorInfo;
+	// data
+	QFontDatabase fontDatabase;
+	QString       regularStyle;
+	// constants
+	static const  QRegExp regular_rx;
+};
+
+#endif
Binary files vim-src/src/qt/icons/document-new.png and vim-qt-src/src/qt/icons/document-new.png differ
Binary files vim-src/src/qt/icons/document-open.png and vim-qt-src/src/qt/icons/document-open.png differ
Binary files vim-src/src/qt/icons/document-print.png and vim-qt-src/src/qt/icons/document-print.png differ
Binary files vim-src/src/qt/icons/document-save-all.png and vim-qt-src/src/qt/icons/document-save-all.png differ
Binary files vim-src/src/qt/icons/document-save-as.png and vim-qt-src/src/qt/icons/document-save-as.png differ
Binary files vim-src/src/qt/icons/document-save.png and vim-qt-src/src/qt/icons/document-save.png differ
Binary files vim-src/src/qt/icons/edit-copy.png and vim-qt-src/src/qt/icons/edit-copy.png differ
Binary files vim-src/src/qt/icons/edit-cut.png and vim-qt-src/src/qt/icons/edit-cut.png differ
Binary files vim-src/src/qt/icons/edit-find-replace.png and vim-qt-src/src/qt/icons/edit-find-replace.png differ
Binary files vim-src/src/qt/icons/edit-find.png and vim-qt-src/src/qt/icons/edit-find.png differ
Binary files vim-src/src/qt/icons/edit-paste.png and vim-qt-src/src/qt/icons/edit-paste.png differ
Binary files vim-src/src/qt/icons/edit-redo.png and vim-qt-src/src/qt/icons/edit-redo.png differ
Binary files vim-src/src/qt/icons/edit-undo.png and vim-qt-src/src/qt/icons/edit-undo.png differ
Binary files vim-src/src/qt/icons/folder-new.png and vim-qt-src/src/qt/icons/folder-new.png differ
Binary files vim-src/src/qt/icons/folder-open.png and vim-qt-src/src/qt/icons/folder-open.png differ
Binary files vim-src/src/qt/icons/go-jump.png and vim-qt-src/src/qt/icons/go-jump.png differ
Binary files vim-src/src/qt/icons/go-next.png and vim-qt-src/src/qt/icons/go-next.png differ
Binary files vim-src/src/qt/icons/go-previous.png and vim-qt-src/src/qt/icons/go-previous.png differ
Binary files vim-src/src/qt/icons/help-contents.png and vim-qt-src/src/qt/icons/help-contents.png differ
Binary files vim-src/src/qt/icons/help-faq.png and vim-qt-src/src/qt/icons/help-faq.png differ
Binary files vim-src/src/qt/icons/run-build-clean.png and vim-qt-src/src/qt/icons/run-build-clean.png differ
Binary files vim-src/src/qt/icons/run-build.png and vim-qt-src/src/qt/icons/run-build.png differ
Binary files vim-src/src/qt/icons/system-run.png and vim-qt-src/src/qt/icons/system-run.png differ
Binary files vim-src/src/qt/icons/tab-new.png and vim-qt-src/src/qt/icons/tab-new.png differ
Binary files vim-src/src/qt/icons/table.png and vim-qt-src/src/qt/icons/table.png differ
Binary files vim-src/src/qt/icons/utilities-terminal.png and vim-qt-src/src/qt/icons/utilities-terminal.png differ
Binary files vim-src/src/qt/icons/view-split-left-right.png and vim-qt-src/src/qt/icons/view-split-left-right.png differ
Binary files vim-src/src/qt/icons/view-split-top-bottom.png and vim-qt-src/src/qt/icons/view-split-top-bottom.png differ
Binary files vim-src/src/qt/icons/vim-qt.png and vim-qt-src/src/qt/icons/vim-qt.png differ
Binary files vim-src/src/qt/icons/window-close.png and vim-qt-src/src/qt/icons/window-close.png differ
Binary files vim-src/src/qt/icons/zoom-fit-height.png and vim-qt-src/src/qt/icons/zoom-fit-height.png differ
Binary files vim-src/src/qt/icons/zoom-fit-width.png and vim-qt-src/src/qt/icons/zoom-fit-width.png differ
diff -urN vim-src/src/qt/icons.qrc vim-qt-src/src/qt/icons.qrc
--- vim-src/src/qt/icons.qrc	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/icons.qrc	2016-06-08 06:39:27.797315734 +0200
@@ -0,0 +1,36 @@
+ <!DOCTYPE RCC><RCC version="1.0">
+ <qresource>
+     <file>icons/document-open.png</file>
+     <file>icons/document-save.png</file>
+     <file>icons/document-save-all.png</file>
+     <file>icons/document-print.png</file>
+     <file>icons/document-new.png</file>
+     <file>icons/edit-undo.png</file>
+     <file>icons/edit-redo.png</file>
+     <file>icons/edit-cut.png</file>
+     <file>icons/edit-copy.png</file>
+     <file>icons/edit-paste.png</file>
+     <file>icons/edit-find-replace.png</file>
+     <file>icons/edit-find.png</file>
+     <file>icons/go-next.png</file>
+     <file>icons/go-previous.png</file>
+     <file>icons/folder-open.png</file>
+     <file>icons/document-save-as.png</file>
+     <file>icons/folder-new.png</file>
+     <file>icons/run-build-clean.png</file>
+     <file>icons/run-build.png</file>
+     <file>icons/table.png</file>
+     <file>icons/go-jump.png</file>
+     <file>icons/help-contents.png</file>
+     <file>icons/help-faq.png</file>
+     <file>icons/vim-qt.png</file>
+     <file>icons/tab-new.png</file>
+     <file>icons/system-run.png</file>
+     <file>icons/view-split-left-right.png</file>
+     <file>icons/view-split-top-bottom.png</file>
+     <file>icons/window-close.png</file>
+     <file>icons/zoom-fit-height.png</file>
+     <file>icons/zoom-fit-width.png</file>
+     <file>icons/utilities-terminal.png</file>
+ </qresource>
+ </RCC>
diff -urN vim-src/src/qt/mainwindow.cpp vim-qt-src/src/qt/mainwindow.cpp
--- vim-src/src/qt/mainwindow.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/mainwindow.cpp	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,226 @@
+#include "mainwindow.moc"
+
+#include <QToolBar>
+#include <QMenuBar>
+#include <QEvent>
+
+MainWindow::MainWindow( gui_T* gui, QWidget *parent)
+:QMainWindow(parent), m_keepTabbar(false)
+{
+	setWindowIcon(QIcon(":/icons/vim-qt.png"));
+	setContextMenuPolicy(Qt::PreventContextMenu);
+
+	// Tool bar
+	toolbar = addToolBar("ToolBar");
+	toolbar->setObjectName("toolbar");
+
+	// Vim shell
+	vimshell = new QVimShell(this);
+
+	scrollarea = new ScrollArea(this);
+	scrollarea->setWidget(vimshell);
+	connect(vimshell, SIGNAL(backgroundColorChanged(QColor)),
+		scrollarea, SLOT(setBackgroundColor(QColor)) );
+
+	setCentralWidget(scrollarea);
+
+	// TabLine
+	tabtoolbar = addToolBar("tabline");
+	tabtoolbar->setObjectName("tabline");
+
+	connect( tabtoolbar, SIGNAL(orientationChanged(Qt::Orientation)),
+			this, SLOT(updateTabOrientation()) );
+	connect( tabtoolbar, SIGNAL(topLevelChanged(bool)),
+			this, SLOT(updateTabOrientation()));
+
+	tabbar = new TabBar(tabtoolbar);
+	tabbar->setTabsClosable(true);
+	tabbar->setExpanding(false);
+	tabbar->setFocusPolicy(Qt::NoFocus);
+	tabbar->setDrawBase(false);
+	tabbar->setMovable(true);
+	connect(tabbar, SIGNAL(tabMoved(int, int)),
+			this, SLOT(tabMoved(int, int)));
+
+
+	tabbar->addTab("VIM"); // One tab must always exist
+
+	tabtoolbar->addWidget(tabbar);
+	QAction *newTab = tabtoolbar->addAction( VimWrapper::icon("tab-new"), "New Tab");
+
+	connect( tabbar, SIGNAL(tabCloseRequested(int)),
+			this, SLOT(closeTab(int)));
+	connect( tabbar, SIGNAL(currentChanged(int)),
+			this, SLOT(switchTab(int)));
+	connect( newTab, SIGNAL(triggered()),
+			this, SLOT(openNewTab()));
+
+
+	vimshell->setFocus();
+}
+
+void MainWindow::tabMoved(int from, int to)
+{
+	//
+	// 1. In some cases Qt will not drag the tab you expect
+	// for example if you have two tabs (1,2) and drag 
+	// tab 1 to place 2 -> Qt might trigger the reverse
+	// event i.e. move tab 2 to place 1
+	//
+	// 2. It also seems that QTabbar::currentIndex() always 
+	// returns the current tab, i.e. after the movement event
+	// it returns the destination position - which is exactly
+	// what we want.
+	//
+	// 3. Also, both tabpage_move and Qt use 0-indexed tab positions
+	//
+
+	tabpage_move(tabbar->currentIndex());
+}
+
+void MainWindow::updateTabOrientation()
+{
+
+	if ( tabtoolbar->orientation() == Qt::Horizontal ) {
+		if ( toolBarArea(tabtoolbar) == Qt::BottomToolBarArea ) {
+			tabbar->setShape( QTabBar::RoundedSouth );
+		} else {
+			tabbar->setShape( QTabBar::RoundedNorth );
+		}
+	} else {
+		if ( toolBarArea(tabtoolbar) == Qt::LeftToolBarArea ) {
+			tabbar->setShape( QTabBar::RoundedWest );
+		} else {
+			tabbar->setShape( QTabBar::RoundedEast );
+		}
+	}
+
+	if ( tabtoolbar->isFloating() ) {
+		tabtoolbar->resize(tabtoolbar->minimumWidth(), tabtoolbar->sizeHint().height());
+	}
+}
+
+bool MainWindow::restoreState(const QByteArray& state, int version)
+{
+	bool ret = QMainWindow::restoreState(state, version);
+	if ( keepTabbar() ) {
+		showTabline(true);
+	}
+
+	return ret;
+}
+
+QVimShell* MainWindow::vimShell()
+{
+	return this->vimshell;
+}
+
+QToolBar* MainWindow::toolBar() const
+{
+	return toolbar;
+}
+
+void MainWindow::closeEvent (QCloseEvent * event)
+{
+	vimshell->closeEvent(event);
+}
+
+void MainWindow::changeEvent( QEvent *ev)
+{
+	if (ev->type() == QEvent::WindowStateChange) {
+		VimWrapper::setFullscreen( windowState() & Qt::WindowFullScreen );
+
+		if ( ! (windowState() & Qt::WindowFullScreen) ) {
+			// Reset vimshell size policy when leaving fullscreen
+			vimshell->setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
+			vimshell->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+			vimshell->updateGeometry();
+		}
+	}
+	QMainWindow::changeEvent(ev);
+}
+
+void MainWindow::showTabline(bool show)
+{
+	// VIM never removes the second tab,
+	// instead it hides the entire tab bar
+	if ( keepTabbar() && !show ) {
+		removeTabs(1);
+	}
+
+	if ( keepTabbar() ) {
+		tabtoolbar->setVisible(true);
+	} else {
+		tabtoolbar->setVisible(show);
+	}
+}
+
+void MainWindow::showToolbar(bool show)
+{
+	toolbar->setVisible(show);
+}
+
+void MainWindow::showMenu(bool show)
+{
+	QMainWindow::menuBar()->setVisible(show);
+}
+
+bool MainWindow::tablineVisible()
+{
+	return tabtoolbar->isVisible();
+}
+
+void MainWindow::setCurrentTab(int idx)
+{
+	tabbar->setCurrentIndex(idx);
+}
+
+void MainWindow::setTab( int idx, const QString& label)
+{
+	while ( tabbar->count() <= idx ) {
+		tabbar->addTab("[No name]");
+	}
+
+	tabbar->setTabText(idx, label);
+}
+
+
+void MainWindow::removeTabs(int idx)
+{
+	int i;
+	for ( i=idx; i<tabbar->count(); i++) {
+		tabbar->removeTab(i);
+	}
+}
+
+void MainWindow::switchTab(int idx)
+{
+	vimshell->switchTab(idx+1);
+}
+
+void MainWindow::closeTab(int idx)
+{
+	if ( keepTabbar() && tabbar->count() == 1 ) {
+		vimshell->close();
+	} else {
+		vimshell->closeTab(idx+1);
+	}
+}
+
+void MainWindow::openNewTab()
+{
+	// The amusing +1 trick opens the
+	// tab at the right of other tabs
+	VimWrapper::newTab(tabbar->count()+1);
+}
+
+void MainWindow::setKeepTabbar(bool keep)
+{
+	m_keepTabbar = keep;
+}
+
+bool MainWindow::keepTabbar()
+{
+	return m_keepTabbar;
+}
+
diff -urN vim-src/src/qt/mainwindow.h vim-qt-src/src/qt/mainwindow.h
--- vim-src/src/qt/mainwindow.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/mainwindow.h	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,57 @@
+#ifndef __GUI_QT_MAINWINDOW__
+#define __GUI_QT_MAINWINDOW__
+
+#include <QMainWindow>
+#include "qvimshell.h"
+#include "tabbar.h"
+#include "scrollarea.h"
+
+
+class MainWindow: public QMainWindow
+{
+	Q_OBJECT
+	Q_PROPERTY(bool m_keepTabbar READ keepTabbar WRITE setKeepTabbar )
+public:
+	MainWindow(gui_T *, QWidget *parent=0);
+	QVimShell* vimShell();
+
+	bool tablineVisible();
+
+	QToolBar* toolBar() const;
+	bool keepTabbar();
+
+	bool restoreState(const QByteArray& state, int version=0);
+
+public slots:
+	void showTabline(bool show);
+	void showMenu(bool show);
+	void showToolbar(bool show);
+	void setCurrentTab(int idx);
+	void setTab( int, const QString& );
+	void removeTabs(int);
+	void switchTab(int idx);
+	void closeTab(int idx);
+	void setKeepTabbar(bool);
+	void openNewTab();
+
+protected:
+	virtual void closeEvent( QCloseEvent *);
+	virtual void changeEvent( QEvent *ev );
+
+protected slots:
+	void updateTabOrientation();
+	void tabMoved(int from, int to);
+
+private:
+	QToolBar *toolbar;
+
+	ScrollArea *scrollarea;
+	QVimShell *vimshell;
+	QToolBar *tabtoolbar;
+	TabBar *tabbar;
+	
+
+	bool m_keepTabbar;
+};
+
+#endif
diff -urN vim-src/src/qt/qt_features.h vim-qt-src/src/qt/qt_features.h
--- vim-src/src/qt/qt_features.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qt_features.h	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,20 @@
+
+//
+// Feature defines for the Vim-Qt Gui
+// :Lets try to stay away from the core Vim code, shall we :D
+//
+// The only features that are moved here are those that are stricty dependent
+// on the GUI
+//
+
+#define FEAT_TOOLBAR
+#define FEAT_GUI_TABLINE
+#define FEAT_BROWSE
+#define FEAT_DND
+#define FEAT_MOUSESHAPE
+#define FEAT_SIGN_ICONS
+#define FEAT_FULLSCREEN
+
+
+#undef HAVE_X11
+
diff -urN vim-src/src/qt/qvimshell.cpp vim-qt-src/src/qt/qvimshell.cpp
--- vim-src/src/qt/qvimshell.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qvimshell.cpp	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,745 @@
+#include "qvimshell.moc"
+
+#include <QResizeEvent>
+#include <QApplication>
+#include <QDebug>
+#include <QFile>
+#include <QTimer>
+#include <QMimeData>
+
+extern "C" {
+#include "proto/gui.pro"
+}
+
+#include "colortable.h"
+
+QVimShell::QVimShell(QWidget *parent)
+:QWidget(parent), m_encoding_utf8(true),
+	m_lastClickEvent(-1), m_tooltip(0), m_slowStringDrawing(false),
+	m_mouseHidden(false)
+{
+	setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+
+	// cursor blinking
+	timer_cursorBlinkOn = new QTimer();
+	timer_cursorBlinkOff = new QTimer();
+	timer_firstOff = new QTimer();
+	timer_firstOn = new QTimer();
+	timer_firstOn->setSingleShot(true);
+	timer_firstOff->setSingleShot(true);
+	blinkState = BLINK_NONE;
+	connect(timer_cursorBlinkOn, SIGNAL(timeout()), this, SLOT(cursorOn()));
+	connect(timer_firstOn, SIGNAL(timeout()), this, SLOT(startBlinkOnTimer()));
+	connect(timer_firstOff, SIGNAL(timeout()), this, SLOT(startBlinkOffTimer()));
+	connect(timer_cursorBlinkOff, SIGNAL(timeout()), this, SLOT(cursorOff()));
+
+	// IM Tooltip
+	m_tooltip = new QLabel(this);
+	m_tooltip->setVisible(false);
+	m_tooltip->setTextFormat(Qt::PlainText);
+	m_tooltip->setTextInteractionFlags(Qt::NoTextInteraction);
+	m_tooltip->setAutoFillBackground(true);
+
+	// Widget Attributes
+	setAttribute(Qt::WA_KeyCompression, false);
+	setAttribute(Qt::WA_InputMethodEnabled, true);
+	setAttribute(Qt::WA_OpaquePaintEvent, true);
+	setAttribute(Qt::WA_StaticContents, true);
+	setAcceptDrops(true);
+	setMouseTracking(true);
+
+	PaintOperation op;
+	op.type = CLEARALL;
+	op.color = background();
+	queuePaintOp(op);
+}
+
+void QVimShell::setBackground(const QColor color)
+{
+	m_background = color;
+	emit backgroundColorChanged(m_background);
+}
+
+void QVimShell::switchTab(int idx)
+{
+	sendTablineEvent(idx);
+}
+
+void QVimShell::closeTab(int idx)
+{
+	sendTablineMenuEvent(idx, TABLINE_MENU_CLOSE);
+}
+
+
+QColor QVimShell::background()
+{
+	return m_background;
+}
+
+void QVimShell::resizeEvent(QResizeEvent *ev)
+{
+	PaintOperation op;
+	op.type = FILLRECT;
+	op.color = background();
+
+	int dWidth = ev->size().width() - ev->oldSize().width();
+	if (dWidth > 0)
+	{
+		op.rect = QRect(ev->oldSize().width(), 0, dWidth, ev->size().height());
+		queuePaintOp(op);
+	}
+
+	int dHeight = ev->size().height() - ev->oldSize().height();
+	if (dHeight > 0)
+	{
+		op.rect = QRect(0, ev->oldSize().height(), ev->size().width(), dHeight);
+		queuePaintOp(op);
+	}
+
+	//
+	// Vim might trigger another resize, postpone the call
+	// to guiResizeShell - otherwise we might be called
+	// recursivelly and crash
+	//
+	postGuiResizeShell(ev->size().width(), ev->size().height());
+}
+
+int_u QVimShell::vimKeyboardModifiers(Qt::KeyboardModifiers mod)
+{
+	int_u vim = 0x00;
+
+	if ( mod & Qt::ShiftModifier ) {
+		vim |= MOD_MASK_SHIFT;
+	} 
+	if ( mod & Qt::ControlModifier ) {
+		vim |= MOD_MASK_CTRL;
+	}
+	if ( mod & Qt::AltModifier ) {
+		vim |= MOD_MASK_ALT;
+	}
+
+	return vim;
+}
+
+int_u QVimShell::vimMouseModifiers(Qt::KeyboardModifiers mod)
+{
+	int_u vim = 0x00;
+
+	if ( mod & Qt::ShiftModifier ) {
+		vim |= MOUSE_SHIFT;
+	} 
+	if ( mod & Qt::ControlModifier ) {
+		vim |= MOUSE_CTRL;
+	}
+	if ( mod & Qt::AltModifier ) {
+		vim |= MOUSE_ALT;
+	}
+
+	return vim;
+}
+
+
+
+void QVimShell::keyPressEvent ( QKeyEvent *ev)
+{
+	// mousehide - conceal mouse pointer when typing
+	if (p_mh && !m_mouseHidden ) {
+		QApplication::setOverrideCursor(Qt::BlankCursor);
+		m_mouseHidden = true;
+	}
+
+	int key_char = 0;
+	int vimModifiers = vimKeyboardModifiers(QApplication::keyboardModifiers());
+	if ( !ev->text().isEmpty() ) {
+		key_char = ev->text()[0].unicode(); // key compression is off
+	}
+
+	/* Find the special key */
+	int i;
+	bool isSpecial = false;
+	for (i = 0; special_keys[i].key_sym != 0; ++i) {
+		if (special_keys[i].key_sym == ev->key())
+		{
+
+			if (special_keys[i].code1 == NUL) {
+				key_char = special_keys[i].code0;
+			} else {
+				key_char = TO_SPECIAL(special_keys[i].code0, special_keys[i].code1);
+				key_char = simplify_key(key_char,
+					(int *)&vimModifiers);
+			}
+			if (ev->key() != Qt::Key_Backtab) {
+				isSpecial = TRUE;
+			}
+			break;
+		}
+	}
+
+	if ( key_char == 0 ) {
+		return;
+	}
+
+	/* TODO: Intercept CMD-. and CTRL-c ?*/
+
+	//
+	// For the most part this is same code as the one found in gui_mac.c, plus our
+	// additional special keys bits, I've also kept the original comments because I
+	// find them informative and slightly amusing
+	//
+	if (!isSpecial)
+	{
+		/* remove SHIFT for keys that are already shifted, e.g.,
+		 * '(' and '*' */
+		if (key_char < 0x100 && !isalpha(key_char) && isprint(key_char)) {
+			vimModifiers &= ~MOD_MASK_SHIFT;
+		}
+
+		/* remove CTRL from keys that already have it */
+		if (key_char < 0x20) {
+			vimModifiers &= ~MOD_MASK_CTRL;
+		}
+
+		/* don't process unicode characters here */
+		if (!IS_SPECIAL(key_char)) {
+			/* Following code to simplify and consolidate vimModifiers
+			 * taken liberally from gui_w48.c */
+			key_char = simplify_key(key_char, (int *)&vimModifiers);
+
+			/* Interpret META, include SHIFT, etc. */
+			key_char = extract_modifiers(key_char, (int *)&vimModifiers);
+			if (key_char == CSI) {
+				key_char = K_CSI;
+			}
+
+			if (IS_SPECIAL(key_char)) {
+				isSpecial = TRUE;
+			}
+		}
+	}
+
+	char_u result[3];
+	if (vimModifiers) {
+		result[0] = CSI;
+		result[1] = KS_MODIFIER;
+		result[2] = vimModifiers;
+		add_to_input_buf(result, 3);
+	}
+
+	if (isSpecial && IS_SPECIAL(key_char)) {
+		result[0] = CSI;
+		result[1] = K_SECOND(key_char);
+		result[2] = K_THIRD(key_char);
+		add_to_input_buf(result, 3);
+	} else {
+		QByteArray utf8 = QString(QChar(key_char)).toUtf8();
+		add_to_input_buf_csi( (char_u *) utf8.data(), utf8.size());
+	}
+}
+
+void QVimShell::close()
+{
+	guiShellClosed();
+}
+
+void QVimShell::closeEvent(QCloseEvent *event)
+{
+	close();
+	event->ignore();
+}
+
+/*
+ * @Deprecated
+ *
+ * Either by sheer absurdity or font substitution magic, some
+ * monospace fonts end up having different widths for each
+ * style (regular, bold, etc). This causes text painting to
+ * misspaint - particularly when painting a selection -  because
+ * the text will be too wide to fit in its place..
+ *
+ * This obscure piece of code tries to find a pointSize for the
+ * same font that respects the monospace char width. Hopefully
+ * you have a decent monospace font and this is never called!!
+ *
+ */
+QFont QVimShell::fixPainterFont( const QFont& pfont )
+{
+	QFontMetrics fm(pfont);
+
+	if ( fm.averageCharWidth() != charWidth() ) {
+		qDebug() << __func__ << "Font size mismatch a.k.a. this is not a proper monospace font";
+
+		int V = (fm.averageCharWidth() > charWidth() ) ? -1 :1;
+		int newsize;
+
+		QFont f1 = pfont;
+		newsize = f1.pointSize()-V;
+
+		if ( newsize < 0 ) {
+			return pfont;
+		}
+		f1.setPointSize(newsize);
+		QFontMetrics fm1(f1);
+
+		float wdiff = ((float)fm1.averageCharWidth() - fm.averageCharWidth())*V;
+		int pt = (fm.averageCharWidth() - charWidth())/wdiff;
+
+		QFont f = pfont;
+		newsize = f.pointSize()+pt;
+		if ( newsize < 0 ) {
+			return pfont;
+		}
+		f.setPointSize(newsize);
+
+		return f;
+	}
+
+	return pfont;
+}
+
+/*
+ * Slow text painting strategy
+ *
+ * - Paints one character at a time
+ * - Looks perfect in any condition
+ * - Takes a looong time
+ * - FIXME: add support for proper undercurl
+ */
+void QVimShell::drawStringSlow( const PaintOperation& op, QPainter &painter )
+{
+	QFont f = op.font;
+	painter.setFont(f);
+	painter.setPen( op.color );
+
+	QRect rect = op.rect;
+	foreach(QChar c, op.str) {
+		if ( VimWrapper::charCellWidth(c) == 1 ) {
+			rect.setWidth(VimWrapper::charWidth());
+		} else if (VimWrapper::charCellWidth(c) == 2) {
+			rect.setWidth(2*VimWrapper::charWidth());
+		} else {
+			qDebug() << __func__ << "invalid lenght" << c << VimWrapper::charCellWidth(c);
+			continue;
+		}
+
+		QPoint pos = op.pos;
+		pos.setX(rect.left());
+		painter.drawText(pos, c);
+		rect.moveTo( rect.x() + rect.width(), rect.y() );
+	}
+}
+
+/**
+ * Draw a string into the canvas
+ *
+ */
+void QVimShell::drawString( const PaintOperation& op, QPainter &painter)
+{
+	painter.setPen( op.color );
+	painter.setFont(op.font);
+	painter.drawText( op.pos, op.str);
+}
+
+void QVimShell::paintEvent ( QPaintEvent *ev )
+{
+	m_painter.begin(this);
+	while ( !paintOps.isEmpty() ) {
+		m_painter.save();
+
+		PaintOperation op = paintOps.dequeue();
+		switch( op.type ) {
+		case CLEARALL:
+			m_painter.fillRect(this->rect(), op.color);
+			break;
+		case FILLRECT:
+			m_painter.fillRect(op.rect, op.color);
+			break;
+		case DRAWRECT:
+			m_painter.setPen(op.color);
+			m_painter.drawRect(op.rect);
+			break;
+		case DRAWSTRING:
+			m_painter.setClipRect(op.rect);
+
+			// Disable underline if undercurl is in place
+			if (op.undercurl && op.font.underline()) {
+				op.font.setUnderline(false);
+			}
+
+			if ( m_slowStringDrawing ) {
+				drawStringSlow(op, m_painter);
+			} else if ( op.str.length() != VimWrapper::stringCellWidth(op.str) ) {
+				drawStringSlow(op, m_painter);
+			} else {
+				drawString(op, m_painter);
+			}
+
+			// Draw undercurl
+			// FIXME: we are doing it wrong - the underlinePos needs
+			// to be stored someplace else
+			if (op.undercurl) {
+				QPoint start(op.rect.bottomLeft());
+				start.setY(op.pos.y() + 1 + gui.char_ul_pos );
+				QPoint end(start);
+				end.setX(op.rect.right());
+
+				QPen pen(op.curlcolor, 1, Qt::DashDotDotLine);
+				m_painter.setPen(pen);
+				m_painter.drawLine(QLine(start, end));
+			}
+
+			break;
+		case DRAWSIGN:
+			m_painter.drawPixmap( op.pos, op.sign);
+			break;
+		case INVERTRECT:
+			m_painter.setCompositionMode( QPainter::RasterOp_SourceXorDestination );
+			m_painter.fillRect( op.rect, Qt::color0);
+			m_painter.setCompositionMode( QPainter::CompositionMode_SourceOver );
+			break;
+		case SCROLLRECT:
+			m_painter.restore();
+			m_painter.end();
+
+#if QT_VERSION >= 0x050000
+			// From #56, in Qt5 scrolling does not work inside
+			// a paint event, without overriding this attribute
+			this->setAttribute(Qt::WA_WState_InPaintEvent, false);
+#endif
+			this->scroll(op.pos.x(), op.pos.y(), op.rect);
+#if QT_VERSION >= 0x050000
+			this->setAttribute(Qt::WA_WState_InPaintEvent);
+#endif
+
+			m_painter.begin(this);
+
+			// Repaint exposed background. Vim won't redraw areas exposed by
+			// scroll if it considers them empty because it assumes we already
+			// cleared that area of the screen.
+			QRect rect;
+			rect.setWidth(op.rect.width());
+			rect.setHeight(abs(op.pos.y()));
+			if (op.pos.y() > 0)
+				rect.moveTopLeft(op.rect.topLeft());
+			else
+				rect.moveBottomRight(op.rect.bottomRight());
+			m_painter.fillRect(rect, op.color);
+
+			continue; // exception, skip painter restore
+		}
+
+		m_painter.restore();
+	}
+	m_painter.end();
+}
+
+//
+// Mouse events
+// FIXME: not handling modifiers
+
+void QVimShell::mouseMoveEvent(QMouseEvent *ev)
+{
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	if ( ev->buttons() ) {
+		int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+		guiSendMouseEvent(MOUSE_DRAG, ev->pos().x(),
+					  ev->pos().y(), FALSE, vmod);
+	} else {
+		guiMouseMoved(ev->pos().x(), ev->pos().y());
+	}
+}
+
+void QVimShell::mousePressEvent(QMouseEvent *ev)
+{
+	int but;
+
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	if ( !hasFocus() ) {
+		setFocus(Qt::MouseFocusReason);
+	}
+
+	switch( ev->button() ) {
+	case Qt::LeftButton:
+		but = MOUSE_LEFT;
+		break;
+	case Qt::RightButton:
+		but = MOUSE_RIGHT;
+		break;
+	case Qt::MidButton:
+		but = MOUSE_MIDDLE;
+		break;
+	default:
+		return;
+	}
+
+	int repeat=0;
+
+	if ( !m_lastClick.isNull() 
+		&& m_lastClick.elapsed() < QApplication::doubleClickInterval() 
+		&& m_lastClickEvent == ev->button() ) {
+		repeat = 1;
+	}
+
+	m_lastClick.restart();
+	m_lastClickEvent = ev->button();
+
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+
+	guiSendMouseEvent(but, ev->pos().x(),
+					  ev->pos().y(), repeat, vmod);
+}
+
+void QVimShell::mouseReleaseEvent(QMouseEvent *ev)
+{
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+	guiSendMouseEvent(MOUSE_RELEASE, ev->pos().x(),
+					  ev->pos().y(), FALSE, vmod);
+}
+
+void QVimShell::wheelEvent(QWheelEvent *ev)
+{
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+	guiSendMouseEvent((ev->delta() > 0) ? MOUSE_4 : MOUSE_5,
+					    ev->pos().x(), ev->pos().y(), FALSE, vmod);
+}
+
+/**
+ * Get a color by name
+ *
+ * The color name can be any Vim or Qt color including html #colors.
+ * Color names are case and space insensitive, i.e. "Dark Blue" 
+ * and "darkblue" are the same color.
+ *
+ */
+QColor QVimShell::color(const QString& name)
+{
+	QString cname = name.toLower().remove(' ');
+	QColor c = ColorTable::get(cname, QColor());
+	if ( !c.isValid() && cname != "transparent" ) {
+		c.setNamedColor(cname);
+	}
+
+	return c;
+}
+
+void QVimShell::queuePaintOp(PaintOperation op)
+{
+	paintOps.enqueue(op);
+	if ( op.rect.isValid() ) {
+		update(op.rect);
+	} else {
+		update();
+	}
+}
+
+void QVimShell::setEncodingUtf8(bool enabled)
+{
+	m_encoding_utf8 = enabled;
+}
+
+void QVimShell::dragEnterEvent(QDragEnterEvent *ev)
+{
+	if ( ev->mimeData()->hasFormat("text/uri-list") ||
+		ev->mimeData()->hasFormat("text/html") ||
+		ev->mimeData()->hasFormat("UTF8_STRING") ||
+		ev->mimeData()->hasFormat("STRING") ||
+	  	ev->mimeData()->hasFormat("text/plain") ) {
+		ev->acceptProposedAction();
+	}
+}
+
+void QVimShell::dropEvent(QDropEvent *ev)
+{
+
+	if ( ev->mimeData()->hasFormat("text/uri-list") ) {
+		QList<QUrl> urls = ev->mimeData()->urls();
+		if ( urls.size() == 0 ) {
+			return;
+		}
+		guiHandleDrop(ev->pos(), 0, urls);
+
+	} else {
+		guiHandleDropText(ev->mimeData()->text());
+	}
+	ev->acceptProposedAction();
+}
+
+void QVimShell::focusInEvent(QFocusEvent *ev)
+{
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	guiFocusChanged(TRUE);
+	QWidget::focusInEvent(ev);
+	update();
+}
+
+void QVimShell::leaveEvent(QEvent *ev)
+{
+	restoreCursor();
+	QWidget::leaveEvent(ev);
+}
+
+void QVimShell::enterEvent(QEvent *ev)
+{
+	restoreCursor();
+	QWidget::leaveEvent(ev);
+}
+
+void QVimShell::focusOutEvent(QFocusEvent *ev)
+{
+	guiFocusChanged(FALSE);
+	QWidget::focusOutEvent(ev);
+	update();
+}
+
+bool QVimShell::focusNextPrevChild(bool next)
+{
+	return false;
+}
+
+void QVimShell::setCharWidth(int w)
+{
+	m_charWidth = w;
+}
+
+int QVimShell::charWidth()
+{
+	return m_charWidth;
+}
+
+void QVimShell::inputMethodEvent(QInputMethodEvent *ev)
+{
+	if ( !ev->commitString().isEmpty() ) {
+		QByteArray s = VimWrapper::convertTo(ev->commitString());
+		add_to_input_buf_csi( (char_u *) s.data(), s.size() );
+		tooltip("");
+	} else {
+		tooltip( ev->preeditString());
+	}
+}
+
+QVariant QVimShell::inputMethodQuery(Qt::InputMethodQuery query) const
+{
+	if ( query == Qt::ImFont) {
+		return font();
+	} else if ( query == Qt::ImMicroFocus ) {
+		return QRect(VimWrapper::cursorPosition(), QSize(0, charHeight()));
+	}
+
+	return QVariant();
+}
+
+/*
+ * Display a tooltip over the shell, covering underlying shell content.
+ * The tooltip is placed at the current shell cursor position.
+ *
+ * When the given string is empty the tooltip is concealed.
+ *
+ * FIXME: Colors could use improving
+ */
+void QVimShell::tooltip(const QString& text)
+{
+	m_tooltip->setText(text);
+	if ( text.isEmpty() ) {
+		m_tooltip->hide();
+		return;
+	}
+
+	if ( !m_tooltip->isVisible() ) {
+		m_tooltip->setMinimumHeight(VimWrapper::charHeight());
+		m_tooltip->move( VimWrapper::cursorPosition() );
+		m_tooltip->show();
+	}
+
+	m_tooltip->setMinimumWidth( QFontMetrics(m_tooltip->font()).width(text) );
+	m_tooltip->setMaximumWidth( QFontMetrics(m_tooltip->font()).width(text) );
+	m_tooltip->update();
+}
+
+/*
+ * If the cursor is invisible, make it visible again
+ *
+ */
+void QVimShell::restoreCursor()
+{
+	QCursor *cursor = QApplication::overrideCursor();
+
+	if ( cursor && m_mouseHidden ) {
+		QApplication::restoreOverrideCursor();
+		m_mouseHidden = false;
+	}
+}
+
+
+void QVimShell::setBlinkTime(const long waittime, const long ontime, const long offtime)
+{
+	m_blinkWaitTime = waittime;
+	m_blinkOnTime = ontime;
+	m_blinkOffTime = offtime;
+}
+
+/*
+ * start blinking: show cursor for waitingtime then blink
+ */
+void QVimShell::startBlinking()
+{
+	if (m_blinkWaitTime && m_blinkOnTime && m_blinkOffTime && hasFocus())
+	{
+		// wait waitTime before starting the blink
+		timer_cursorBlinkOn->stop();
+		timer_cursorBlinkOff->stop();
+		timer_firstOff->stop();
+		timer_firstOn->stop();
+
+		timer_firstOff->start(m_blinkWaitTime);
+		cursorOn();
+	}
+}
+
+void QVimShell::startBlinkOnTimer()
+{
+	if (blinkState == BLINK_OFF) // if blinkstate == NONE do nothing
+	{
+		timer_cursorBlinkOn->start(m_blinkOnTime+m_blinkOffTime);
+		cursorOn();
+	}
+}
+
+void QVimShell::startBlinkOffTimer()
+{
+	if (blinkState == BLINK_ON) // if blinkstate == NONE do nothing
+	{
+		timer_firstOn->start(m_blinkOffTime);
+		timer_cursorBlinkOff->start(m_blinkOnTime+m_blinkOffTime);
+		cursorOff();
+	}
+}
+
+
+/*
+ * Stop cursor blinking
+ */
+void QVimShell::stopBlinking()
+{
+	blinkState = BLINK_NONE;
+	timer_cursorBlinkOn->stop();
+	timer_cursorBlinkOff->stop();
+	timer_firstOn->stop();
+	timer_firstOff->stop();
+}
+
+void QVimShell::cursorOff()
+{
+	blinkState = BLINK_OFF;
+	undrawCursor();
+}
+
+void QVimShell::cursorOn()
+{
+	blinkState = BLINK_ON;
+	updateCursor(true, false);
+}
diff -urN vim-src/src/qt/qvimshell.h vim-qt-src/src/qt/qvimshell.h
--- vim-src/src/qt/qvimshell.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qvimshell.h	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,186 @@
+#ifndef __QVIMSHELL__
+#define __QVIMSHELL__
+
+#include <QWidget>
+#include <QQueue>
+#include <QLabel>
+#include <QTime>
+#include <QPainter>
+#include "vimwrapper.h"
+
+
+class QVimShell: public QWidget, public VimWrapper
+{
+	Q_OBJECT
+	Q_ENUMS(PaintOperationType)
+public:
+	enum PaintOperationType { CLEARALL=0, FILLRECT, DRAWSTRING, DRAWRECT, INVERTRECT, SCROLLRECT, DRAWSIGN};
+	class PaintOperation {
+	public:
+		enum QVimShell::PaintOperationType type;
+		QRect rect;
+		QColor color;
+		// DRAWSTRING
+		QFont font;
+		QString str;
+		bool undercurl;
+		QColor curlcolor;
+		// SIGN
+		QPixmap sign;
+		// SCROLL
+		QPoint pos;
+	};
+
+	QVimShell(QWidget *parent=0);
+
+	bool hasInput();
+	static QColor color(const QString&);
+
+	void queuePaintOp(PaintOperation);
+
+	QColor background();
+	int charWidth();
+
+	void setEncodingUtf8(bool);
+	virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;
+	void setSlowStringDrawing(bool slow) {m_slowStringDrawing = slow;}
+
+	void setBlinkTime(const long waittime, const long ontime, const long offtime);
+
+	void stopBlinking();
+	void startBlinking();
+
+
+public slots:
+	void setBackground(const QColor);
+	void setCharWidth(int);
+
+	void close();
+	virtual void closeEvent(QCloseEvent *event);
+
+	void switchTab(int idx);
+	void closeTab(int idx);
+
+signals:
+	void backgroundColorChanged(const QColor&);
+
+protected:
+	void resizeEvent(QResizeEvent *);
+	void keyPressEvent ( QKeyEvent *);
+	virtual void mouseMoveEvent(QMouseEvent *event);
+	virtual void mousePressEvent(QMouseEvent *event);
+	virtual void mouseReleaseEvent(QMouseEvent *event);
+	virtual void wheelEvent(QWheelEvent *event );
+	virtual void inputMethodEvent(QInputMethodEvent *event);
+	virtual void focusInEvent(QFocusEvent *);
+	virtual void focusOutEvent(QFocusEvent *);
+
+	virtual void paintEvent( QPaintEvent *);
+
+	QFont fixPainterFont(const QFont &);
+	void drawString(const PaintOperation&, QPainter& );
+	void drawStringSlow( const PaintOperation&, QPainter &painter );
+
+
+	int_u vimKeyboardModifiers(Qt::KeyboardModifiers);
+	int_u vimMouseModifiers(Qt::KeyboardModifiers);
+
+	void dragEnterEvent(QDragEnterEvent *);
+	void dropEvent(QDropEvent *);
+
+	void tooltip(const QString& );
+	void restoreCursor();
+
+	virtual void leaveEvent(QEvent *ev);
+	virtual void enterEvent(QEvent *ev);
+	bool focusNextPrevChild(bool next);
+
+private slots:
+	void cursorOff();
+	void cursorOn();
+	void startBlinkOffTimer();
+	void startBlinkOnTimer();
+
+private:
+	QColor m_background;
+	int m_charWidth;
+	QFont m_font;
+	QPainter m_painter;
+
+	QTimer * timer_cursorBlinkOn ;
+	QTimer * timer_cursorBlinkOff ;
+	QTimer * timer_firstOff;
+	QTimer * timer_firstOn;
+
+
+	long m_blinkWaitTime, m_blinkOnTime, m_blinkOffTime;
+
+	enum blink_state{BLINK_NONE, BLINK_ON, BLINK_OFF};
+	blink_state blinkState;
+	bool m_encoding_utf8;
+
+	QQueue<PaintOperation> paintOps;
+
+	QTime m_lastClick;
+	int m_lastClickEvent;
+	QLabel *m_tooltip;
+
+	bool m_slowStringDrawing;
+	bool m_mouseHidden;
+};
+
+struct special_key
+{
+	int key_sym;
+	char_u code0;
+	char_u code1;
+};
+
+static const struct special_key special_keys[] =
+{
+	{Qt::Key_Up,		'k', 'u'},
+	{Qt::Key_Down,		'k', 'd'},
+	{Qt::Key_Left,		'k', 'l'},
+    	{Qt::Key_Right,		'k', 'r'},
+
+	{Qt::Key_F1,		'k', '1'},
+	{Qt::Key_F2,		'k', '2'},
+	{Qt::Key_F3,		'k', '3'},
+	{Qt::Key_F4,		'k', '4'},
+	{Qt::Key_F5,		'k', '5'},
+	{Qt::Key_F6,		'k', '6'},
+	{Qt::Key_F7,		'k', '7'},
+	{Qt::Key_F8,		'k', '8'},
+	{Qt::Key_F9,		'k', '9'},
+	{Qt::Key_F10,		'k', ';'},
+	{Qt::Key_F11,		'F', '1'},
+	{Qt::Key_F12,		'F', '2'},
+	{Qt::Key_F13,		'F', '3'},
+	{Qt::Key_F14,		'F', '4'},
+	{Qt::Key_Backspace,	'k', 'b'},
+
+	{Qt::Key_Delete,	'k', 'D'},
+	{Qt::Key_Insert,	'k', 'I'},
+	{Qt::Key_Home,		'k', 'h'},
+	{Qt::Key_End,		'@', '7'},
+	{Qt::Key_PageUp,	'k', 'P'},
+	{Qt::Key_PageDown,	'k', 'N'},
+
+	{Qt::Key_Print,		'%', '9'},
+
+	// The following are not really **special** but this
+	// allows to use these keys with any keyboard modifier while
+	// bypassing some of Qt's unwanted behaviour in the text()
+	//
+	{Qt::Key_Tab,		TAB, NUL},
+	{Qt::Key_Backtab,	TAB, NUL},
+	{Qt::Key_Escape,	ESC, NUL},
+	{Qt::Key_Return,	CAR, NUL},
+	{Qt::Key_Enter,		CAR, NUL},
+	{Qt::Key_Space,		' ', NUL},
+
+	/* End of list marker: */
+	{0, 0, 0}
+};
+
+#endif
diff -urN vim-src/src/qt/scrollarea.cpp vim-qt-src/src/qt/scrollarea.cpp
--- vim-src/src/qt/scrollarea.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/scrollarea.cpp	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,32 @@
+#include "scrollarea.moc"
+
+#include <QWidget>
+#include <QGridLayout>
+
+ScrollArea::ScrollArea(QWidget *parent)
+:QWidget(parent), m_widget(NULL)
+{
+	setAutoFillBackground(true);
+	m_layout = new QGridLayout(this);
+	m_layout->setSpacing(0);
+	m_layout->setContentsMargins(0,0,0,0);
+	m_layout->setAlignment(Qt::AlignTop | Qt::AlignHCenter);
+}
+
+void ScrollArea::setWidget(QWidget *w)
+{
+	if ( w == m_widget || !w ) {
+		return;
+	}
+
+	m_widget = w;
+	m_layout->addWidget(m_widget, 0, 1);
+}
+
+void ScrollArea::setBackgroundColor(const QColor& c)
+{
+	QPalette p = palette();
+	p.setColor(QPalette::Window, c);
+	setPalette(p);
+}
+
diff -urN vim-src/src/qt/scrollarea.h vim-qt-src/src/qt/scrollarea.h
--- vim-src/src/qt/scrollarea.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/scrollarea.h	2016-06-08 06:39:27.798315741 +0200
@@ -0,0 +1,23 @@
+#ifndef VIM_GUI_QT_SCROLLAREA
+#define VIM_GUI_QT_SCROLLAREA
+
+#include <QWidget>
+#include <QGridLayout>
+
+class ScrollArea: public QWidget
+{
+	Q_OBJECT
+public:
+	ScrollArea(QWidget *parent=0);
+	void setWidget(QWidget *widget);
+
+public slots:
+	void setBackgroundColor(const QColor&);
+
+private:
+	QWidget *m_widget;
+	QGridLayout *m_layout;
+
+};
+
+#endif
diff -urN vim-src/src/qt/tabbar.cpp vim-qt-src/src/qt/tabbar.cpp
--- vim-src/src/qt/tabbar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/tabbar.cpp	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,23 @@
+#include "tabbar.moc"
+
+#include <QMouseEvent>
+
+TabBar::TabBar(QWidget *parent)
+:QTabBar(parent)
+{
+}
+
+
+void TabBar::mouseReleaseEvent(QMouseEvent *ev)
+{
+	if (ev->button() != Qt::MiddleButton) {
+		QTabBar::mouseReleaseEvent(ev);
+		return;
+	}
+
+	int tab = tabAt(ev->pos());
+	if ( tab != -1 ) {
+		emit QTabBar::tabCloseRequested(tab);
+	}
+}
+
diff -urN vim-src/src/qt/tabbar.h vim-qt-src/src/qt/tabbar.h
--- vim-src/src/qt/tabbar.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/tabbar.h	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,17 @@
+#ifndef __GUI_QT_TABBAR__
+#define __GUI_QT_TABBAR__
+
+#include <QTabBar>
+
+class TabBar: public QTabBar
+{
+	Q_OBJECT
+public:
+	TabBar(QWidget *parent=0);
+
+protected:
+	virtual void mouseReleaseEvent(QMouseEvent *);
+
+};
+
+#endif
diff -urN vim-src/src/qt/vimaction.cpp vim-qt-src/src/qt/vimaction.cpp
--- vim-src/src/qt/vimaction.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimaction.cpp	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,60 @@
+#include "vimaction.moc"
+
+/**
+ * :help builtin-tools
+ */
+QStringList VimAction::iconNames = QStringList() 
+	<< "document-new"	// 00  New		open new window
+	<< "document-open"	// 01  Open		browse for file to open in current window
+	<< "document-save"	// 02  Save		write buffer to file
+	<< "edit-undo"		// 03  Undo		undo last change
+	<< "edit-redo"		// 04  Redo		redo last undone change
+	<< "edit-cut"		// 05  Cut		delete selected text to clipboard
+	<< "edit-copy"		// 06  Copy		copy selected text to clipboard
+	<< "edit-paste"		// 07  Paste		paste text from clipboard
+	<< "document-print"	// 08  Print		print current buffer
+	<< "help-contents"	// 09  Help		open a buffer on Vim's builtin help
+	<< "edit-find"		// 10  Find		start a search command
+	<< "document-save-all"	// 11  SaveAll		write all modified buffers to file
+	<< "document-save-as"	// 12  SaveSesn		write session file for current situation
+	<< "folder-new"		// 13  NewSesn		write new session file
+	<< "folder-open"	// 14  LoadSesn		load session file // FIXME
+	<< "system-run"		// 15  RunScript	browse for file to run as a Vim script
+	<< "edit-find-replace"	// 16  Replace		prompt for substitute command
+	<< "window-close"	// 17  WinClose		close current window
+	<< ""			// 18  WinMax		make current window use many lines // FIXME
+	<< ""			// 19  WinMin		make current window use few lines // FIXME
+<< "view-split-left-right"	// 20  WinSplit		split current window
+	<< "utilities-terminal"	// 21  Shell		start a shell
+	<< "go-previous"	// 22  FindPrev		search again, backward
+	<< "go-next"		// 23  FindNext		search again, forward
+	<< "help-faq"		// 24  FindHelp		prompt for word to search help for
+	<< "run-build"		// 25  Make		run make and jump to first error
+	<< "go-jump"		// 26  TagJump		jump to tag under the cursor
+	<< "table"		// 27  RunCtags		build tags for files in current directory
+<< "view-split-top-bottom"	// 28  WinVSplit	split current window vertically
+	<< "zoom-fit-height"	// 29  WinMaxWidth	make current window use many columns
+	<< "zoom-fit-width"	// 30  WinMinWidth	make current window use few columns
+	;
+
+VimAction::VimAction(vimmenu_T* menu, QObject *parent)
+:QAction(parent), m_menu(menu)
+{
+	if ( menu_is_toolbar(menu->parent->name) ) {
+		// FIXME: add support for iconfile
+		if ( menu->iconidx >= 0 && menu->iconidx <iconNames.size() ) {
+			setIcon( VimWrapper::icon(iconNames.at(menu->iconidx)) );
+		}
+
+		setToolTip(VimWrapper::convertFrom(menu->strings[MENU_INDEX_TIP]));
+	} else {
+		setText( VimWrapper::convertFrom(menu->name) );
+	}
+	connect(this, SIGNAL(triggered()),
+			this, SLOT(actionTriggered()));
+}
+
+void VimAction::actionTriggered()
+{
+	gui_menu_cb(m_menu);
+}
diff -urN vim-src/src/qt/vimaction.h vim-qt-src/src/qt/vimaction.h
--- vim-src/src/qt/vimaction.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimaction.h	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,21 @@
+#ifndef __GUI_QT_VIMACTION__
+#define __GUI_QT_VIMACTION__
+
+#include <QAction>
+#include "qvimshell.h"
+
+class VimAction: public QAction
+{
+	Q_OBJECT
+public:
+	VimAction(vimmenu_T *, QObject* );
+
+protected slots:
+	void actionTriggered();
+
+private:
+	vimmenu_T *m_menu;
+	static QStringList iconNames;
+};
+
+#endif
diff -urN vim-src/src/qt/vimevents.cpp vim-qt-src/src/qt/vimevents.cpp
--- vim-src/src/qt/vimevents.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimevents.cpp	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,38 @@
+#include "vimevents.h"
+#include "vimwrapper.h"
+
+VimEvent::VimEvent(VimWrapper &vim, EvType t)
+:vim(vim), m_type(t)
+{
+}
+
+ResizeEvent::ResizeEvent(VimWrapper &vim, int w, int h)
+:VimEvent(vim, Resize), width(w), height(h)
+{
+}
+
+void ResizeEvent::handle()
+{
+	vim.guiResizeShell(width, height);
+}
+
+CloseEvent::CloseEvent(VimWrapper& vim)
+:VimEvent(vim, Close)
+{
+}
+
+void CloseEvent::handle()
+{
+	vim.guiShellClosed();
+}
+
+DropEvent::DropEvent(VimWrapper& vim, const QPoint& pos, unsigned int mod, QList<QUrl> urls)
+:VimEvent(vim, Drop), pos(pos), mod(mod), urls(urls)
+{
+}
+
+void DropEvent::handle()
+{
+	vim.guiHandleDrop(pos, mod, urls);
+}
+
diff -urN vim-src/src/qt/vimevents.h vim-qt-src/src/qt/vimevents.h
--- vim-src/src/qt/vimevents.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimevents.h	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,51 @@
+#ifndef VIM_QT_VIMEVENT
+#define VIM_QT_VIMEVENT
+
+#include <QPoint>
+#include <QList>
+#include <QUrl>
+
+struct VimWrapper;
+// Base class
+class VimEvent {
+public:
+	enum EvType {Resize, Close, Drop};
+
+	VimEvent(VimWrapper& vim, EvType t);
+	virtual void handle()=0;
+	EvType type() { return m_type; }
+protected:
+	VimWrapper& vim;
+	EvType m_type;
+};
+
+
+class ResizeEvent: public VimEvent
+{
+public:
+	ResizeEvent(VimWrapper& vim, int w, int h);
+	void handle();
+private:
+	int width, height;
+
+};
+
+class CloseEvent: public VimEvent
+{
+public:
+	CloseEvent(VimWrapper& vim);
+	void handle();
+};
+
+class DropEvent: public VimEvent
+{
+public:
+	DropEvent(VimWrapper& vim, const QPoint& pos, unsigned int mod, QList<QUrl> urls);
+	void handle();
+private:
+	QPoint pos;
+	unsigned int mod;
+	QList<QUrl> urls;
+};
+
+#endif
diff -urN vim-src/src/qt/vimscrollbar.cpp vim-qt-src/src/qt/vimscrollbar.cpp
--- vim-src/src/qt/vimscrollbar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimscrollbar.cpp	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,63 @@
+#include "vimscrollbar.moc"
+
+VimScrollBar::VimScrollBar(scrollbar_T *sbar, Qt::Orientation o, QWidget *parent)
+:QScrollBar(o, parent), sb(sbar), m_index(-1), m_length(0)
+{
+	connect(this, SIGNAL(valueChanged(int)),
+			this, SLOT(draggingFinished()));
+}
+
+void VimScrollBar::dragging()
+{
+	if (sb == NULL) {
+		return;
+	}
+
+	gui_drag_scrollbar(sb, this->value(), 1);
+}
+
+void VimScrollBar::draggingFinished()
+{
+	if (sb == NULL) {
+		return;
+	}
+
+	gui_drag_scrollbar(sb, this->value(), 0);
+}
+
+void VimScrollBar::setIndex(int idx)
+{
+	if ( idx != m_index ) {
+		m_index = idx;
+		emit indexChanged(m_index);
+	}
+}
+
+void VimScrollBar::setLength(int len)
+{
+	if ( len != m_length ) {
+		m_length = len;
+		emit indexChanged(m_index); // FIXME
+	}
+}
+
+int VimScrollBar::length()
+{
+	return m_length;
+}
+
+int VimScrollBar::index() const
+{
+	return m_index;
+}
+
+void VimScrollBar::setVisible(bool show)
+{
+	bool visible = isVisible();
+	QScrollBar::setVisible(show);
+
+	if ( visible != show ) {
+		emit visibilityChanged(show);
+	}
+}
+
diff -urN vim-src/src/qt/vimscrollbar.h vim-qt-src/src/qt/vimscrollbar.h
--- vim-src/src/qt/vimscrollbar.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimscrollbar.h	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,35 @@
+#ifndef __GUI_QT_VIMSCROLLBAR__
+#define __GUI_QT_VIMSCROLLBAR__
+
+#include "qvimshell.h"
+
+#include <QScrollBar>
+
+class VimScrollBar: public QScrollBar
+{
+	Q_OBJECT
+public:
+	VimScrollBar(scrollbar_T *, Qt::Orientation, QWidget *parent=0);
+	void setIndex(int);
+	int index() const;
+	int length();
+
+	bool operator<(const VimScrollBar& other) { return ( m_index < other.m_index ); }
+
+	void setVisible(bool);
+	void setLength(int);
+signals:
+	void indexChanged(int);
+	void visibilityChanged(bool);
+
+protected slots:
+	void dragging();
+	void draggingFinished();
+
+private:
+	scrollbar_T *sb;
+	int m_index;
+	int m_length;
+};
+
+#endif
diff -urN vim-src/src/qt/vimwrapper.cpp vim-qt-src/src/qt/vimwrapper.cpp
--- vim-src/src/qt/vimwrapper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimwrapper.cpp	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,435 @@
+#include <QApplication>
+#include <QStyle>
+#include <QMetaType>
+#include <QTime>
+#include "vimwrapper.h"
+
+extern "C" {
+#include "vim.h"
+}
+
+Q_DECLARE_METATYPE( QList<QUrl> );
+
+VimWrapper::VimWrapper()
+:m_processInputOnly(false)
+{
+	qRegisterMetaType<QList<QUrl> >("URLList");
+
+}
+
+/*
+ * Post a vim resize event to be handled later
+ *
+ */
+void VimWrapper::postGuiResizeShell(int w, int h)
+{
+	ResizeEvent *new_ev = new ResizeEvent( *this, w, h);
+	foreach(VimEvent *ev, pendingEvents) {
+		if (ev->type() == VimEvent::Resize) {
+			pendingEvents.removeOne(ev);
+			delete ev;
+		}
+	}
+	pendingEvents.append(new_ev);
+}
+
+/*
+ * Notify Vim of a GUI resize
+ *
+ * If m_processInputOnly is true the handling of this event WILL
+ * be delayed
+ */
+void VimWrapper::guiResizeShell(int w, int h)
+{
+	if ( m_processInputOnly ) {
+		postGuiResizeShell(w, h);
+	} else {
+		gui_resize_shell(w, h);
+	}
+}
+
+void VimWrapper::guiShellClosed()
+{
+	if ( m_processInputOnly ) {
+		pendingEvents.append(new CloseEvent(*this));
+	} else {
+		gui_shell_closed();
+	}
+}
+
+void VimWrapper::guiSendMouseEvent(int button, int x, int y, int repeated_click, unsigned int modifiers)
+{
+	// This is safe
+	gui_send_mouse_event(button, x, y, repeated_click, modifiers);
+}
+
+void VimWrapper::guiMouseMoved(int x, int y)
+{
+	gui_mouse_moved(x, y);
+}
+
+void VimWrapper::guiFocusChanged(int focus)
+{
+	gui_focus_change(focus);
+}
+
+void VimWrapper::sendTablineEvent(int ev)
+{
+	// This just writes to the input buf
+	send_tabline_event(ev);
+}
+
+void VimWrapper::updateCursor(bool force, bool clearsel)
+{
+	gui_update_cursor( force ? TRUE: FALSE,
+				clearsel ? TRUE: FALSE);
+}
+
+void VimWrapper::undrawCursor()
+{
+	gui_undraw_cursor();
+}
+
+void VimWrapper::sendTablineMenuEvent(int idx, int ev)
+{
+	// This just writes to the input buf
+	send_tabline_menu_event(idx, ev);
+}
+
+/**
+ * Place text into the '~' register and push
+ * drop event into the input buffer
+ */
+void VimWrapper::guiHandleDropText(const QString& s)
+{
+	QByteArray text = convertTo(s);
+	dnd_yank_drag_data( (char_u*)text.data(), text.size());
+
+	char_u buf[3] = {CSI, KS_EXTRA, (char_u)KE_DROP};
+	add_to_input_buf(buf, 3);
+}
+
+void VimWrapper::guiHandleDrop(const QPoint& pos, unsigned int mod, const QList<QUrl> urls)
+{
+	if ( urls.size() == 0 ) {
+		return;
+	}
+
+	if ( m_processInputOnly ) {
+		DropEvent *ev = new DropEvent( *this, pos, mod, urls);
+		pendingEvents.append(ev);
+	} else {
+	
+		char_u **fnames = (char_u**)alloc( urls.size() * sizeof(char_u*));
+		int i;
+		for (i=0; i<urls.size(); i++) {
+			QByteArray encoded;
+			if ( urls.at(i).scheme() == "file" ) {
+				encoded = convertTo(urls.at(i).toLocalFile());
+			} else {
+				encoded = convertTo(urls.at(i).toString());
+			}
+	
+			char *s = (char*)alloc(encoded.size()*sizeof(char)+1);
+			int j;
+			for (j=0; j<encoded.size(); j++) {
+				s[j] = encoded.at(j);
+			}
+			s[j]='\0';
+			fnames[i] = (char_u *) s;
+		}
+		gui_handle_drop(pos.x(), pos.y(), mod, fnames, urls.size());
+	}
+}
+
+/**
+ * Map row/column into absolute pixel coordinates
+ *
+ * The returned point is the top left corner of the cell
+ *
+ */
+QPoint VimWrapper::mapText(int row, int col) 
+{ 
+	return QPoint( gui.char_width*col, gui.char_height*row );
+}
+
+QPoint VimWrapper::cursorPosition() 
+{ 
+	return mapText(gui.cursor_row, gui.cursor_col);
+}
+
+/**
+ * Return a rect from row1/col1 to row2/col2 (inclusive)
+ *
+ * The rect coordinates are in pixels
+ */
+QRect VimWrapper::mapBlock(int row1, int col1, int row2, int col2)
+{
+	QPoint tl = mapText( row1, col1 );
+	QPoint br = mapText( row2+1, col2+1);
+	br.setX( br.x()-1 );
+	br.setY( br.y()-1 );
+
+	return QRect(tl, br);
+}
+
+QColor VimWrapper::backgroundColor()
+{
+	return fromColor(gui.back_pixel);
+}
+
+QColor VimWrapper::normalColor()
+{
+	return fromColor(gui.norm_pixel);
+}
+
+int VimWrapper::charWidth()
+{
+	return gui.char_width;
+}
+
+int VimWrapper::charHeight()
+{
+	return gui.char_height;
+}
+
+QFont VimWrapper::normalFont()
+{
+	if ( gui.norm_font ) {
+		return *(gui.norm_font);
+	}
+
+	return QFont();
+}
+
+int VimWrapper::charCellWidth(const QChar& c)
+{
+	int len = utf_char2cells(c.unicode());
+	if ( len <= 2 ) {
+		return len;
+	}
+
+	return 0;
+}
+
+int VimWrapper::stringCellWidth(const QString& s)
+{
+	/*
+	 * Vim kindly provides us with utf_char2cells,
+	 * unfortunately Qt does not have a way measure
+	 * wide char length.
+	 */
+	int len=0;
+	foreach ( QChar c, s ) {
+		len += charCellWidth(c);
+	}
+	return len;
+}
+
+bool VimWrapper::isFakeMonospace(QFont f)
+{
+
+	QFont fi(f);
+	fi.setItalic(true);
+	QFont fb(f);
+	fb.setBold(true);
+	QFont fbi(fb);
+	fbi.setItalic(false);
+
+	QFontMetrics fm_normal(f);
+	QFontMetrics fm_italic(fi);
+	QFontMetrics fm_boldit(fbi);
+	QFontMetrics fm_bold(fb);
+
+	// Regular
+	if ( fm_normal.averageCharWidth() != fm_normal.maxWidth() ) {
+		QFontInfo info(f);
+		qDebug() << __func__ << f.family() 
+			<< "Average and Maximum font width mismatch for Regular font; QFont::exactMatch() is" << f.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Italic
+	if ( fm_italic.averageCharWidth() != fm_italic.maxWidth() ||
+			fm_italic.maxWidth()*2 != fm_italic.width("MM") ) {
+		QFontInfo info(fi);
+		qDebug() << __func__ << fi.family() << "Average and Maximum font width mismatch for Italic font; QFont::exactMatch() is" << fi.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Bold
+	if ( fm_bold.averageCharWidth() != fm_bold.maxWidth() ||
+			fm_bold.maxWidth()*2 != fm_bold.width("MM") ) {
+		QFontInfo info(fb);
+		qDebug() << __func__ << fb.family() << "Average and Maximum font width mismatch for Bold font; QFont::exactMatch() is" << fb.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Bold+Italic
+	if ( fm_boldit.averageCharWidth() != fm_boldit.maxWidth() ||
+			fm_boldit.maxWidth()*2 != fm_boldit.width("MM") ) {
+		QFontInfo info(fbi);
+		qDebug() << __func__ << fbi.family() << "Average and Maximum font width mismatch for Bold+Italic font; QFont::exactMatch() is" << fbi.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	if ( fm_normal.maxWidth() != fm_italic.maxWidth() || 
+		fm_normal.maxWidth() != fm_boldit.maxWidth() || 
+		fm_normal.maxWidth() != fm_bold.maxWidth()) {
+		qDebug() << __func__ << f.family() << "Average and Maximum font width mismatch between font types";
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * Get an icon for a given name
+ *
+ * Icons are loaded in the following order:
+ * 1. If the name is a Vim icon name - map it into a theme name
+ * 2. If the system theme has the icon - use it
+ * 3. If not - load the icon from icons.qrc
+ * 4. As last resort - use a Qt standard icon
+ */
+QIcon VimWrapper::icon(const QString& name)
+{
+
+	QIcon icon;
+
+	icon = QIcon::fromTheme(name.toLower(), QIcon(":/icons/" + name + ".png"));
+	if ( icon.isNull() ) {
+		return QApplication::style()->standardIcon(QStyle::SP_FileLinkIcon);
+	}
+
+	return icon;
+}
+
+QColor
+VimWrapper::fromColor(long color)
+{
+	if ( color == INVALCOLOR ) {
+		return QColor();
+	}
+
+	int red = ((color & 0x00FF0000) >> 16);
+	int green = ((color & 0x0000FF00) >>  8);
+	int blue = ((color & 0x000000FF) >>  0);
+
+	return QColor(red, green, blue);
+}
+
+long
+VimWrapper::toColor(const QColor& c)
+{
+	return ((long)c.red() << 16) + ((long)c.green() << 8) + ((long)c.blue());
+}
+
+void
+VimWrapper::newTab(int idx)
+{
+	send_tabline_menu_event(idx, TABLINE_MENU_NEW);
+}
+
+QByteArray VimWrapper::convertTo(const QString& s)
+{
+	bool m_encoding_utf8 = true; // FIXME: check encoding
+
+	if ( m_encoding_utf8 ) {
+		return s.toUtf8();
+	} else {
+		return s.toLatin1();
+	}
+}
+
+QString VimWrapper::convertFrom(const char *s, int size)
+{
+	bool m_encoding_utf8 = true; // FIXME: check encoding
+
+	if ( m_encoding_utf8 ) {
+		return QString::fromUtf8(s, size);
+	} else {
+		return QString::fromLatin1(s, size);
+	}
+}
+
+QString VimWrapper::convertFrom(const QByteArray& arr)
+{
+	return convertFrom( arr.data(), arr.size());
+}
+
+QString VimWrapper::convertFrom(const char_u *s, int size)
+{
+	return convertFrom( (char*)s, size);
+}
+
+void VimWrapper::setFullscreen(bool on)
+{
+	if (on) {
+		p_fullscreen = TRUE;
+	} else {
+		p_fullscreen = FALSE;
+	}
+}
+
+/**
+ *
+ *  wtime == -1	    Wait forever.
+ *  wtime == 0	    Process what you have and exit
+ *  wtime > 0	    Wait wtime milliseconds for a character.
+ *
+ *  Just like gui_mch_wait_for_chars we return OK if there is
+ *  input or FAIL otherwise
+ */
+bool VimWrapper::processEvents(long wtime, bool inputOnly)
+{
+	bool prev = m_processInputOnly;
+	m_processInputOnly = inputOnly;
+
+	// Process pending events
+	if (!inputOnly) {
+		while(pendingEvents.size() > 0) {
+			VimEvent *ev = pendingEvents.takeFirst();
+			ev->handle();
+			delete ev;
+		}
+	}
+
+	int ret = FAIL;
+	if ( wtime == -1 ) {
+		QApplication::processEvents( QEventLoop::WaitForMoreEvents);
+	} else if ( wtime == 0 ) {
+		if ( !hasPendingEvents() && vim_is_input_buf_empty() ) {
+			return OK;
+		}
+		QApplication::processEvents();
+	} else {
+		QTime t;
+		t.start();
+		do {
+
+			QApplication::processEvents( QEventLoop::WaitForMoreEvents);
+			if ( hasPendingEvents() || !vim_is_input_buf_empty() ) {
+				goto out;
+			}
+		} while( t.elapsed() < wtime );
+	}
+
+out:
+	m_processInputOnly = prev;
+	if ( hasPendingEvents() || !vim_is_input_buf_empty() ) {
+		return OK;
+	} else {
+		return FAIL;
+	}
+}
+
+bool VimWrapper::hasPendingEvents()
+{
+	return pendingEvents.size() != 0;
+}
+
diff -urN vim-src/src/qt/vimwrapper.h vim-qt-src/src/qt/vimwrapper.h
--- vim-src/src/qt/vimwrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimwrapper.h	2016-06-08 06:39:27.799315749 +0200
@@ -0,0 +1,114 @@
+#ifndef __VIM_QT_VIM__
+#define __VIM_QT_VIM__
+
+#include <QObject>
+#include <QIcon>
+#include <QUrl>
+#include <QWidget>
+#include <QDebug>
+
+extern "C" {
+#include "vim.h"
+}
+
+#include "vimevents.h"
+
+/**
+ * VimWrapper is wrapper around Vim, it handles conversion between Qt types
+ * and vim function's argument types
+ *
+ */
+class VimWrapper
+{
+public:
+	VimWrapper();
+	
+	/**
+	 * Map a row/col coordinate to a point in widget coordinates
+	 */
+	static QPoint mapText(int row, int col);
+
+	/**
+	 * Returns the current cursor coordinates(top left corner)
+	 */
+	static QPoint cursorPosition();
+
+	/**
+	 * Map an area in row/col(inclusive) coordinates into
+	 * widget coordinates
+	 */
+	static QRect mapBlock(int row1, int col1, int row2, int col2);
+
+	/**
+	 * The current background pixel color
+	 */
+	static QColor backgroundColor();
+
+	/**
+	 * Normal text color
+	 */
+	static QColor normalColor();
+
+	static int charWidth();
+	static int charHeight();
+
+	/**
+	 * Gui normal font
+	 */
+	static QFont normalFont();
+
+	static int stringCellWidth(const QString&);
+	static int charCellWidth(const QChar&);
+	static bool isFakeMonospace(QFont );
+
+	/**
+	 * Load icons
+	 */
+	static QIcon icon(const QString&);
+
+	static QColor fromColor(long);
+	static long toColor(const QColor&);
+
+	/**
+	 * New tab
+	 */
+	static void newTab(int idx=1);
+
+	static QByteArray convertTo(const QString& s);
+	static QString convertFrom(const char_u *, int size=-1);
+	static QString convertFrom(const QByteArray&);
+
+
+	/**
+	 * Vim methods
+	 */
+	void postGuiResizeShell(int w, int h);
+	void guiResizeShell(int w, int h);
+	void guiShellClosed();
+	void guiSendMouseEvent(int , int , int , int , unsigned int );
+	void guiMouseMoved(int, int);
+	void guiFocusChanged(int);
+
+	void guiHandleDropText(const QString&);
+	void guiHandleDrop(const QPoint& , unsigned int, const QList<QUrl>);
+
+	void sendTablineEvent(int);
+	void sendTablineMenuEvent(int, int);
+
+	void updateCursor(bool force, bool clearsel);
+	void undrawCursor();
+
+	static void setFullscreen(bool on);
+	void setProcessInputOnly(bool input_only);
+	bool processEvents(long wtime=0, bool inputOnly=false);
+
+protected:
+	static QString convertFrom(const char *, int size=-1);
+	bool hasPendingEvents();
+
+private:
+	bool m_processInputOnly;
+	QList<VimEvent *> pendingEvents;
+};
+
+#endif
diff -urN vim-src/src/structs.h vim-qt-src/src/structs.h
--- vim-src/src/structs.h	2016-06-08 06:34:09.833885098 +0200
+++ vim-qt-src/src/structs.h	2016-06-08 06:40:09.668637646 +0200
@@ -2804,6 +2804,10 @@
 
 typedef struct VimMenu vimmenu_T;
 
+#ifdef FEAT_GUI_QT
+struct QMenu;
+#endif
+
 struct VimMenu
 {
     int		modes;		    /* Which modes is this menu visible for? */
@@ -2874,6 +2878,10 @@
     PtWidget_t	*id;
     PtWidget_t	*submenu_id;
 #endif
+#ifdef FEAT_GUI_QT
+    struct QWidget	*qmenu;
+    struct QAction	*qaction;
+#endif
 };
 #else
 /* For generating prototypes when FEAT_MENU isn't defined. */
diff -urN vim-src/src/term.c vim-qt-src/src/term.c
--- vim-src/src/term.c	2016-06-08 06:34:09.836885121 +0200
+++ vim-qt-src/src/term.c	2016-06-08 06:40:09.670637662 +0200
@@ -6033,7 +6033,7 @@
 }
 #endif
 
-#if (defined(WIN3264) && !defined(FEAT_GUI)) || defined(PROTO)
+#if (defined(WIN3264) && !defined(FEAT_GUI)) || defined(PROTO) || (defined(WIN3264) && defined(FEAT_GUI_QT))
 static char ksme_str[20];
 static char ksmr_str[20];
 static char ksmd_str[20];
diff -urN vim-src/src/testdir/test10.in vim-qt-src/src/testdir/test10.in
--- vim-src/src/testdir/test10.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test10.in	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,114 @@
+Test for 'errorformat'.  This will fail if the quickfix feature was disabled.
+
+STARTTEST
+:so small.vim
+:" Also test a BOM is ignored.
+:so mbyte.vim
+:set encoding=utf-8
+:7/start of errorfile/,/end of errorfile/w! Xerrorfile1
+:7/start of errorfile/,/end of errorfile/-1w! Xerrorfile2
+:/start of testfile/,/end of testfile/w! Xtestfile
+:set efm+==%f=\\,\ line\ %l%*\\D%v%*[^\ ]\ %m
+:set efm^=%AError\ in\ \"%f\"\ at\ line\ %l:,%Z%p^,%C%m
+:cf Xerrorfile2
+:clast
+:copen
+:let a=w:quickfix_title
+:wincmd p
+lgR=a
+:cf Xerrorfile1
+grA
+:cn
+gRLINE 6, COL 19
+:cn
+gRNO COLUMN SPECIFIED
+:cn
+gRAGAIN NO COLUMN
+:cn
+gRCOL 1
+:cn
+gRCOL 2
+:cn
+gRCOL 10
+:cn
+gRVCOL 10
+:cn
+grI
+:cn
+gR. SPACE POINTER
+:cn
+gR. DOT POINTER
+:cn
+gR. DASH POINTER
+:cn
+gR. TAB-SPACE POINTER
+:clast
+:cprev
+:cprev
+:wincmd w
+:let a=w:quickfix_title
+:wincmd p
+lgR=a
+:w! test.out             " Write contents of this file
+:qa!
+ENDTEST
+
+start of errorfile
+"Xtestfile", line 4.12: 1506-045 (S) Undeclared identifier fd_set.
+"Xtestfile", line 6 col 19; this is an error
+gcc -c -DHAVE_CONFIsing-prototypes -I/usr/X11R6/include  version.c
+Xtestfile:9: parse error before `asd'
+make: *** [vim] Error 1
+in file "Xtestfile" linenr 10: there is an error
+
+2 returned
+"Xtestfile", line 11 col 1; this is an error
+"Xtestfile", line 12 col 2; this is another error
+"Xtestfile", line 14:10; this is an error in column 10
+=Xtestfile=, line 15:10; this is another error, but in vcol 10 this time
+"Xtestfile", linenr 16: yet another problem
+Error in "Xtestfile" at line 17:
+x should be a dot
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17
+            ^
+Error in "Xtestfile" at line 18:
+x should be a dot
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18
+.............^
+Error in "Xtestfile" at line 19:
+x should be a dot
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19
+--------------^
+Error in "Xtestfile" at line 20:
+x should be a dot
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20
+	       ^
+
+Does anyone know what is the problem and how to correction it?
+"Xtestfile", line 21 col 9: What is the title of the quickfix window?
+"Xtestfile", line 22 col 9: What is the title of the quickfix window?
+end of errorfile
+
+start of testfile
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  4
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  6
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  9
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 10
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 12
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 14
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 15
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 21
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 22
+end of testfile
diff -urN vim-src/src/testdir/test10.ok vim-qt-src/src/testdir/test10.ok
--- vim-src/src/testdir/test10.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test10.ok	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,23 @@
+start of testfile
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3
+	xxxxxxxxxxAxxxxxxxxxxxxxxxxxxx    line  4
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5
+	xxxxxxxxxxxxxxxxxLINE 6, COL 19   line  6
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8
+	NO COLUMN SPECIFIEDxxxxxxxxxxx    line  9
+	AGAIN NO COLUMNxxxxxxxxxxxxxxx    line 10
+COL 1	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11
+	COL 2xxxxxxxxxxxxxxxxxxxxxxxxx    line 12
+	xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13
+	xxxxxxxxCOL 10xxxxxxxxxxxxxxxx    line 14
+	xVCOL 10xxxxxxxxxxxxxxxxxxxxxx    line 15
+	Ixxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16
+	xxxx. SPACE POINTERxxxxxxxxxxx    line 17
+	xxxxx. DOT POINTERxxxxxxxxxxxx    line 18
+	xxxxxx. DASH POINTERxxxxxxxxxx    line 19
+	xxxxxxx. TAB-SPACE POINTERxxxx    line 20
+	xxxxxxxx:cf Xerrorfile1xxxxxxx    line 21
+	xxxxxxxx:cf Xerrorfile2xxxxxxx    line 22
+end of testfile
diff -urN vim-src/src/testdir/test105.in vim-qt-src/src/testdir/test105.in
--- vim-src/src/testdir/test105.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test105.in	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,45 @@
+Test filename modifiers     vim: set ft=vim :
+
+STARTTEST
+:source small.vim
+:%delete _
+:set shell=sh
+:set shellslash
+:let tab="\t"
+:command -nargs=1 Put :let expr=<q-args> | $put =expr.tab.strtrans(string(eval(expr)))
+:let $HOME=fnamemodify('.', ':p:h:h')
+:Put fnamemodify('.',              ':p'      )[-1:]
+:Put fnamemodify('.',              ':p:h'    )[-1:]
+:Put fnamemodify('test.out',       ':p'      )[-1:]
+:Put fnamemodify('test.out',       ':.'      )
+:Put fnamemodify('../testdir/a',   ':.'      )
+:Put fnamemodify('test.out',       ':~'      )
+:Put fnamemodify('../testdir/a',   ':~'      )
+:Put fnamemodify('../testdir/a',   ':t'      )
+:Put fnamemodify('.',              ':p:t'    )
+:Put fnamemodify('test.out',       ':p:t'    )
+:Put fnamemodify('test.out',       ':p:e'    )
+:Put fnamemodify('test.out',       ':p:t:e'  )
+:Put fnamemodify('abc.fb2.tar.gz', ':r'      )
+:Put fnamemodify('abc.fb2.tar.gz', ':r:r'    )
+:Put fnamemodify('abc.fb2.tar.gz', ':r:r:r'  )
+:Put substitute(fnamemodify('abc.fb2.tar.gz', ':p:r:r'), '.*\(testdir/.*\)', '\1', '')
+:Put fnamemodify('abc.fb2.tar.gz', ':e'      )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e'    )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:e'  )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:e:e')
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:r'  )
+:Put fnamemodify('abc def',        ':S'      )
+:Put fnamemodify('abc" "def',      ':S'      )
+:Put fnamemodify('abc"%"def',      ':S'      )
+:Put fnamemodify('abc'' ''def',    ':S'      )
+:Put fnamemodify('abc''%''def',    ':S'      )
+:Put fnamemodify("abc\ndef",       ':S'      )
+:set shell=tcsh
+:Put fnamemodify("abc\ndef",       ':S'      )
+:$put ='vim: ts=8'
+:1 delete _
+:w! test.out
+:qa!
+ENDTEST
+
diff -urN vim-src/src/testdir/test105.ok vim-qt-src/src/testdir/test105.ok
--- vim-src/src/testdir/test105.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test105.ok	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,29 @@
+fnamemodify('.',              ':p'      )[-1:]	'/'
+fnamemodify('.',              ':p:h'    )[-1:]	'r'
+fnamemodify('test.out',       ':p'      )[-1:]	't'
+fnamemodify('test.out',       ':.'      )	'test.out'
+fnamemodify('../testdir/a',   ':.'      )	'a'
+fnamemodify('test.out',       ':~'      )	'~/testdir/test.out'
+fnamemodify('../testdir/a',   ':~'      )	'~/testdir/a'
+fnamemodify('../testdir/a',   ':t'      )	'a'
+fnamemodify('.',              ':p:t'    )	''
+fnamemodify('test.out',       ':p:t'    )	'test.out'
+fnamemodify('test.out',       ':p:e'    )	'out'
+fnamemodify('test.out',       ':p:t:e'  )	'out'
+fnamemodify('abc.fb2.tar.gz', ':r'      )	'abc.fb2.tar'
+fnamemodify('abc.fb2.tar.gz', ':r:r'    )	'abc.fb2'
+fnamemodify('abc.fb2.tar.gz', ':r:r:r'  )	'abc'
+substitute(fnamemodify('abc.fb2.tar.gz', ':p:r:r'), '.*\(testdir/.*\)', '\1', '')	'testdir/abc.fb2'
+fnamemodify('abc.fb2.tar.gz', ':e'      )	'gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e'    )	'tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:e'  )	'fb2.tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:e:e')	'fb2.tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:r'  )	'tar'
+fnamemodify('abc def',        ':S'      )	'''abc def'''
+fnamemodify('abc" "def',      ':S'      )	'''abc" "def'''
+fnamemodify('abc"%"def',      ':S'      )	'''abc"%"def'''
+fnamemodify('abc'' ''def',    ':S'      )	'''abc''\'''' ''\''''def'''
+fnamemodify('abc''%''def',    ':S'      )	'''abc''\''''%''\''''def'''
+fnamemodify("abc\ndef",       ':S'      )	'''abc^@def'''
+fnamemodify("abc\ndef",       ':S'      )	'''abc\^@def'''
+vim: ts=8
diff -urN vim-src/src/testdir/test106.in vim-qt-src/src/testdir/test106.in
--- vim-src/src/testdir/test106.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test106.in	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,16 @@
+Tests for errorformat.  vim: set ft=vim ts=8 :
+
+STARTTEST
+:so small.vim
+:if !has('quickfix') | e! test.ok | wq! test.out | endif
+:set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
+:cgetexpr ['WWWW', 'EEEE', 'CCCC']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:/^Results/,$wq! test.out
+ENDTEST
+
+Results of test106:
diff -urN vim-src/src/testdir/test106.ok vim-qt-src/src/testdir/test106.ok
--- vim-src/src/testdir/test106.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test106.ok	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,4 @@
+Results of test106:
+[['W', 1], ['E^@CCCC', 1]]
+[['W', 1], ['E^@CCCC', 1]]
+[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]
diff -urN vim-src/src/testdir/test10a.in vim-qt-src/src/testdir/test10a.in
--- vim-src/src/testdir/test10a.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test10a.in	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,73 @@
+Test for 'errorformat'.
+
+STARTTEST
+:so small.vim
+:/start of errorfile/,/end of errorfile/w! Xerrorfile
+:/start of testfile/,/end of testfile/w! Xtestfile
+:cf Xerrorfile
+rA
+:cn
+rB
+:cn
+rC
+:cn
+rD
+:cn
+rE
+:w! test.out             " Write contents of this file
+:qa!
+ENDTEST
+
+start of errorfile
+
+                  printf(" %d \n", (number/other)%10 );
+..................^
+%CC-E-NOSEMI, Missing ";".
+at line number 4 in file SYS$DISK:XTESTFILE
+
+             other=10000000;
+.............^
+%CC-E-UNDECLARED, In this statement, "oszt" is not declared.
+at line number 7 in file SYS$DISK:XTESTFILE
+
+             for (i = 0; i<7 ; i++ ){
+..................^
+%CC-E-UNDECLARED, In this statement, "i" is not declared.
+at line number 16 in file SYS$DISK:XTESTFILE
+
+some other error somewhere here.
+...........................^
+%CC-W-WARRING, Sorry, but no expalnation for such an warring.
+at line number 19 in file SYS$DISK:XTESTFILE
+
+and finally some other error exactly here.
+.....................................^
+%CC-I-INFORMATIONAL, It should be some informational message.
+at line number 20 in file SYS$DISK:XTESTFILE
+
+Does anyone know what is the problem and how to correct ??  :)
+end of errorfile
+
+start of testfile
+01234567890123456789012345678901234567
+line 3  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 4  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 5  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 6  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 7  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 8  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 9  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 10 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 11 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 12 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 13 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 14 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 15 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 16 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 17 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 18 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 19 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 20 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 21 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 22 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+end of testfile
diff -urN vim-src/src/testdir/test10a.ok vim-qt-src/src/testdir/test10a.ok
--- vim-src/src/testdir/test10a.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test10a.ok	2016-06-08 06:39:27.815315872 +0200
@@ -0,0 +1,23 @@
+start of testfile
+01234567890123456789012345678901234567
+line 3  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 4  xxxxxxxxxxAxxxxxxxxxxxxxxxxxxx
+line 5  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 6  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 7  xxxxxBxxxxxxxxxxxxxxxxxxxxxxxx
+line 8  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 9  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 10 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 11 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 12 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 13 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 14 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 15 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 16 xxxxxxxxxxCxxxxxxxxxxxxxxxxxxx
+line 17 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 18 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 19 xxxxxxxxxxxxxxxxxxxDxxxxxxxxxx
+line 20 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxE
+line 21 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+line 22 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+end of testfile
diff -urN vim-src/src/testdir/test27.in vim-qt-src/src/testdir/test27.in
--- vim-src/src/testdir/test27.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test27.in	2016-06-08 06:39:27.816315879 +0200
@@ -0,0 +1,20 @@
+Test for expanding file names
+
+STARTTEST
+:!mkdir Xdir1
+:!mkdir Xdir2
+:!mkdir Xdir3
+:cd Xdir3
+:!mkdir Xdir4
+:cd ..
+:w Xdir1/file
+:w Xdir3/Xdir4/file
+:n Xdir?/*/file
+Go%:.w! test.out
+:n! Xdir?/*/nofile
+Go%:.w >>test.out
+:e! xx
+:!rm -rf Xdir1 Xdir2 Xdir3
+:qa!
+ENDTEST
+
diff -urN vim-src/src/testdir/test27.ok vim-qt-src/src/testdir/test27.ok
--- vim-src/src/testdir/test27.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test27.ok	2016-06-08 06:39:27.816315879 +0200
@@ -0,0 +1,2 @@
+Xdir3/Xdir4/file
+Xdir?/*/nofile
diff -urN vim-src/src/testdir/test74.in vim-qt-src/src/testdir/test74.in
--- vim-src/src/testdir/test74.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test74.in	2016-06-08 06:39:27.821315918 +0200
@@ -0,0 +1,36 @@
+" Tests for storing global variables in the .viminfo file vim: set ft=vim:
+
+STARTTEST
+:so small.vim
+:" Do all test in a separate window to avoid E211 when we recursively
+:" delete the Xfind directory during cleanup
+:"
+:" This will cause a few errors, do it silently.
+:set visualbell
+:set nocp viminfo+=!,nviminfo
+:let MY_GLOBAL_DICT={'foo': 1, 'bar': 0, 'longvarible': 1000}
+:" store a really long list, so line wrapping will occur in viminfo file
+:let MY_GLOBAL_LIST=range(1,100)
+:wv! Xviminfo
+:unlet MY_GLOBAL_DICT
+:unlet MY_GLOBAL_LIST
+:rv! Xviminfo
+:call delete('Xviminfo')
+:if exists("MY_GLOBAL_DICT")
+:redir >> test.out
+:echo MY_GLOBAL_DICT
+:redir end
+:endif
+:if exists("MY_GLOBAL_LIST")
+:redir >> test.out
+:echo MY_GLOBAL_LIST
+:redir end
+:endif
+:redir >> test.out
+:echo "foobar"
+:redir end
+:endif
+:qa!
+ENDTEST
+
+eof
diff -urN vim-src/src/testdir/test74.ok vim-qt-src/src/testdir/test74.ok
--- vim-src/src/testdir/test74.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test74.ok	2016-06-08 06:39:27.822315925 +0200
@@ -0,0 +1,5 @@
+
+{'foo': 1, 'longvarible': 1000, 'bar': 0}
+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
+
+foobar
diff -urN vim-src/src/testdir/test96.in vim-qt-src/src/testdir/test96.in
--- vim-src/src/testdir/test96.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test96.in	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,142 @@
+This will test for problems in quickfix:
+A. incorrectly copying location lists which caused the location list to show a
+   different name than the file that was actually being displayed.
+B. not reusing the window for which the location list window is opened but
+   instead creating new windows.
+C. make sure that the location list window is not reused instead of the window
+   it belongs to.
+
+Note: to debug a problem comment out the last ":b 1" in a test and testing will
+stop at this point.
+
+STARTTEST
+:so small.vim
+: enew
+: w! test.out
+: b 1
+: " Set up the test environment:
+: function! ReadTestProtocol(name)
+:   let base = substitute(a:name, '\v^test://(.*)%(\.[^.]+)?', '\1', '')
+:   let word = substitute(base, '\v(.*)\..*', '\1', '')
+:
+:   setl modifiable
+:   setl noreadonly
+:   setl noswapfile
+:   setl bufhidden=delete
+:   %del _
+:   " For problem 2:
+:   " 'buftype' has to be set to reproduce the constant opening of new windows
+:   setl buftype=nofile
+:
+:   call setline(1, word)
+:
+:   setl nomodified
+:   setl nomodifiable
+:   setl readonly
+:   exe 'doautocmd BufRead ' . substitute(a:name, '\v^test://(.*)', '\1', '')
+: endfunction
+: augroup testgroup
+:   au!
+:   autocmd BufReadCmd test://* call ReadTestProtocol(expand("<amatch>"))
+: augroup END
+: let words = [ "foo", "bar", "baz", "quux", "shmoo", "spam", "eggs" ]
+:
+: let qflist = []
+: for word in words
+:   call add(qflist, {'filename': 'test://' . word . '.txt', 'text': 'file ' . word . '.txt', })
+:   " NOTE: problem 1:
+:   " intentionally not setting 'lnum' so that the quickfix entries are not
+:   " valid
+:   call setloclist(0, qflist, ' ')
+: endfor
+ENDTEST
+
+Test A:
+STARTTEST
+:lrewind
+:enew
+:lopen
+:lnext
+:lnext
+:lnext
+:lnext
+:vert split
+:wincmd L
+:lopen
+:wincmd p
+:lnext
+:"b 1
+:let fileName = expand("%")
+:wincmd p
+:let locationListFileName = substitute(getline(line('.')), '\([^|]*\)|.*', '\1', '')
+:wincmd n
+:wincmd K
+:b test.out
+:let fileName = substitute(fileName, '\\', '/', 'g')
+:let locationListFileName = substitute(locationListFileName, '\\', '/', 'g')
+:call append(line('$'), "Test A:")
+:call append(line('$'), "  - file name displayed: " . fileName)
+:call append(line('$'), "  - quickfix claims that the file name displayed is: " . locationListFileName)
+:w
+:wincmd o
+:b 1
+ENDTEST
+
+Test B:
+STARTTEST
+:lrewind
+:lopen
+:2
+:exe "normal \<CR>"
+:wincmd p
+:3
+:exe "normal \<CR>"
+:wincmd p
+:4
+:exe "normal \<CR>"
+:let numberOfWindowsOpen = winnr('$')
+:wincmd n
+:wincmd K
+:b test.out
+:call append(line('$'), "Test B:")
+:call append(line('$'), "  - number of window open: " . numberOfWindowsOpen)
+:w
+:wincmd o
+:b 1
+ENDTEST
+
+Test C:
+STARTTEST
+:lrewind
+:lopen
+:" Let's move the location list window to the top to check whether it (the first
+:" window found) will be reused when we try to open new windows:
+:wincmd K
+:2
+:exe "normal \<CR>"
+:wincmd p
+:3
+:exe "normal \<CR>"
+:wincmd p
+:4
+:exe "normal \<CR>"
+:1wincmd w
+:let locationListWindowBufType = &buftype
+:2wincmd w
+:let bufferName = expand("%")
+:wincmd n
+:wincmd K
+:b test.out
+:let bufferName = substitute(bufferName, '\\', '/', 'g')
+:call append(line('$'), "Test C:")
+:call append(line('$'), "  - 'buftype' of the location list window: " . locationListWindowBufType)
+:call append(line('$'), "  - buffer displayed in the 2nd window: " . bufferName)
+:w
+:wincmd o
+:b 1
+ENDTEST
+
+STARTTEST
+:qa
+ENDTEST
+
diff -urN vim-src/src/testdir/test96.ok vim-qt-src/src/testdir/test96.ok
--- vim-src/src/testdir/test96.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test96.ok	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,9 @@
+
+Test A:
+  - file name displayed: test://bar.txt
+  - quickfix claims that the file name displayed is: test://bar.txt
+Test B:
+  - number of window open: 2
+Test C:
+  - 'buftype' of the location list window: quickfix
+  - buffer displayed in the 2nd window: test://quux.txt
diff -urN vim-src/src/testdir/test_argument_0count.in vim-qt-src/src/testdir/test_argument_0count.in
--- vim-src/src/testdir/test_argument_0count.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_argument_0count.in	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,28 @@
+Tests for :0argadd and :0argedit     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:let arglists = []
+:%argd
+:arga a b c d
+:2argu
+:0arga added
+:call add(arglists, argv())
+:2argu
+:arga third
+:call add(arglists, argv())
+:%argd
+:arga a b c d
+:2argu
+:0arge edited
+:call add(arglists, argv())
+:2argu
+:arga third
+:call add(arglists, argv())
+:e! test.out
+:call append(0, map(copy(arglists), 'join(v:val, " ")'))
+:w
+:qa!
+ENDTEST
+
+
diff -urN vim-src/src/testdir/test_argument_0count.ok vim-qt-src/src/testdir/test_argument_0count.ok
--- vim-src/src/testdir/test_argument_0count.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_argument_0count.ok	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,5 @@
+added a b c d
+added a third b c d
+edited a b c d
+edited a third b c d
+
diff -urN vim-src/src/testdir/test_argument_count.in vim-qt-src/src/testdir/test_argument_count.in
--- vim-src/src/testdir/test_argument_count.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_argument_count.in	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,47 @@
+Tests for :[count]argument! and :[count]argdelete     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:%argd
+:argadd a b c d
+:set hidden
+:let buffers = []
+:augroup TEST
+:au BufEnter * call add(buffers, expand('%:t'))
+:augroup END
+:$argu
+:$-argu
+:-argu
+:1argu
+:+2argu
+:augroup TEST
+:au!
+:augroup END
+:let arglists = []
+:.argd
+:call add(arglists, argv())
+:-argd
+:call add(arglists, argv())
+:$argd
+:call add(arglists, argv())
+:1arga c
+:1arga b
+:$argu
+:$arga x
+:call add(arglists, argv())
+:0arga Y
+:call add(arglists, argv())
+:%argd
+:call add(arglists, argv())
+:arga a b c d e f
+:2,$-argd
+:call add(arglists, argv())
+:e! test.out
+:call append(0, buffers)
+:let lnr = line('$')
+:call append(lnr, map(copy(arglists), 'join(v:val, " ")'))
+:w
+:qa!
+ENDTEST
+
+
diff -urN vim-src/src/testdir/test_argument_count.ok vim-qt-src/src/testdir/test_argument_count.ok
--- vim-src/src/testdir/test_argument_count.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_argument_count.ok	2016-06-08 06:39:27.827315964 +0200
@@ -0,0 +1,13 @@
+d
+c
+b
+a
+c
+
+a b d
+a d
+a
+a b c x
+Y a b c x
+
+a f
diff -urN vim-src/src/testdir/test_increment.in vim-qt-src/src/testdir/test_increment.in
--- vim-src/src/testdir/test_increment.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_increment.in	2016-06-08 06:39:27.828315971 +0200
@@ -0,0 +1,734 @@
+Tests for using Ctrl-A/Ctrl-X on visual selections
+
+Test cases
+==========
+
+1) Ctrl-A on visually selected number
+Text:
+foobar-10
+    Expected:
+    1)    Ctrl-A on start of line:
+	foobar-9
+    2)    Ctrl-A on visually selected "-10":
+	foobar-9
+    3)    Ctrl-A on visually selected "10":
+	foobar-11
+    4)    Ctrl-X on visually selected "-10"
+	foobar-11
+    5)    Ctrl-X on visually selected "10"
+	foobar-9
+
+2) Ctrl-A on visually selected lines
+Text:
+10
+20
+30
+40
+
+    Expected:
+    1) Ctrl-A on visually selected lines:
+11
+21
+31
+41
+
+    2) Ctrl-X on visually selected lines:
+9
+19
+29
+39
+
+3) g Ctrl-A on visually selected lines, with non-numbers in between
+Text:
+10
+
+20
+
+30
+
+40
+
+    Expected:
+    1) 2 g Ctrl-A on visually selected lines:
+12
+
+24
+
+36
+
+48
+    2) 2 g Ctrl-X on visually selected lines
+8
+
+16
+
+24
+
+32
+
+4) Ctrl-A on non-number
+Text:
+foobar-10
+    Expected:
+    1) visually select foobar:
+    foobar-10
+
+5) g<Ctrl-A> on letter
+Test:
+a
+a
+a
+a
+    Expected:
+    1) g Ctrl-A on visually selected lines
+    b
+    c
+    d
+    e
+
+6) g<Ctrl-A> on letter
+Test:
+z
+z
+z
+z
+    Expected:
+    1) g Ctrl-X on visually selected lines
+    y
+    x
+    w
+    v
+
+7) <Ctrl-A> on letter
+Test:
+2
+1
+0
+-1
+-2
+
+    Expected:
+    1) Ctrl-A on visually selected lines
+    3
+    2
+    1
+    0
+    -1
+
+    2) Ctrl-X on visually selected lines
+    1
+    0
+    -1
+    -2
+    -3
+8) Block increment on 0x9
+Text:
+0x9
+0x9
+    Expected:
+    1) Ctrl-A on visually block selected region (cursor at beginning):
+    0xa
+    0xa
+    2) Ctrl-A on visually block selected region (cursor at end)
+    0xa
+    0xa
+
+9) Increment and redo
+Text:
+2
+2
+
+3
+3
+
+    Expected:
+    1) 2 Ctrl-A on first 2 visually selected lines
+    4
+    4
+    2) redo (.) on 3
+    5
+    5
+10) sequentially decrement 1
+Text:
+1
+1
+1
+1
+    Expected:
+    1) g Ctrl-X on visually selected lines
+    0
+    -1
+    -2
+    -3
+
+11) visually block selected indented lines
+Text:
+    1
+1
+    1
+    1
+    Expexted:
+    1) g Ctrl-A on block selected indented lines
+    2
+1
+    3
+    4
+
+12) visually selected several columns
+Text:
+0 0
+0 0
+0 0
+    Expected:
+    1) 'v' select last zero and first zeroes
+    0 1
+    1 0
+    1 0
+
+13) visually selected part of columns
+Text:
+max: 100px
+max: 200px
+max: 300px
+max: 400px
+    Expected:
+    1) 'v' on first two numbers Ctrl-A
+    max: 110px
+    max: 220px
+    max: 330px
+    max: 400px
+    2) 'v' on first two numbers Ctrl-X
+    max: 90px
+    max: 190px
+    max: 290px
+    max: 400px
+
+14) redo in block mode
+Text:
+1 1
+1 1
+    Expected:
+    1) Ctrl-a on first column, redo on second column
+    2 2
+    2 2
+
+15) block select single numbers
+Text:
+101
+    Expected:
+    1) Ctrl-a on visually selected zero
+    111
+
+16) increment right aligned numbers
+Text:
+   1
+  19
+ 119
+    Expected:
+    1) Ctrl-a on line selected region
+       2
+      20
+     120
+
+17) block-wise increment and redo
+Text:
+  100
+  1
+
+  100
+  1
+
+  Expected:
+  1) Ctrl-V j $ on first block, afterwards '.' on second
+  101
+  2
+
+  101
+  2
+
+18) repeat of g<Ctrl-a>
+Text:
+  0
+  0
+  0
+  0
+
+  Expected:
+  1) V 4j g<ctrl-a>, repeat twice afterwards with .
+  3
+  6
+  9
+  12
+  
+19) increment on number with nrformat including alpha
+Text:
+ 1
+ 1a
+
+ Expected:
+ 1) <Ctrl-V>j$ <ctrl-a>
+ 2
+ 2a
+
+20) increment a single letter
+Text:
+ a
+
+ Expected:
+ 1) <Ctrl-a> and cursor is on a
+ b
+
+21) block-wise increment on part of hexadecimal
+Text:
+0x123456
+
+  Expected:
+  1) Ctrl-V f3 <ctrl-a>
+0x124456
+
+22) Block increment on 0b0
+Text:
+0b1
+0b1
+    Expected:
+    1) Ctrl-A on visually block selected region (cursor at beginning):
+    0b10
+    0b10
+    2) Ctrl-A on visually block selected region (cursor at end)
+    0b10
+    0b10
+
+23) block-wise increment on part of binary
+Text:
+0b1001
+
+  Expected:
+  1) Ctrl-V 5l <ctrl-a>
+0b1011
+
+24) increment hexadecimal
+Text:
+0x0b1001
+
+  Expected:
+  1) <ctrl-a>
+0x0b1002
+
+25) increment binary with nrformats including alpha
+Text:
+0b1001a
+
+  Expected:
+  1) <ctrl-a>
+0b1010a
+
+26) increment binary with 64 bits
+Text:
+0b1111111111111111111111111111111111111111111111111111111111111110
+
+  Expected:
+  1) <ctrl-a>
+0b1111111111111111111111111111111111111111111111111111111111111111
+
+
+STARTTEST
+:so small.vim
+:"
+:" Avoid CTRL-X being mapped in Visual mode for MS-Windows
+:vmapclear
+:"
+:" Test 1
+:/^S1=/+,/^E1=/-y a
+:/^E1=/+put a
+:/^E1=/+2put a
+f-v$:/^E1=/+3put a
+f1v$:/^E1=/+4put a
+f-v$:/^E1=/+5put a
+f1v$
+
+:" Test 2
+:/^S2=/+,/^E2=/-y a
+:/^E2=/+put a
+V3k$3j:.+put a
+V3k$
+
+:" Test 3
+:/^S3=/+,/^E3=/-y a
+:/^E3=/+put a
+V6k2g6j:.+put a
+V6k2g
+
+:" Test 4
+:/^S4=/+,/^E4=/-y a
+:/^E4=/+put a
+vf-
+
+:" Test 5
+:set nrformats+=alpha
+:/^S5=/+,/^E5=/-y a
+:/^E5=/+put a
+v3kg
+
+:" Test 6
+:/^S6=/+,/^E6=/-y a
+:/^E6=/+put a
+v3kg
+
+:" Test 7
+:set nrformats&vim
+:/^S7=/+,/^E7=/-y a
+:/^E7=/+put a
+V4k4j:.+put a
+V4k
+
+:" Test 8
+:/^S8=/+,/^E8=/-y a
+:/^E8=/+put a
+kj$j:.+put a
+k$+
+
+:" Test 9
+:/^S9=/+,/^E9=/-y a
+:/^E9=/+put a
+5kVj23j.
+
+:" Test 10
+:/^S10=/+,/^E10=/-y a
+:/^E10=/+put a
+V3kg
+
+: Test 11
+:/^S11=/+,/^E11=/-y a
+:/^E11=/+put a
+3kf13jg
+
+:" Test 12
+:/^S12=/+,/^E12=/-y a
+:/^E12=/+put a
+2k$v++
+
+:" Test 13
+:/^S13=/+,/^E13=/-y a
+:/^E13=/+put a
+3kf1l2j3j:.+put a
+3kf1l2j
+
+:" Test 14
+:/^S14=/+,/^E14=/-y a
+:/^E14=/+put a
+kw.
+
+:" Test 15
+:/^S15=/+,/^E15=/-y a
+:/^E15=/+put a
+lv
+
+:" Test 16
+:/^S16=/+,/^E16=/-y a
+:/^E16=/+put a
+V3k
+
+:" Test 17
+:/^S17=/+,/^E17=/-y a
+:/^E17=/+put a
+4kj$2j.
+
+:" Test 18
+:/^S18=/+,/^E18=/-y a
+:/^E18=/+put a
+V3kg..
+
+:" Test 19
+:set nrformats+=alpha
+:/^S19=/+,/^E19=/-y a
+:/^E19=/+put a
+k$
+:set nrformats&vim
+
+:" Test 20
+:set nrformats+=alpha
+:/^S20=/+,/^E20=/-y a
+:/^E20=/+put a
+:.put =col('.')
+:set nrformats&vim
+
+:" Test 21
+:/^S21=/+,/^E21=/-y a
+:/^E21=/+put a
+:set nrformats&vim
+f3
+
+:" Test 22
+:/^S22=/+,/^E22=/-y a
+:/^E22=/+put a
+kj$j:.+put a
+k$+
+
+:" Test 23
+:/^S23=/+,/^E23=/-y a
+:/^E23=/+put a
+:set nrformats&vim
+4l
+
+:" Test 24
+:/^S24=/+,/^E24=/-y a
+:/^E24=/+put a
+:set nrformats&vim
+$
+
+:" Test 25
+:set nrformats+=alpha
+:/^S25=/+,/^E25=/-y a
+:/^E25=/+put a
+k$
+:set nrformats&vim
+
+:" Test 26
+:set nrformats+=alpha
+:/^S26=/+,/^E26=/-y a
+:/^E26=/+put a
+k$
+:set nrformats&vim
+
+:" Save the report
+:/^# Test 1/,$w! test.out
+:qa!
+
+
+# Test 1
+S1======
+foobar-10
+E1======
+
+
+
+# Test 2
+S2=====
+10
+20
+30
+40
+E2=====
+
+
+
+# Test 3
+S3=====
+10
+
+20
+
+30
+
+40
+E3=====
+
+
+
+# Test 4
+S4=====
+foobar-10
+E4=====
+
+
+
+# Test 5
+S5====
+a
+a
+a
+a
+E5====
+
+
+# Test 6
+S6====
+z
+z
+z
+z
+E6====
+
+
+
+# Test 7
+S7====
+2
+1
+0
+-1
+-2
+E7====
+
+
+
+# Test 8
+S8====
+0x9
+0x9
+E8====
+
+
+
+
+# Test 9
+S9====
+2
+2
+
+3
+3
+
+E9====
+
+
+
+
+# Test 10
+S10====
+1
+1
+1
+1
+E10====
+
+
+
+
+# Test 11
+S11====
+    1
+1
+    1
+    1
+E11====
+
+
+
+# Test 12
+S12====
+0 0
+0 0
+0 0
+E12====
+
+
+
+# Test 13
+S13====
+max: 100px
+max: 200px
+max: 300px
+max: 400px
+E13====
+
+
+
+# Test 14
+S14====
+1 1
+1 1
+E14====
+
+
+
+# Test 15
+S15====
+101
+E15====
+
+
+
+# Test 16
+S16====
+   1
+  19
+ 119
+E16====
+
+
+
+# Test 17
+S17====
+ 100
+ 1
+
+ 100
+ 1
+E17====
+
+
+# Test 18
+S18====
+0
+0
+0
+0
+E18====
+
+
+
+# Test 19
+S19====
+1
+1a
+E19====
+
+
+
+# Test 20
+S20====
+a
+E20====
+
+
+
+# Test 21
+S21====
+0x123456
+E21====
+
+
+
+# Test 22
+S22====
+0b1
+0b1
+E22====
+
+
+
+
+# Test 23
+S23====
+0b1001
+E23====
+
+
+
+
+# Test 24
+S24====
+0x0b1001
+E24====
+
+
+
+
+# Test 25
+S25====
+0b1001a
+E25====
+
+
+
+
+# Test 26
+S26====
+0b11111111111111111111111111111110
+E26====
+
+
+
+ENDTEST
+
diff -urN vim-src/src/testdir/test_increment.ok vim-qt-src/src/testdir/test_increment.ok
--- vim-src/src/testdir/test_increment.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_increment.ok	2016-06-08 06:39:27.828315971 +0200
@@ -0,0 +1,340 @@
+# Test 1
+S1======
+foobar-10
+E1======
+
+foobar-9
+foobar-9
+foobar-11
+foobar-11
+foobar-9
+
+
+# Test 2
+S2=====
+10
+20
+30
+40
+E2=====
+
+11
+21
+31
+41
+
+9
+19
+29
+39
+
+# Test 3
+S3=====
+10
+
+20
+
+30
+
+40
+E3=====
+
+12
+
+24
+
+36
+
+48
+
+8
+
+16
+
+24
+
+32
+
+# Test 4
+S4=====
+foobar-10
+E4=====
+
+foobar-10
+
+
+# Test 5
+S5====
+a
+a
+a
+a
+E5====
+
+b
+c
+d
+e
+
+# Test 6
+S6====
+z
+z
+z
+z
+E6====
+
+y
+x
+w
+v
+
+
+# Test 7
+S7====
+2
+1
+0
+-1
+-2
+E7====
+
+3
+2
+1
+0
+-1
+
+1
+0
+-1
+-2
+-3
+
+# Test 8
+S8====
+0x9
+0x9
+E8====
+
+0xa
+0xa
+
+0xa
+0xa
+
+
+# Test 9
+S9====
+2
+2
+
+3
+3
+
+E9====
+
+4
+4
+
+5
+5
+
+
+
+
+# Test 10
+S10====
+1
+1
+1
+1
+E10====
+
+0
+-1
+-2
+-3
+
+
+
+# Test 11
+S11====
+    1
+1
+    1
+    1
+E11====
+
+    2
+1
+    3
+    4
+
+
+# Test 12
+S12====
+0 0
+0 0
+0 0
+E12====
+
+0 1
+1 0
+1 0
+
+
+# Test 13
+S13====
+max: 100px
+max: 200px
+max: 300px
+max: 400px
+E13====
+
+max: 110px
+max: 210px
+max: 310px
+max: 400px
+
+max: 90px
+max: 190px
+max: 290px
+max: 400px
+
+# Test 14
+S14====
+1 1
+1 1
+E14====
+
+2 2
+2 2
+
+
+# Test 15
+S15====
+101
+E15====
+
+111
+
+
+# Test 16
+S16====
+   1
+  19
+ 119
+E16====
+
+   2
+  20
+ 120
+
+
+# Test 17
+S17====
+ 100
+ 1
+
+ 100
+ 1
+E17====
+
+ 101
+ 2
+
+ 101
+ 1
+
+# Test 18
+S18====
+0
+0
+0
+0
+E18====
+
+3
+6
+9
+12
+
+
+# Test 19
+S19====
+1
+1a
+E19====
+
+2
+2a
+
+
+# Test 20
+S20====
+a
+E20====
+
+b
+1
+
+
+# Test 21
+S21====
+0x123456
+E21====
+
+0x124456
+
+
+# Test 22
+S22====
+0b1
+0b1
+E22====
+
+0b10
+0b10
+
+0b10
+0b10
+
+
+# Test 23
+S23====
+0b1001
+E23====
+
+0b1011
+
+
+
+# Test 24
+S24====
+0x0b1001
+E24====
+
+0x0b1002
+
+
+
+# Test 25
+S25====
+0b1001a
+E25====
+
+0b1010a
+
+
+
+# Test 26
+S26====
+0b11111111111111111111111111111110
+E26====
+
+0b11111111111111111111111111111111
+
+
+ENDTEST
+
diff -urN vim-src/src/testdir/test_match_conceal.in vim-qt-src/src/testdir/test_match_conceal.in
--- vim-src/src/testdir/test_match_conceal.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_match_conceal.in	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,159 @@
+Test for matchadd() and conceal feature
+
+STARTTEST
+:so small.vim
+:if !has("conceal") | e! test.ok | w! test.out | qa! | endif
+:set term=ansi
+:so mbyte.vim
+:if &enc !=? 'utf-8'|:e! test.ok|:w! test.out|qa!|endif
+:10new|:vsp|:vert resize 20
+:put =\"\#\ This\ is\ a\ Test\"
+:norm! mazt
+:fu! ScreenChar(width, lines)
+:	let c=''
+:	for j in range(1,a:lines)
+:	    for i in range(1,a:width)
+:	    	let c.=nr2char(screenchar(j, i))
+:	    endfor
+:           let c.="\n"
+:	endfor
+:	return c
+:endfu
+:fu! ScreenAttr(line, pos, eval)
+:       let g:attr=[]
+:       for col in a:pos
+:	    call add(g:attr, screenattr(a:line,col))
+:	endfor
+:	" In case all values are zero, probably the terminal
+:       " isn't set correctly, so catch that case
+:	let null = (eval(join(g:attr, '+')) == 0)
+:       let str=substitute(a:eval, '\d\+', 'g:attr[&]', 'g')
+:	if null || eval(str)
+:	    :let g:attr_test="OK: ". str
+:	else
+:	    :let g:attr_test="FAILED: ".str
+:	    :let g:attr_test.="\n". join(g:attr, ' ')
+:	    :let g:attr_test.="\n TERM: ". &term
+:	endif
+:endfu
+:fu! DoRecordScreen()
+:	wincmd l
+:	$put =printf(\"\n%s\", g:test)
+:	$put =g:line
+:       $put =g:attr_test
+:	wincmd p
+:endfu
+:let g:test ="Test 1: simple addmatch()"
+:call matchadd('Conceal', '\%2l ')
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 2: simple addmatch() and conceal (should be: #XThisXisXaXTest)"
+:norm! 'azt
+:call clearmatches()
+:syntax on
+:set concealcursor=n conceallevel=1
+:call matchadd('Conceal', '\%2l ', 10, -1, {'conceal': 'X'})
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 3: addmatch() and conceallevel=3 (should be: #ThisisaTest)"
+:norm! 'azt
+:set conceallevel=3
+:call clearmatches()
+:call matchadd('Conceal', '\%2l ', 10, -1, {'conceal': 'X'})
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0==1 && 1==2 && 1==3 && 1==4 && 0!=5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 4: more match() (should be: #Thisisa Test)"
+:norm! 'azt
+:call matchadd('ErrorMsg', '\%2l Test', 20, -1, {'conceal': 'X'})
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0==1 && 1==2 && 0!=3 && 3==4 && 0!=5 && 3!=5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 5/1: default conceal char (should be: # This is a Test)"
+:norm! 'azt
+:call clearmatches()
+:set conceallevel=1
+:call matchadd('Conceal', '\%2l ', 10, -1, {})
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:let g:test ="Test 5/2: default conceal char (should be: #+This+is+a+Test)"
+:norm! 'azt
+:set listchars=conceal:+
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:set listchars&vim
+:
+:let g:test ="Test 6/1: syn and match conceal (should be: #ZThisZisZaZTest)"
+:norm! 'azt
+:call clearmatches()
+:set conceallevel=1
+:call matchadd('Conceal', '\%2l ', 10, -1, {'conceal': 'Z'})
+:syn match MyConceal /\%2l / conceal containedin=ALL cchar=*
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:let g:test ="Test 6/2: syn and match conceal (should be: #*This*is*a*Test)"
+:norm! 'azt
+:call clearmatches()
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 7/1: clear matches"
+:norm! 'azt
+:syn on
+:call matchadd('Conceal', '\%2l ', 10, -1, {'conceal': 'Z'})
+:let a=getmatches()
+:call clearmatches()
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0==1 && 0==2 && 0==3 && 0==4 && 0==5")
+:call DoRecordScreen()
+:$put =a
+:call setmatches(a)
+:norm! 'azt
+:let g:test ="Test 7/2: reset match using setmatches()"
+:norm! 'azt
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:
+:let g:test ="Test 8: using matchaddpos() (should be #Pis a Test"
+:norm! 'azt
+:call clearmatches()
+:call matchaddpos('Conceal', [[2,2,6]], 10, -1, {'conceal': 'P'})
+:let a=getmatches()
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1!=2 && 0==2 && 0==3 && 0!=4 && 0!=5 && 4==5")
+:call DoRecordScreen()
+:$put =a
+:
+:let g:test ="Test 9: match using multibyte conceal char (should be: #ThisisaTest)"
+:norm! 'azt
+:call clearmatches()
+:call matchadd('Conceal', '\%2l ', 20, -1, {'conceal': "\u02d1"})
+:redraw!
+:let line=ScreenChar(winwidth(0),1)
+:call ScreenAttr(1,[1,2,7,10,12,16], "0!=1 && 1==2 && 1==3 && 1==4 && 0==5")
+:call DoRecordScreen()
+:
+:"sleep 10
+:%w! test.out
+:qa!
+ENDTEST
+dummy text
diff -urN vim-src/src/testdir/test_match_conceal.ok vim-qt-src/src/testdir/test_match_conceal.ok
--- vim-src/src/testdir/test_match_conceal.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_match_conceal.ok	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,52 @@
+
+# This is a Test
+
+Test 1: simple addmatch()
+# This is a Test    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 2: simple addmatch() and conceal (should be: #XThisXisXaXTest)
+#XThisXisXaXTest    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 3: addmatch() and conceallevel=3 (should be: #ThisisaTest)
+#ThisisaTest        
+OK: g:attr[0]==g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]!=g:attr[5]
+
+Test 4: more match() (should be: #Thisisa Test)
+#Thisisa Test       
+OK: g:attr[0]==g:attr[1] && g:attr[1]==g:attr[2] && g:attr[0]!=g:attr[3] && g:attr[3]==g:attr[4] && g:attr[0]!=g:attr[5] && g:attr[3]!=g:attr[5]
+
+Test 5/1: default conceal char (should be: # This is a Test)
+# This is a Test    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 5/2: default conceal char (should be: #+This+is+a+Test)
+#+This+is+a+Test    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 6/1: syn and match conceal (should be: #ZThisZisZaZTest)
+#ZThisZisZaZTest    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 6/2: syn and match conceal (should be: #*This*is*a*Test)
+#*This*is*a*Test    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 7/1: clear matches
+# This is a Test    
+OK: g:attr[0]==g:attr[1] && g:attr[0]==g:attr[2] && g:attr[0]==g:attr[3] && g:attr[0]==g:attr[4] && g:attr[0]==g:attr[5]
+{'group': 'Conceal', 'pattern': '\%2l ', 'priority': 10, 'id': 10, 'conceal': 'Z'}
+
+Test 7/2: reset match using setmatches()
+#ZThisZisZaZTest    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
+
+Test 8: using matchaddpos() (should be #Pis a Test
+#Pis a Test         
+OK: g:attr[0]!=g:attr[1] && g:attr[1]!=g:attr[2] && g:attr[0]==g:attr[2] && g:attr[0]==g:attr[3] && g:attr[0]!=g:attr[4] && g:attr[0]!=g:attr[5] && g:attr[4]==g:attr[5]
+{'group': 'Conceal', 'id': 11, 'priority': 10, 'pos1': [2, 2, 6], 'conceal': 'P'}
+
+Test 9: match using multibyte conceal char (should be: #ThisisaTest)
+#ThisisaTest    
+OK: g:attr[0]!=g:attr[1] && g:attr[1]==g:attr[2] && g:attr[1]==g:attr[3] && g:attr[1]==g:attr[4] && g:attr[0]==g:attr[5]
diff -urN vim-src/src/testdir/test_perl.in vim-qt-src/src/testdir/test_perl.in
--- vim-src/src/testdir/test_perl.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_perl.in	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,26 @@
+Tests for perl interface.     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:set nocompatible viminfo+=nviminfo
+:if !has('perl') | e! test.ok | wq! test.out | endif
+:" change buffer contents
+:perl VIM::DoCommand("normal /^1\n")
+:perl $curline = VIM::Eval("line('.')")
+:perl $curbuf->Set($curline, "1 changed line 1")
+:" evaluate a List
+:perl VIM::DoCommand("normal /^2\n")
+:perl $curline = VIM::Eval("line('.')")
+:let l = ["abc", "def"]
+:perl << EOF
+$l = VIM::Eval("l");
+$curbuf->Append($curline, $l);
+EOF
+:normal j
+:.perldo s|\n|/|g
+:?^1?,$w! test.out
+:qa!
+ENDTEST
+
+1 line 1
+2 line 2
diff -urN vim-src/src/testdir/test_perl.ok vim-qt-src/src/testdir/test_perl.ok
--- vim-src/src/testdir/test_perl.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_perl.ok	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,3 @@
+1 changed line 1
+2 line 2
+abc/def/
diff -urN vim-src/src/testdir/test_qf_title.in vim-qt-src/src/testdir/test_qf_title.in
--- vim-src/src/testdir/test_qf_title.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_qf_title.in	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,18 @@
+Tests for quickfix window's title     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:if !has('quickfix') | e! test.ok | wq! test.out | endif
+:set efm=%E%f:%l:%c:%m
+:cgetexpr ['file:1:1:message']
+:let qflist=getqflist()
+:call setqflist(qflist, 'r')
+:copen
+:let g:quickfix_title=w:quickfix_title
+:wincmd p
+:$put =g:quickfix_title
+:/^Results/,$w test.out
+:qa!
+ENDTEST
+
+Results of test_qf_title:
diff -urN vim-src/src/testdir/test_qf_title.ok vim-qt-src/src/testdir/test_qf_title.ok
--- vim-src/src/testdir/test_qf_title.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/testdir/test_qf_title.ok	2016-06-08 06:39:27.829315979 +0200
@@ -0,0 +1,2 @@
+Results of test_qf_title:
+:setqflist()
Binary files vim-src/src/tools16.bmp and vim-qt-src/src/tools16.bmp differ
diff -urN vim-src/src/ui.c vim-qt-src/src/ui.c
--- vim-src/src/ui.c	2016-03-27 19:08:37.254723003 +0200
+++ vim-qt-src/src/ui.c	2016-06-08 06:40:09.680637739 +0200
@@ -3112,7 +3112,7 @@
 
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
 	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(PROTO)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_QT) || defined(PROTO)
 /*
  * Translate window coordinates to buffer position without any side effects
  */
diff -urN vim-src/src/vim.h vim-qt-src/src/vim.h
--- vim-src/src/vim.h	2016-06-08 06:34:09.851885235 +0200
+++ vim-qt-src/src/vim.h	2016-06-08 06:40:09.681637746 +0200
@@ -120,6 +120,11 @@
 # define FEAT_GUI_MAC
 #endif
 
+#if defined(FEAT_GUI_QT)
+# define FEAT_GUI
+#endif
+
+
 #if defined(FEAT_GUI_MOTIF) \
     || defined(FEAT_GUI_GTK) \
     || defined(FEAT_GUI_ATHENA) \
@@ -1986,6 +1991,10 @@
     GdkAtom     gtk_sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
 # endif
 
+# ifdef FEAT_GUI_QT
+    int		clipboardMode;
+# endif
+
 # if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
     int_u	format;		/* Vim's own special clipboard format */
     int_u	format_raw;	/* Vim's raw text clipboard format */
@@ -2010,7 +2019,8 @@
  * been seen at that stage.  But it must be before globals.h, where error_ga
  * is declared. */
 #if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \
-	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC)
+	&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) \
+        && !defined(FEAT_GUI_QT)
 # define mch_errmsg(str)	fprintf(stderr, "%s", (str))
 # define display_errors()	fflush(stderr)
 # define mch_msg(str)		printf("%s", (str))
diff -urN vim-src/src/vim16.def vim-qt-src/src/vim16.def
--- vim-src/src/vim16.def	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/vim16.def	2016-06-08 06:39:27.833316010 +0200
@@ -0,0 +1,5 @@
+CODE PRELOAD EXECUTEONLY
+DATA MULTIPLE SHARED
+DESCRIPTION 'Vim 7.4'
+STACKSIZE 16000
+HEAPSIZE 10000
diff -urN vim-src/src/vim16.rc vim-qt-src/src/vim16.rc
--- vim-src/src/vim16.rc	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/vim16.rc	2016-06-08 06:39:27.833316010 +0200
@@ -0,0 +1,81 @@
+// vim:ts=8:sw=4:sts=4:
+//
+// VIM - Vi IMproved	by Bram Moolenaar
+//
+// Do ":help uganda"  in Vim to read copying and usage conditions.
+// Do ":help credits" in Vim to see a list of people who contributed.
+
+// vim.rc
+//   Icon and version information for the Win32 version of Vim
+//   Must be in DOS format <CR><NL>!
+
+#include "version.h"
+#include "gui_w3~1.h"
+#include "guiw16rc.h"
+
+//
+// Icons
+//
+IDR_VIM ICON "VIM.ICO"
+
+#ifndef FEAT_TINY
+IDR_VIM_ERROR	ICON "VIM_ER~1.ICO"
+IDR_VIM_ALERT	ICON "VIM_AL~1.ICO"
+IDR_VIM_INFO	ICON "VIM_INFO.ICO"
+IDR_VIM_QUESTION ICON "VIM_QU~1.ICO"
+#endif
+
+//
+// Bitmaps
+//
+#ifdef FEAT_TOOLBAR
+IDR_TOOLBAR1	BITMAP  DISCARDABLE  "tools16.bmp"
+#endif
+//
+// Version
+//
+
+VS_VERSION_INFO		VERSIONINFO
+  FILEVERSION		VIM_VERSION_MAJOR,VIM_VERSION_MINOR,VIM_VERSION_BUILD,VIM_VERSION_PATCHLEVEL
+  PRODUCTVERSION	VIM_VERSION_MAJOR,VIM_VERSION_MINOR,VIM_VERSION_BUILD,VIM_VERSION_PATCHLEVEL
+  FILEFLAGSMASK		VS_FFI_FILEFLAGSMASK
+
+#if VIM_VERSION_PATCHLEVEL > 0
+ #ifdef _DEBUG
+  FILEFLAGS		VS_FF_PRERELEASE | VS_FF_DEBUG | VS_FF_PATCHED
+ #else
+  FILEFLAGS		VS_FF_PRERELEASE | VS_FF_PATCHED
+ #endif
+#else
+ #ifdef _DEBUG
+  FILEFLAGS		VS_FF_PRERELEASE | VS_FF_DEBUG
+ #else
+  FILEFLAGS		VS_FF_PRERELEASE
+ #endif
+#endif
+
+  FILEOS		VOS__WINDOWS32
+  FILETYPE		VFT_APP
+  FILESUBTYPE		0x0L
+BEGIN
+  BLOCK "StringFileInfo"
+  BEGIN
+    // 0x0409 == U.S. English; 0x04E4 => Windows Multilingual
+    BLOCK "040904E4"
+    BEGIN
+	VALUE "CompanyName",		"Vim Developers\0"
+	VALUE "FileDescription",	"Vi Improved - A Text Editor\0"
+	VALUE "FileVersion",		VIM_VERSION_MAJOR_STR ", " VIM_VERSION_MINOR_STR ", " VIM_VERSION_BUILD_STR ", " VIM_VERSION_PATCHLEVEL_STR  "\0"
+	VALUE "InternalName",		"VIM\0"
+	VALUE "LegalCopyright",		"Copyright \251 1996\0"
+	VALUE "LegalTrademarks",	"Vim\0"
+	VALUE "OriginalFilename",	"VIM.EXE\0"
+	VALUE "ProductName",		"Vim\0"
+	VALUE "ProductVersion",		VIM_VERSION_MAJOR_STR ", " VIM_VERSION_MINOR_STR ", " VIM_VERSION_BUILD_STR ", " VIM_VERSION_PATCHLEVEL_STR "\0"
+    END
+  END
+  BLOCK "VarFileInfo"
+  BEGIN
+	VALUE "Translation", 0x409, 0x4E4
+  END
+END
Binary files vim-src/src/vimtbar.dll and vim-qt-src/src/vimtbar.dll differ
diff -urN vim-src/src/vimtbar.h vim-qt-src/src/vimtbar.h
--- vim-src/src/vimtbar.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/vimtbar.h	2016-06-08 06:39:27.833316010 +0200
@@ -0,0 +1,185 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *			Win16 Toolbar by Vince Negri - External Header
+ *			(Based on MS Sample Code)
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+//
+// Button Structure
+//
+typedef struct tagTBBUTTON
+{
+    int  iBitmap;	 // index into bitmap of this button's picture
+    int  idCommand;	 // WM_COMMAND menu ID that this button sends
+    BYTE fsState;	 // button's state
+    BYTE fsStyle;	 // button's style
+} TBBUTTON;
+
+typedef TBBUTTON NEAR* PTBBUTTON;
+typedef TBBUTTON FAR* LPTBBUTTON;
+typedef const TBBUTTON FAR* LPCTBBUTTON;
+
+
+//
+// Styles
+//
+#define TBSTYLE_BUTTON		0x00	// this entry is button
+#define TBSTYLE_SEP		0x01	// this entry is a separator
+#define TBSTYLE_CHECK		0x02	// this is a check button (it stays down)
+#define TBSTYLE_GROUP		0x04	// this is a check button (it stays down)
+#define TBSTYLE_CHECKGROUP	(TBSTYLE_GROUP | TBSTYLE_CHECK) // this group is a member of a group radio group
+
+//
+// States
+//
+#define TBSTATE_CHECKED		0x01	// radio button is checked
+#define TBSTATE_PRESSED		0x02	// button is being depressed (any style)
+#define TBSTATE_ENABLED		0x04	// button is enabled
+#define TBSTATE_HIDDEN		0x08	// button is hidden
+#define TBSTATE_INDETERMINATE   0x10    // button is indeterminate
+#define TBSTATE_SELECTED	0x20	// mouse hovering over button (for coolbar look)
+
+
+
+typedef struct tagADJUSTINFO
+{
+    TBBUTTON tbButton;
+    char szDescription[1];
+} ADJUSTINFO;
+
+typedef ADJUSTINFO NEAR* PADJUSTINFO;
+typedef ADJUSTINFO FAR* LPADJUSTINFO;
+
+
+HWND WINAPI CreateToolbar(HWND hwnd, DWORD ws, WORD wID, int nBitmaps,
+	HINSTANCE hBMInst, WORD wBMID,
+	LPCTBBUTTON lpButtons, int iNumButtons);
+
+#define CMB_DISCARDABLE 0x01    // create bitmap as discardable
+#define CMB_MASKED      0x02    // create image/mask pair in bitmap
+
+
+#define TB_ENABLEBUTTON	(WM_USER + 1)
+// wParam: UINT, button ID
+// lParam: BOOL LOWORD, enable if nonzero; HIWORD not used, 0
+// return: not used
+//
+
+#define TB_CHECKBUTTON	(WM_USER + 2)
+// wParam: UINT, button ID
+// lParam: BOOL LOWORD, check if nonzero; HIWORD not used, 0
+// return: not used
+//
+
+#define TB_PRESSBUTTON	(WM_USER + 3)
+// wParam: UINT, button ID
+// lParam: BOOL LOWORD, press if nonzero; HIWORD not used, 0
+// return: not used
+//
+
+#define TB_HIDEBUTTON	(WM_USER + 4)
+// wParam: UINT, button ID
+// lParam: BOOL LOWORD, hide if nonzero; HIWORD not used, 0
+// return: not used
+//
+#define TB_INDETERMINATE	(WM_USER + 5)
+// wParam: UINT, button ID
+// lParam: BOOL LOWORD, make indeterminate if nonzero; HIWORD not used, 0
+// return: not used
+//
+
+#define TB_ISBUTTONENABLED	(WM_USER + 9)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: BOOL LOWORD, enabled if nonzero; HIWORD not used
+//
+
+#define TB_ISBUTTONCHECKED	(WM_USER + 10)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: BOOL LOWORD, checked if nonzero; HIWORD not used
+//
+
+#define TB_ISBUTTONPRESSED	(WM_USER + 11)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: BOOL LOWORD, pressed if nonzero; HIWORD not used
+//
+
+#define TB_ISBUTTONHIDDEN	(WM_USER + 12)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: BOOL LOWORD, hidden if nonzero; HIWORD not used
+//
+
+#define TB_ISBUTTONINDETERMINATE	(WM_USER + 13)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: BOOL LOWORD, indeterminate if nonzero; HIWORD not used
+//
+
+#define TB_SETSTATE		(WM_USER + 17)
+// wParam: UINT, button ID
+// lParam: UINT LOWORD, state bits; HIWORD not used, 0
+// return: not used
+//
+
+#define TB_GETSTATE		(WM_USER + 18)
+// wParam: UINT, button ID
+// lParam: not used, 0
+// return: UINT LOWORD, state bits; HIWORD not used
+//
+
+#define TB_ADDBITMAP		(WM_USER + 19)
+// wParam: UINT, number of button graphics in bitmap
+// lParam: one of:
+//	   HINSTANCE LOWORD, module handle; UINT HIWORD, resource id
+//	   HINSTANCE LOWORD, NULL; HBITMAP HIWORD, bitmap handle
+// return: one of:
+//	   int LOWORD, index for first new button; HIWORD not used
+//	   int LOWORD, -1 indicating error; HIWORD not used
+//
+
+#define TB_ADDBUTTONS		(WM_USER + 20)
+// wParam: UINT, number of buttons to add
+// lParam: LPTBBUTTON, pointer to array of TBBUTTON structures
+// return: not used
+//
+
+#define TB_INSERTBUTTON		(WM_USER + 21)
+// wParam: UINT, index for insertion (appended if index doesn't exist)
+// lParam: LPTBBUTTON, pointer to one TBBUTTON structure
+// return: not used
+//
+
+#define TB_DELETEBUTTON		(WM_USER + 22)
+// wParam: UINT, index of button to delete
+// lParam: not used, 0
+// return: not used
+//
+
+#define TB_GETBUTTON		(WM_USER + 23)
+// wParam: UINT, index of button to get
+// lParam: LPTBBUTTON, pointer to TBBUTTON buffer to receive button
+// return: not used
+//
+
+#define TB_BUTTONCOUNT		(WM_USER + 24)
+// wParam: not used, 0
+// lParam: not used, 0
+// return: UINT LOWORD, number of buttons; HIWORD not used
+//
+
+#define TB_COMMANDTOINDEX	(WM_USER + 25)
+// wParam: UINT, command id
+// lParam: not used, 0
+// return: UINT LOWORD, index of button (-1 if command not found);
+//	   HIWORD not used
+//
+
+
+#define TBN_BEGINDRAG	0x0201
+#define TBN_ENDDRAG	0x0203
Binary files vim-src/src/vimtbar.lib and vim-qt-src/src/vimtbar.lib differ
diff -urN vim-src/src/winclip.c vim-qt-src/src/winclip.c
--- vim-src/src/winclip.c	2016-03-27 19:08:37.255723010 +0200
+++ vim-qt-src/src/winclip.c	2016-06-08 06:40:09.681637746 +0200
@@ -181,7 +181,7 @@
 
 #endif /* FEAT_MBYTE */
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
 /*
  * Clipboard stuff, for cutting and pasting text to other windows.
  */
@@ -634,7 +634,7 @@
 	GlobalFree(hMemVim);
 }
 
-#endif /* FEAT_CLIPBOARD */
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 
 #if defined(FEAT_MBYTE) || defined(PROTO)
 /*
diff -urN vim-src/src/xxd/Make_bc3.mak vim-qt-src/src/xxd/Make_bc3.mak
--- vim-src/src/xxd/Make_bc3.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/xxd/Make_bc3.mak	2016-06-08 06:39:27.838316048 +0200
@@ -0,0 +1,31 @@
+# Simple makefile for Borland C++ 4.0
+# 3.1 can NOT be used, it has problems with the fileno() define.
+
+# Command line variables:
+# BOR		path to root of Borland C (E:\BORLANDC)
+# DEBUG		set to "yes" for debugging (no)
+
+!ifndef BOR
+BOR	= e:\bc4
+!endif
+
+!if ("$(DEBUG)" == "yes")
+DEBUG_FLAG = -v -DDEBUG
+!else
+DEBUG_FLAG =
+!endif
+
+CC	= $(BOR)\bin\bcc
+INC	= -I$(BOR)\include
+LIB	= -L$(BOR)\lib
+
+# The following compile options can be changed for better machines.
+#	replace -1- with -2 to produce code for a 80286 or higher
+#	replace -1- with -3 to produce code for a 80386 or higher
+#	add -v for source debugging
+OPTIMIZE= -1- -Ox
+
+CFLAGS	= -A -mc -DMSDOS $(DEBUG_FLAG) $(OPTIMIZE) $(INC) $(LIB)
+
+xxd.exe: xxd.c
+	$(CC) $(CFLAGS) xxd.c
diff -urN vim-src/src/xxd/Make_cyg.mak vim-qt-src/src/xxd/Make_cyg.mak
--- vim-src/src/xxd/Make_cyg.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/xxd/Make_cyg.mak	2016-06-08 06:39:27.838316048 +0200
@@ -0,0 +1,28 @@
+# The most simplistic Makefile, for Cygnus gcc on MS-DOS
+
+ifndef USEDLL
+USEDLL = no
+endif
+
+ifeq (yes, $(USEDLL))
+DEFINES =
+LIBS    = -lc
+else
+DEFINES =
+LIBS    =
+endif
+
+CC = gcc
+CFLAGS = -O2 -Wall -DWIN32 $(DEFINES)
+
+ifneq (sh.exe, $(SHELL))
+DEL = rm
+else
+DEL = del
+endif
+
+xxd.exe: xxd.c
+	$(CC) $(CFLAGS) -s -o xxd.exe xxd.c $(LIBS)
+
+clean:
+	-$(DEL) xxd.exe
diff -urN vim-src/src/xxd/Make_djg.mak vim-qt-src/src/xxd/Make_djg.mak
--- vim-src/src/xxd/Make_djg.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/xxd/Make_djg.mak	2016-06-08 06:39:27.838316048 +0200
@@ -0,0 +1,9 @@
+# The most simplistic Makefile, for DJGPP on MS-DOS
+
+CFLAGS = -O2 -Wall
+
+xxd.exe: xxd.c
+	gcc $(CFLAGS) -s -o xxd.exe xxd.c -lpc
+
+clean:
+	del xxd.exe
Binary files vim-src/src.info and vim-qt-src/src.info differ
Binary files vim-src/vimdir.info and vim-qt-src/vimdir.info differ
