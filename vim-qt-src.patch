diff -urN vim-src/README.md vim-qt-src/README.md
--- vim-src/README.md	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README.md	2012-08-23 19:26:45.000000000 +0200
@@ -0,0 +1,51 @@
+This is README for the Qt GUI - if you want the VIM README check README.txt
+
+# Compiling VIM with the Qt gui
+
+## Building on Linux/BSD systems
+
+For the most part you can build it as you would build vim with support for another gui, just issue the following commands:
+
+    $ ./configure --enable-gui=qt
+    $ make  
+
+All the regular configure options apply. Just don’t forget, you need libqt and libqt4-devel now. Usually you'll want to pass in something like:
+
+    ./configure --prefix=/usr/ --with-features=huge --with-vim-name=qvim --enable-gui=qt
+
+If configure is unable to find Qt, try passing in the Qt base dir as follows:
+
+    ./configure <...> --with-qt-dir=/usr/lib/qt4
+
+The vim binary will be created under **src/vim**.
+
+
+## Building on Windows
+
+As of commit c0956732b437 we have some initial support to build vim-Qt in windows. You can build vim-Qt for windows provided that you have Qt, CMake and an adequate compiler(Mingw or Visual Studio).
+
+Naturally you need to have Qt installed. The best way to do this depends on your setup - check the Qt website for more details and keep in mind that you need to match your Qt library version with your compiler.
+
+
+### Visual Studio 2010
+
+From the VS console:
+
+    $ cmake -G NMake Makefiles PATH_TO_QTVIM\src
+    $ nmake
+
+This will generate a binary, qvim.exe. Keep the runtime folder in the same folder as qvim.exe, otherwise vim will not have access to menus and configuration files.
+
+
+### MinGW
+
+Make sure all mingw tools are in your path (i.e. gcc, mingw32-make), and then from your console:
+
+    $ cmake -G MinGW Makefiles PATH_TO_QTVIM\src
+    $ mingw32-make
+
+
+
+
+
+
diff -urN vim-src/README_qt.txt vim-qt-src/README_qt.txt
--- vim-src/README_qt.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/README_qt.txt	2012-08-23 19:26:45.000000000 +0200
@@ -0,0 +1,51 @@
+This is README for the Qt GUI - if you want the VIM README check README.txt
+
+# Compiling VIM with the Qt gui
+
+## Building on Linux/BSD systems
+
+For the most part you can build it as you would build vim with support for another gui, just issue the following commands:
+
+    $ ./configure --enable-gui=qt
+    $ make  
+
+All the regular configure options apply. Just don’t forget, you need libqt and libqt4-devel now. Usually you'll want to pass in something like:
+
+    ./configure --prefix=/usr/ --with-features=huge --with-vim-name=qvim --enable-gui=qt
+
+If configure is unable to find Qt, try passing in the Qt base dir as follows:
+
+    ./configure <...> --with-qt-dir=/usr/lib/qt4
+
+The vim binary will be created under **src/vim**.
+
+
+## Building on Windows
+
+As of commit c0956732b437 we have some initial support to build vim-Qt in windows. You can build vim-Qt for windows provided that you have Qt, CMake and an adequate compiler(Mingw or Visual Studio).
+
+Naturally you need to have Qt installed. The best way to do this depends on your setup - check the Qt website for more details and keep in mind that you need to match your Qt library version with your compiler.
+
+
+### Visual Studio 2010
+
+From the VS console:
+
+    $ cmake -G NMake Makefiles PATH_TO_QTVIM\src
+    $ nmake
+
+This will generate a binary, qvim.exe. Keep the runtime folder in the same folder as qvim.exe, otherwise vim will not have access to menus and configuration files.
+
+
+### MinGW
+
+Make sure all mingw tools are in your path (i.e. gcc, mingw32-make), and then from your console:
+
+    $ cmake -G MinGW Makefiles PATH_TO_QTVIM\src
+    $ mingw32-make
+
+
+
+
+
+
diff -urN vim-src/runtime/menu.vim vim-qt-src/runtime/menu.vim
--- vim-src/runtime/menu.vim	2014-09-24 20:45:28.491428402 +0200
+++ vim-qt-src/runtime/menu.vim	2014-09-24 20:43:01.206356526 +0200
@@ -383,7 +383,7 @@
   endif
   unlet s:n
 endif
-if has("win32") || has("win16") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac")
+if has("win32") || has("win16") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac") || has("gui_qt")
   an 20.470 &Edit.Select\ Fo&nt\.\.\.	:set guifont=*<CR>
 endif
 
diff -urN vim-src/src/CMakeLists.txt vim-qt-src/src/CMakeLists.txt
--- vim-src/src/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/CMakeLists.txt	2013-05-18 08:44:24.000000000 +0200
@@ -0,0 +1,123 @@
+cmake_minimum_required(VERSION 2.8)
+
+find_package(Qt4 REQUIRED)
+set( QT_USE_QTGUI TRUE )
+include(${QT_USE_FILE} )
+
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+include_directories(proto auto . qt)
+
+# pathdef
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/pathdef.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/auto/pathdef.c)
+
+#
+# Vim executable
+#
+
+set(VIM_SOURCES buffer.c 
+		blowfish.c 
+		charset.c 
+		diff.c 
+		digraph.c 
+		edit.c 
+		eval.c 
+		ex_cmds.c 
+		ex_cmds2.c 
+		ex_docmd.c 
+		ex_eval.c 
+		ex_getln.c 
+		fileio.c 
+		fold.c 
+		getchar.c 
+		hardcopy.c 
+		hashtab.c 
+		if_cscope.c 
+		if_xcmdsrv.c 
+		main.c 
+		mark.c 
+		memfile.c 
+		memline.c 
+		menu.c 
+		message.c 
+		misc1.c 
+		misc2.c 
+		move.c 
+		mbyte.c 
+		normal.c 
+		ops.c 
+		option.c 
+		popupmnu.c 
+		quickfix.c 
+		regexp.c 
+		screen.c 
+		search.c 
+		sha256.c 
+		spell.c 
+		syntax.c 
+		tag.c 
+		term.c 
+		ui.c 
+		undo.c 
+		window.c 
+		gui.c 
+		netbeans.c 
+		version.c 
+		auto/pathdef.c)
+
+set(GUI_SOURCES gui_qt.cpp )
+set(MOC_SOURCES qt/qvimshell.cpp 
+		qt/mainwindow.cpp 
+		qt/vimaction.cpp 
+		qt/tabbar.cpp 
+		qt/vimaction.cpp 
+		qt/vimscrollbar.cpp 
+		qt/vimwrapper.cpp 
+		qt/fontdialog.cpp
+		qt/colortable.cpp
+		qt/vimevents.cpp
+		qt/scrollarea.cpp)
+
+set(QVIM_RCS qt/icons.qrc)
+QT4_ADD_RESOURCES( QVIM_RC_SRCS ${QVIM_RCS} )
+
+qt4_automoc(${MOC_SOURCES})
+
+
+if(MSVC OR MINGW)
+
+	set(VIM_SOURCES ${VIM_SOURCES} 
+			os_win32.c 
+			winclip.c
+			os_mswin.c)
+
+	add_definitions(-DWIN32
+			-DNO_X11_INCLUDES
+			-DFEAT_GUI_QT
+			-UHAVE_X11
+			-DFEAT_HUGE
+			-DFEAT_MBYTE
+			-UFEAT_SIGN
+			-D__func__=__FUNCTION__
+			-D_CRT_SECURE_NO_WARNINGS)
+
+	if (MSVC)
+		add_definitions(-wd4099)
+	endif (MSVC)
+
+	set(SOURCES ${VIM_SOURCES} ${GUI_SOURCES} ${MOC_SOURCES} ${QVIM_RC_SRCS})
+
+	if ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+		message("Building Debug version")
+		add_executable(qvim ${SOURCES})
+	else ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+		add_executable(qvim WIN32 ${SOURCES})
+	endif ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+
+	target_link_libraries(qvim ${QT_QTMAIN_LIBRARY} # Link to qtmain.lib to avoid WinMain()
+				   ${QT_LIBRARIES} )	# Link to Qt
+else(MSVC OR MINGW)
+	message(FATAL_ERROR "Could not find Visual Studio or Mingw - are they on the path? This is Windows, right?")
+endif(MSVC OR MINGW)
+
+
diff -urN vim-src/src/Makefile vim-qt-src/src/Makefile
--- vim-src/src/Makefile	2014-09-24 20:45:28.870425902 +0200
+++ vim-qt-src/src/Makefile	2014-09-24 20:43:01.794353003 +0200
@@ -1250,6 +1250,39 @@
 NEXTAW_TESTTARGET = gui
 NEXTAW_BUNDLE	=
 
+### Qt
+# We use the following to build
+# - QT_MOC
+# - QT_LIBS
+# - QT_INCPATH
+MOC		= $(QT_MOC)
+QT_LIBS1	= $(QT_LIBS)
+QT_SRC	= gui.c gui_qt.cpp pty.c gui_beval.c \
+			qt/qvimshell.cpp qt/mainwindow.cpp qt/vimaction.cpp qt/scrollarea.cpp \
+			qt/fontdialog.cpp \
+			qt/colortable.cpp \
+			qt/vimwrapper.cpp qt/tabbar.cpp qt/vimscrollbar.cpp \
+			qt/vimevents.cpp
+QT_OBJ	= objects/gui.o objects/gui_qt.o \
+			objects/pty.o objects/gui_beval.o \
+			objects/mainwindow.o objects/qvimshell.o objects/vimaction.o objects/qtresources.o \
+			objects/colortable.o \
+			objects/scrollarea.o objects/fontdialog.o objects/vimwrapper.o \
+			objects/vimevents.o \
+			objects/tabbar.o objects/vimscrollbar.o
+
+QT_DEFS	= -DFEAT_GUI_QT $(NARROW_PROTO) -Iqt -I. $(QT_INCPATH)
+QT_IPATH	= $(GUI_INC_LOC)
+QT_LIBS_DIR = $(GUI_LIB_LOC)
+
+QT_INSTALL  = install_normal install_gui_extra
+
+# Qt needs to be linked using the c++ compiler
+ifdef QT_LIBS
+	CClink=$(CXX)
+endif
+
+
 ### (J)  Sun OpenWindows 3.2 (SunOS 4.1.x) or earlier that produce these ld
 #	 errors:  ld: Undefined symbol
 #		      _get_wmShellWidgetClass
@@ -1294,7 +1327,7 @@
 CARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)
 
 # All GUI files
-ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c pty.c
+ALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c pty.c gui_qt_cpp qt/qvimshell.cpp qt/mainwindow.cpp qt/vimgui.cpp qt/fontdialog.cpp qt/colortable.cpp
 ALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w16.pro gui_w32.pro gui_photon.pro
 
 # }}}
@@ -1342,7 +1375,7 @@
 PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
 POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(TCL_CFLAGS) $(EXTRA_DEFS)
 
-ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
+ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS) ${QT_CFLAGS}
 
 # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
 # with "-E".
@@ -1493,7 +1526,7 @@
 	$(WORKSHOP_SRC) \
 	$(WSDEBUG_SRC)
 
-TAGS_SRC = *.c *.cpp if_perl.xs
+TAGS_SRC = *.c *.cpp if_perl.xs qt/*.cpp
 
 EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
 	    if_python.c if_python3.c if_tcl.c if_ruby.c if_sniff.c \
@@ -2579,6 +2612,56 @@
 objects/gui_athena.o: gui_athena.c
 	$(CCC) -o $@ gui_athena.c
 
+## Qt objects
+objects/gui_qt.o: gui_qt.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c gui_qt.cpp
+
+objects/mainwindow.o: qt/mainwindow.cpp
+	$(MOC) qt/mainwindow.h > mainwindow.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/mainwindow.cpp
+
+objects/qvimshell.o: qt/qvimshell.cpp
+	$(MOC) qt/qvimshell.h > qvimshell.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/qvimshell.cpp
+
+objects/colortable.o: qt/colortable.cpp
+	$(MOC) qt/colortable.h > colortable.moc
+	$(CXX) $(ALL_CFLAGS) -O0 -o $@ -c qt/colortable.cpp # -O0 is needed here
+
+objects/vimaction.o: qt/vimaction.cpp
+	$(MOC) qt/vimaction.h > vimaction.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimaction.cpp
+
+objects/qtresources.o: qt/icons.qrc
+	$(QT_RCC) -no-compress qt/icons.qrc -o qtresources.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qtresources.cpp
+
+objects/vimscrollbar.o: qt/vimscrollbar.cpp
+	$(MOC) qt/vimscrollbar.h > vimscrollbar.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimscrollbar.cpp
+
+objects/scrollarea.o: qt/scrollarea.cpp
+	$(MOC) qt/scrollarea.h > scrollarea.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/scrollarea.cpp
+
+objects/vimgui.o: qt/vimgui.cpp
+	$(MOC) qt/vimgui.h > vimgui.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimgui.cpp
+
+objects/fontdialog.o: qt/fontdialog.cpp
+	$(MOC) qt/fontdialog.h > fontdialog.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/fontdialog.cpp
+
+objects/vimwrapper.o: qt/vimwrapper.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimwrapper.cpp
+
+objects/vimevents.o: qt/vimevents.cpp
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/vimevents.cpp
+
+objects/tabbar.o: qt/tabbar.cpp
+	$(MOC) qt/tabbar.h > tabbar.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/tabbar.cpp
+
 objects/gui_beval.o: gui_beval.c
 	$(CCC) -o $@ gui_beval.c
 
diff -urN vim-src/src/Toolchain-mingw32.cmake vim-qt-src/src/Toolchain-mingw32.cmake
--- vim-src/src/Toolchain-mingw32.cmake	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/Toolchain-mingw32.cmake	2012-06-20 16:40:37.000000000 +0200
@@ -0,0 +1,18 @@
+
+SET(CMAKE_SYSTEM_NAME Windows)
+
+# specify the cross compiler
+SET(CMAKE_C_COMPILER   i686-w64-mingw32-gcc)
+SET(CMAKE_CXX_COMPILER i686-w64-mingw32-g++)
+SET(CMAKE_RC_COMPILER i686-w64-mingw32-windres)
+
+SET(CMAKE_FIND_ROOT_PATH /usr/i686-w64-mingw32/sys-root/mingw)
+
+SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+
+SET(QT_QMAKE_EXECUTABLE /usr/i686-w64-mingw32/bin/qmake CACHE INTERNAL "" FORCE)
+SET(QT_MOC_EXECUTABLE /usr/i686-w64-mingw32/bin/moc CACHE INTERNAL "" FORCE)
+SET(QT_RCC_EXECUTABLE /usr/i686-w64-mingw32/bin/rcc CACHE INTERNAL "" FORCE)
+SET(QT_UIC_EXECUTABLE /usr/i686-w64-mingw32/bin/uic CACHE INTERNAL "" FORCE)
diff -urN vim-src/src/config.mk.in vim-qt-src/src/config.mk.in
--- vim-src/src/config.mk.in	2014-09-24 20:45:28.978425189 +0200
+++ vim-qt-src/src/config.mk.in	2014-09-24 20:43:01.798352979 +0200
@@ -157,6 +157,12 @@
 GUI_X_LIBS	= @GUI_X_LIBS@
 MOTIF_LIBNAME	= @MOTIF_LIBNAME@
 GTK_LIBNAME	= @GTK_LIBNAME@
+QT_MOC		= @QT_MOC@
+QT_RCC		= @QT_RCC@
+QT_LIBS		= @QT_LIBS@
+QT_INCPATH	= @QT_INCPATH@
+QT_CXXFLAGS	= @QT_CXXFLAGS@
+QT_CFLAGS	= @QT_CFLAGS@
 
 ### Any OS dependent extra source and object file
 OS_EXTRA_SRC	= @OS_EXTRA_SRC@
diff -urN vim-src/src/configure vim-qt-src/src/configure
--- vim-src/src/configure	2014-09-24 20:45:56.927239256 +0200
+++ vim-qt-src/src/configure	2014-09-24 20:46:00.808213205 +0200
@@ -634,6 +634,17 @@
 GUITYPE
 GUI_LIB_LOC
 GUI_INC_LOC
+QT_CFLAGS
+QT_CXXFLAGS
+QT_INCPATH
+QT_RCC
+QT_MOC
+QT_LIBS
+MAKE_P
+QMAKE
+ac_ct_CXX
+CXXFLAGS
+CXX
 NARROW_PROTO
 MOTIF_LIBNAME
 GNOME_INCLUDEDIR
@@ -824,6 +835,7 @@
 with_gnome_libs
 with_gnome
 with_motif_lib
+with_qt_qmake
 with_tlib
 enable_largefile
 enable_acl
@@ -840,7 +852,10 @@
 LIBS
 CPPFLAGS
 CPP
-XMKMF'
+XMKMF
+CXX
+CXXFLAGS
+CCC'
 
 
 # Initialize some variables set by options.
@@ -1474,7 +1489,7 @@
   --enable-hangulinput    Include Hangul input support.
   --enable-xim            Include XIM input support.
   --enable-fontset        Include X fontset output support.
-  --enable-gui=OPTS     X11 GUI default=auto OPTS=auto/no/gtk2/gnome2/motif/athena/neXtaw/photon/carbon
+  --enable-gui=OPTS     X11 GUI default=auto OPTS=auto/no/gtk2/gnome2/motif/athena/neXtaw/photon/carbon/qt
   --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 default=yes
   --enable-gnome-check    If GTK GUI, check for GNOME default=no
   --enable-motif-check    If auto-select GUI, check for Motif default=yes
@@ -1514,6 +1529,7 @@
   --with-gnome-libs=DIR   Specify location of GNOME libs
   --with-gnome            Specify prefix for GNOME files
   --with-motif-lib=STRING   Library for Motif
+  --with-qt-qmake=PATH   QMake location (ex: /usr/lib/qt4/bin/qmake)
   --with-tlib=library     terminal library to be used
 
 Some influential environment variables:
@@ -1526,6 +1542,8 @@
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
   XMKMF       Path to xmkmf, Makefile generator for X Window System
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -1955,6 +1973,44 @@
 
 } # ac_fn_c_check_func
 
+# ac_fn_cxx_try_compile LINENO
+# ----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_cxx_try_compile
+
 # ac_fn_c_check_type LINENO TYPE VAR INCLUDES
 # -------------------------------------------
 # Tests whether TYPE exists after having included INCLUDES, setting cache
@@ -8360,7 +8416,7 @@
   fi
 fi
 
-test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" -a "x$enable_gui" != "xqt" && enable_gui=no
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-gui argument" >&5
 $as_echo_n "checking --enable-gui argument... " >&6; }
@@ -8382,6 +8438,7 @@
 SKIP_NEXTAW=YES
 SKIP_PHOTON=YES
 SKIP_CARBON=YES
+SKIP_QT=YES
 GUITYPE=NONE
 
 if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
@@ -8431,7 +8488,8 @@
 		SKIP_MOTIF=
 		SKIP_ATHENA=
 		SKIP_NEXTAW=
-		SKIP_CARBON=;;
+		SKIP_CARBON=
+		SKIP_QT=;;
     gtk2)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: GTK+ 2.x GUI support" >&5
 $as_echo "GTK+ 2.x GUI support" >&6; }
 		SKIP_GTK2=;;
@@ -8448,6 +8506,9 @@
     nextaw)	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: neXtaw GUI support" >&5
 $as_echo "neXtaw GUI support" >&6; }
 		SKIP_NEXTAW=;;
+    qt)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Qt GUI support" >&5
+$as_echo "Qt GUI support" >&6; }
+    		SKIP_QT=;;
     *)		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Sorry, $enable_gui GUI is not supported" >&5
 $as_echo "Sorry, $enable_gui GUI is not supported" >&6; } ;;
   esac
@@ -8558,7 +8619,6 @@
   fi
 fi
 
-
 if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Carbon GUI" >&5
 $as_echo_n "checking for Carbon GUI... " >&6; }
@@ -8587,7 +8647,8 @@
   SKIP_ATHENA=YES;
   SKIP_NEXTAW=YES;
   SKIP_PHOTON=YES;
-  SKIP_CARBON=YES
+  SKIP_CARBON=YES;
+  SKIP_QT=YES;
 fi
 
 
@@ -8779,6 +8840,7 @@
       SKIP_ATHENA=YES
       SKIP_NEXTAW=YES
       SKIP_MOTIF=YES
+      SKIP_QT=YES
       GUITYPE=GTK
 
     fi
@@ -8968,6 +9030,7 @@
 if test -z "$SKIP_MOTIF"; then
   SKIP_ATHENA=YES
   SKIP_NEXTAW=YES
+  SKIP_QT=YES
   GUITYPE=MOTIF
 
 fi
@@ -9300,6 +9363,715 @@
 fi
 
 
+if test -z "$SKIP_QT" -a -z "$DONT_FIND_QT"; then
+    ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+    ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CXX+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CXX+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if ${ac_cv_cxx_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if ${ac_cv_prog_cxx_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
+else
+  CXXFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+else
+  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+    QT_FOUND="no"
+    QT_MIN_VERSION="4.7.0"
+
+    # Disable xim - Qt will decide on this
+    enable_xim="no"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-qt-qmake argument" >&5
+$as_echo_n "checking --with-qt-qmake argument... " >&6; }
+
+# Check whether --with-qt-qmake was given.
+if test "${with_qt_qmake+set}" = set; then :
+  withval=$with_qt_qmake;  QMAKE="${withval}"
+fi
+
+
+    if test -n "$QMAKE"; then
+
+    	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $QMAKE" >&5
+$as_echo_n "checking for $QMAKE... " >&6; }
+	if test ! -x "$QMAKE"; then
+            as_fn_error $? "\"Unable to find the given qmake $QMAKE\"" "$LINENO" 5
+	fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+        #
+        # Find qmake
+        # 1. First look for "qmake4" in the PATH - some systems use the name qmake(Qt3) and qmake4(Qt4)
+        # 2. If qmake4 is not found then look for qmake-qt4 in the PATH
+	# 3. Look for qmake in the PATH
+        # 4. Look for "qmake", outside the path, in the following locations
+        QT_BIN_PATH="/usr/lib64/qt4/bin:/usr/local/lib64/qt4/bin:/usr/lib/qt4/bin:/usr/local/lib/qt4/bin"
+
+        # Extract the first word of "qmake4", so it can be a program name with args.
+set dummy qmake4; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake-qt4", so it can be a program name with args.
+set dummy qmake-qt4; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake", so it can be a program name with args.
+set dummy qmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            # Extract the first word of "qmake", so it can be a program name with args.
+set dummy qmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_QMAKE+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $QMAKE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_QMAKE="$QMAKE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $QT_BIN_PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_QMAKE="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+QMAKE=$ac_cv_path_QMAKE
+if test -n "$QMAKE"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QMAKE" >&5
+$as_echo "$QMAKE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+        fi
+
+        if test -z "$QMAKE"; then
+            as_fn_error $? "\"Unable to find qmake\"" "$LINENO" 5
+        fi
+
+    fi
+
+    #
+    # Check Qt version >= 4.7.0
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking Qt version" >&5
+$as_echo_n "checking Qt version... " >&6; }
+    QT_VERSION=`$QMAKE -query QT_VERSION | cut -f1`
+    if test  "$QT_VERSION" \< "$QT_MIN_VERSION" ; then
+       as_fn_error $? "\"Qt version is too old - need at least $QT_MIN_VERSION\"" "$LINENO" 5
+    fi
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $QT_VERSION" >&5
+$as_echo "$QT_VERSION" >&6; }
+
+    QT_INSTALL_BINS=`$QMAKE -query QT_INSTALL_BINS | cut -f1`
+    QT_MOC="$QT_INSTALL_BINS/moc"
+    if test ! -x "$QT_MOC"; then
+    	as_fn_error $? "\"Unable to find the given Qt moc $QT_MOC\"" "$LINENO" 5
+    fi
+    QT_RCC="$QT_INSTALL_BINS/rcc"
+    if test ! -x "$QT_RCC"; then
+    	as_fn_error $? "\"Unable to find the given Qt rcc $QT_RCC\"" "$LINENO" 5
+    fi
+
+    #
+    # Call qmake to generate bogus project
+    #
+    # What we do here is call qmake to generate a valid Makefile and
+    # then extract the Qt compiler flags from the generated Makefile
+    #
+    TMPDIR=/tmp
+    tmp=`(umask 077 && mktemp -d -q "$TMPDIR/test-vim-qt-XXXXXXXX") 2>/dev/null`;
+    if test -z "$tmp" -a -d "$tmp"; then
+	as_fn_error $? "Unable to create temporary directory" "$LINENO" 5
+    fi
+
+cat > $tmp/qttest.cpp << EOF
+#include <QApplication>
+int main(int ac, char **av) {
+    QApplication app(ac, av);
+    return app.exec();
+}
+EOF
+
+    # Extract the first word of "gmake", so it can be a program name with args.
+set dummy gmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_MAKE_P+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAKE_P in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MAKE_P="$MAKE_P" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_MAKE_P="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+MAKE_P=$ac_cv_path_MAKE_P
+if test -n "$MAKE_P"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAKE_P" >&5
+$as_echo "$MAKE_P" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    if test -z "$MAKE_P"; then
+    	MAKE_P="make"
+
+    else
+        # Extract the first word of "gmake", so it can be a program name with args.
+set dummy gmake; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_MAKE_P+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAKE_P in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MAKE_P="$MAKE_P" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_MAKE_P="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+MAKE_P=$ac_cv_path_MAKE_P
+if test -n "$MAKE_P"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAKE_P" >&5
+$as_echo "$MAKE_P" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    fi
+    echo "$MAKE_P"
+
+    # Generate qmake project
+    qmake_try=`cd $tmp; $QMAKE -project -o test.pro`
+    { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$qt_try\""; } >&5
+  (eval $qt_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+    if test x"$ac_status" != x0; then
+        as_fn_error $? "qmake failed" "$LINENO" 5
+    fi
+
+    # Qt Modules
+    echo "QT += network" >> $tmp/test.pro
+    if test ! "5.0.0" \> "$QT_VERSION" ; then
+    	# Qt5 needs QtWidgets
+	echo "QT += widgets" >> $tmp/test.pro
+    fi
+
+
+    # generate Makefile
+    qmake_try=`cd $tmp; $QMAKE`
+    { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$qt_try\""; } >&5
+  (eval $qt_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+    if test x"$ac_status" != x0; then
+        as_fn_error $? "qmake failed" "$LINENO" 5
+    fi
+
+    #
+    # A dummy Makefile to help extract the
+    # real parameters
+    #
+cat > $tmp/makefile.dummy << EOF
+def: info
+include $tmp/Makefile
+info:
+	@echo "CXXFLAGS = \$(CXXFLAGS)"
+	@echo "CFLAGS = \$(CFLAGS)"
+	@echo "LFLAGS = \$(LFLAGS)"
+	@echo "LIBS = \$(LIBS)"
+	@echo "INCPATH = \$(INCPATH)"
+EOF
+
+    # LIBS
+    QT_LIBS=`$MAKE_P -f $tmp/makefile.dummy |grep LIBS.*= | awk '{sub(/^LIBS +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        as_fn_error $? "Unable to find Qt libraries" "$LINENO" 5
+    fi
+
+    # Include directives
+    QT_INCPATH=`$MAKE_P -f $tmp/makefile.dummy |grep INCPATH.*= | awk '{sub(/^INCPATH +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        as_fn_error $? "Unable to find Qt include path" "$LINENO" 5
+    fi
+
+    # LFLAGS
+    QT_LFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep LFLAGS.*= | awk '{sub(/^LFLAGS +=/, ""); print}'`
+    if test -z "$QT_LFLAGS"; then
+        as_fn_error $? "Unable to find Qt link flags" "$LINENO" 5
+    fi
+
+    # Qt CXXFLAGS
+    QT_CXXFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CXXFLAGS.*= | awk '{sub(/^CXXFLAGS +=/, ""); print}'`
+    QT_CXXFLAGS=`echo "$QT_CXXFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_LFLAGS"; then
+        as_fn_error $? "Unable to find Qt C flags" "$LINENO" 5
+    fi
+
+    # Qt CFLAGS
+    QT_CFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CFLAGS.*= | awk '{sub(/^CFLAGS +=/, ""); print}'`
+    QT_CFLAGS=`echo "$QT_CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_CFLAGS"; then
+        as_fn_error $? "Unable to find Qt C++ flags" "$LINENO" 5
+    fi
+
+    LDFLAGS="$LDFLAGS $QT_LFLAGS -lstdc++"
+
+
+
+
+
+
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+    # Remove temp directory
+    rm $tmp/Makefile
+    rm $tmp/qttest.cpp
+    rm $tmp/test.pro
+    rm $tmp/makefile.dummy
+    rmdir $tmp
+fi
+
+if test -z "$SKIP_QT"; then
+  GUITYPE=QT
+  GUI_X_LIBS=
+fi
+
 if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2"; then
     cppflags_save=$CPPFLAGS
   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
diff -urN vim-src/src/configure.in vim-qt-src/src/configure.in
--- vim-src/src/configure.in	2014-09-24 20:45:28.980425176 +0200
+++ vim-qt-src/src/configure.in	2014-09-24 20:43:01.801352961 +0200
@@ -2054,11 +2054,11 @@
   fi
 fi
 
-test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" -a "x$enable_gui" != "xqt" && enable_gui=no
 
 AC_MSG_CHECKING(--enable-gui argument)
 AC_ARG_ENABLE(gui,
- [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+ [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/motif/athena/neXtaw/photon/carbon/qt]], , enable_gui="auto")
 
 dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
 dnl Do not use character classes for portability with old tools.
@@ -2073,6 +2073,7 @@
 SKIP_NEXTAW=YES
 SKIP_PHOTON=YES
 SKIP_CARBON=YES
+SKIP_QT=YES
 GUITYPE=NONE
 
 if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
@@ -2110,7 +2111,8 @@
 		SKIP_MOTIF=
 		SKIP_ATHENA=
 		SKIP_NEXTAW=
-		SKIP_CARBON=;;
+		SKIP_CARBON=
+		SKIP_QT=;;
     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
 		SKIP_GTK2=;;
     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
@@ -2122,6 +2124,8 @@
 		SKIP_ATHENA=;;
     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
 		SKIP_NEXTAW=;;
+    qt)		AC_MSG_RESULT(Qt GUI support)
+    		SKIP_QT=;;
     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
   esac
 
@@ -2195,7 +2199,6 @@
   fi
 fi
 
-
 if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
   AC_MSG_CHECKING(for Carbon GUI)
   dnl already did the check, just give the message
@@ -2226,7 +2229,8 @@
   SKIP_ATHENA=YES;
   SKIP_NEXTAW=YES;
   SKIP_PHOTON=YES;
-  SKIP_CARBON=YES
+  SKIP_CARBON=YES;
+  SKIP_QT=YES;
 fi
 
 dnl define an autoconf function to check for a specified version of GTK, and
@@ -2436,6 +2440,7 @@
       SKIP_ATHENA=YES
       SKIP_NEXTAW=YES
       SKIP_MOTIF=YES
+      SKIP_QT=YES
       GUITYPE=GTK
       AC_SUBST(GTK_LIBNAME)
     fi
@@ -2548,6 +2553,7 @@
 if test -z "$SKIP_MOTIF"; then
   SKIP_ATHENA=YES
   SKIP_NEXTAW=YES
+  SKIP_QT=YES
   GUITYPE=MOTIF
   AC_SUBST(MOTIF_LIBNAME)
 fi
@@ -2649,6 +2655,199 @@
   CPPFLAGS=$cppflags_save
 fi
 
+dnl Check if the Qt files can be found
+
+if test -z "$SKIP_QT" -a -z "$DONT_FIND_QT"; then
+    AC_LANG_PUSH(C++)
+    AC_PROG_CXX
+    QT_FOUND="no"
+    QT_MIN_VERSION="4.7.0"
+
+    # Disable xim - Qt will decide on this
+    enable_xim="no"
+
+    AC_MSG_CHECKING(--with-qt-qmake argument)
+    AC_ARG_WITH(qt-qmake,
+    [  --with-qt-qmake=PATH   QMake location (ex: /usr/lib/qt4/bin/qmake)],
+    [ QMAKE="${withval}" ] )
+
+    if test -n "$QMAKE"; then
+
+    	AC_MSG_CHECKING(for $QMAKE)
+	if test ! -x "$QMAKE"; then
+            AC_MSG_ERROR("Unable to find the given qmake $QMAKE")
+	fi
+
+        AC_MSG_RESULT(yes)
+    else
+        AC_MSG_RESULT(no)
+
+        #
+        # Find qmake
+        # 1. First look for "qmake4" in the PATH - some systems use the name qmake(Qt3) and qmake4(Qt4) 
+        # 2. If qmake4 is not found then look for qmake-qt4 in the PATH
+	# 3. Look for qmake in the PATH
+        # 4. Look for "qmake", outside the path, in the following locations
+        QT_BIN_PATH="/usr/lib64/qt4/bin:/usr/local/lib64/qt4/bin:/usr/lib/qt4/bin:/usr/local/lib/qt4/bin"
+    
+        AC_PATH_PROG(QMAKE, qmake4)
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake-qt4)
+        fi
+ 
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake)
+        fi
+
+        if test -z "$QMAKE"; then
+            AC_PATH_PROG(QMAKE, qmake, , $QT_BIN_PATH)
+        fi
+    
+        if test -z "$QMAKE"; then
+            AC_MSG_ERROR("Unable to find qmake")
+        fi
+    
+    fi
+
+    #
+    # Check Qt version >= 4.7.0
+
+    AC_MSG_CHECKING(Qt version)
+    QT_VERSION=`$QMAKE -query QT_VERSION | cut -f1`
+    if test [ "$QT_VERSION" \< "$QT_MIN_VERSION" ]; then
+       AC_MSG_ERROR("Qt version is too old - need at least $QT_MIN_VERSION")
+    fi
+    AC_MSG_RESULT($QT_VERSION)
+
+    QT_INSTALL_BINS=`$QMAKE -query QT_INSTALL_BINS | cut -f1`
+    QT_MOC="$QT_INSTALL_BINS/moc"
+    if test ! -x "$QT_MOC"; then
+    	AC_MSG_ERROR("Unable to find the given Qt moc $QT_MOC")
+    fi
+    QT_RCC="$QT_INSTALL_BINS/rcc"
+    if test ! -x "$QT_RCC"; then
+    	AC_MSG_ERROR("Unable to find the given Qt rcc $QT_RCC")
+    fi
+
+    #
+    # Call qmake to generate bogus project
+    #
+    # What we do here is call qmake to generate a valid Makefile and
+    # then extract the Qt compiler flags from the generated Makefile
+    #
+    TMPDIR=/tmp
+    tmp=`(umask 077 && mktemp -d -q "$TMPDIR/test-vim-qt-XXXXXXXX") 2>/dev/null`;
+    if test -z "$tmp" -a -d "$tmp"; then
+	AC_MSG_ERROR(Unable to create temporary directory)
+    fi
+
+cat > $tmp/qttest.cpp << EOF
+#include <QApplication>
+int main(int ac, char **av) {
+    QApplication app(ac, av);
+    return app.exec();
+}
+EOF
+
+    AC_PATH_PROG(MAKE_P, gmake)
+    if test -z "$MAKE_P"; then
+    	MAKE_P="make"
+
+    else
+        AC_PATH_PROG(MAKE_P, gmake)
+    fi
+    echo "$MAKE_P"
+
+    # Generate qmake project
+    qmake_try=`cd $tmp; $QMAKE -project -o test.pro`
+    AC_TRY_EVAL(qt_try)
+    if test x"$ac_status" != x0; then
+        AC_MSG_ERROR(qmake failed)
+    fi
+
+    # Qt Modules
+    echo "QT += network" >> $tmp/test.pro
+    if test ![ "5.0.0" \> "$QT_VERSION" ]; then
+    	# Qt5 needs QtWidgets
+	echo "QT += widgets" >> $tmp/test.pro
+    fi
+
+
+    # generate Makefile
+    qmake_try=`cd $tmp; $QMAKE`
+    AC_TRY_EVAL(qt_try)
+    if test x"$ac_status" != x0; then
+        AC_MSG_ERROR(qmake failed)
+    fi
+
+    #
+    # A dummy Makefile to help extract the
+    # real parameters
+    #
+cat > $tmp/makefile.dummy << EOF
+def: info
+include $tmp/Makefile
+info:
+	@echo "CXXFLAGS = \$(CXXFLAGS)"
+	@echo "CFLAGS = \$(CFLAGS)"
+	@echo "LFLAGS = \$(LFLAGS)"
+	@echo "LIBS = \$(LIBS)"
+	@echo "INCPATH = \$(INCPATH)"
+EOF
+
+    # LIBS
+    QT_LIBS=`$MAKE_P -f $tmp/makefile.dummy |grep LIBS.*= | awk '{sub(/^LIBS +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        AC_MSG_ERROR(Unable to find Qt libraries)
+    fi
+
+    # Include directives
+    QT_INCPATH=`$MAKE_P -f $tmp/makefile.dummy |grep INCPATH.*= | awk '{sub(/^INCPATH +=/, ""); print}'`
+    if test -z "$QT_LIBS"; then
+        AC_MSG_ERROR(Unable to find Qt include path)
+    fi
+
+    # LFLAGS
+    QT_LFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep LFLAGS.*= | awk '{sub(/^LFLAGS +=/, ""); print}'`
+    if test -z "$QT_LFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt link flags)
+    fi
+
+    # Qt CXXFLAGS
+    QT_CXXFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CXXFLAGS.*= | awk '{sub(/^CXXFLAGS +=/, ""); print}'`
+    QT_CXXFLAGS=`echo "$QT_CXXFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_LFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt C flags)
+    fi
+
+    # Qt CFLAGS
+    QT_CFLAGS=`$MAKE_P -f $tmp/makefile.dummy |grep CFLAGS.*= | awk '{sub(/^CFLAGS +=/, ""); print}'`
+    QT_CFLAGS=`echo "$QT_CFLAGS" | sed -e 's/-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/-D_FORTIFY_SOURCE=.//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+    if test -z "$QT_CFLAGS"; then
+        AC_MSG_ERROR(Unable to find Qt C++ flags)
+    fi
+
+    LDFLAGS="$LDFLAGS $QT_LFLAGS -lstdc++"
+    AC_SUBST(QT_LIBS)
+    AC_SUBST(QT_MOC)
+    AC_SUBST(QT_RCC)
+    AC_SUBST(QT_INCPATH)
+    AC_SUBST(QT_CXXFLAGS)
+    AC_SUBST(QT_CFLAGS)
+    AC_LANG_POP(C++)
+
+    # Remove temp directory
+    rm $tmp/Makefile
+    rm $tmp/qttest.cpp
+    rm $tmp/test.pro
+    rm $tmp/makefile.dummy
+    rmdir $tmp
+fi
+
+if test -z "$SKIP_QT"; then
+  GUITYPE=QT
+  GUI_X_LIBS=
+fi
 
 if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2"; then
   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
diff -urN vim-src/src/eval.c vim-qt-src/src/eval.c
--- vim-src/src/eval.c	2014-09-24 20:45:29.317422951 +0200
+++ vim-qt-src/src/eval.c	2014-09-24 20:43:02.377349508 +0200
@@ -12539,6 +12539,9 @@
 #ifdef FEAT_GUI_W32
 	"gui_win32",
 #endif
+#ifdef FEAT_GUI_QT
+	"gui_qt",
+#endif
 #ifdef FEAT_HANGULIN
 	"hangul_input",
 #endif
diff -urN vim-src/src/ex_docmd.c vim-qt-src/src/ex_docmd.c
--- vim-src/src/ex_docmd.c	2014-09-24 20:45:29.334422839 +0200
+++ vim-qt-src/src/ex_docmd.c	2014-09-24 20:43:02.381349484 +0200
@@ -7084,6 +7084,7 @@
 	|| (defined(FEAT_GUI_GTK) && defined(FEAT_DND)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 
 /*
diff -urN vim-src/src/feature.h vim-qt-src/src/feature.h
--- vim-src/src/feature.h	2014-09-24 20:45:56.213244042 +0200
+++ vim-qt-src/src/feature.h	2014-09-24 20:46:00.134217733 +0200
@@ -40,6 +40,10 @@
  * When +small is used, +tiny is also included.  +normal implies +small, etc.
  */
 
+#ifdef FEAT_GUI_QT
+#include <qt_features.h>
+#endif
+
 /*
  * Uncomment one of these to override the default.  For unix use a configure
  * argument, see Makefile.
@@ -631,7 +635,7 @@
  * Disabled for EBCDIC:
  * Multibyte support doesn't work on z/OS Unix currently.
  */
-#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_ARABIC)) \
+#if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT) || defined(FEAT_ARABIC)) \
 	&& !defined(FEAT_MBYTE) && !defined(WIN16) \
 	&& VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)
 # define FEAT_MBYTE
@@ -811,7 +815,8 @@
 	|| defined(FEAT_GUI_GTK) \
 	|| defined(FEAT_GUI_PHOTON) \
 	|| defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_MAC)
+	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT)
 #  define FEAT_CON_DIALOG
 #  define FEAT_GUI_DIALOG
 # else
diff -urN vim-src/src/fileio.c vim-qt-src/src/fileio.c
--- vim-src/src/fileio.c	2014-09-24 20:45:29.344422773 +0200
+++ vim-qt-src/src/fileio.c	2014-09-24 20:43:02.384349466 +0200
@@ -6124,6 +6124,7 @@
 #if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 /*
  * Shorten all filenames in "fnames[count]" by current directory.
diff -urN vim-src/src/globals.h vim-qt-src/src/globals.h
--- vim-src/src/globals.h	2014-09-24 20:45:28.089431055 +0200
+++ vim-qt-src/src/globals.h	2014-09-24 20:43:02.386349454 +0200
@@ -513,7 +513,7 @@
 
 #ifdef FEAT_CLIPBOARD
 EXTERN VimClipboard clip_star;	/* PRIMARY selection in X11 */
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 EXTERN VimClipboard clip_plus;	/* CLIPBOARD selection in X11 */
 # else
 #  define clip_plus clip_star	/* there is only one clipboard */
@@ -1417,7 +1417,7 @@
 EXTERN char_u e_fontset[]	INIT(= N_("E234: Unknown fontset: %s"));
 #endif
 #if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(MACOS) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_QT)
 EXTERN char_u e_font[]		INIT(= N_("E235: Unknown font: %s"));
 #endif
 #if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)
diff -urN vim-src/src/gui.c vim-qt-src/src/gui.c
--- vim-src/src/gui.c	2014-09-24 20:45:28.092431035 +0200
+++ vim-qt-src/src/gui.c	2014-09-24 20:43:02.387349448 +0200
@@ -166,10 +166,10 @@
     termcapinit((char_u *)"builtin_gui");
     gui.starting = recursive - 1;
 
-#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_QT)
     if (gui.in_use)
     {
-# ifdef FEAT_EVAL
+# if defined(FEAT_EVAL) && !defined(FEAT_GUI_QT)
 	Window	x11_window;
 	Display	*x11_display;
 
@@ -800,7 +800,7 @@
 }
 
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(PROTO)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT) || defined(PROTO)
 # define NEED_GUI_UPDATE_SCREEN 1
 /*
  * Called when the GUI shell is closed by the user.  If there are no changed
@@ -1400,7 +1400,7 @@
     base_height = 2 * gui.border_offset;
     if (gui.which_scrollbars[SBAR_BOTTOM])
 	base_height += gui.scrollbar_height;
-#ifdef FEAT_GUI_GTK
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     /* We can't take the sizes properly into account until anything is
      * realized.  Therefore we recalculate all the values here just before
      * setting the size. (--mdcki) */
@@ -1561,7 +1561,7 @@
     if (!gui.shell_created)
 	return;
 
-#if defined(MSWIN) || defined(FEAT_GUI_GTK)
+#if (defined(MSWIN) || defined(FEAT_GUI_GTK)) && !defined(FEAT_GUI_QT)
     /* If not setting to a user specified size and maximized, calculate the
      * number of characters that fit in the maximized window. */
     if (!mustset && gui_mch_maximized())
@@ -2373,7 +2373,7 @@
     if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
 	return FAIL;
 
-#if defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     /* If there's no italic font, then fake it.
      * For GTK2, we don't need a different font for italic style. */
     if (hl_mask_todo & HL_ITALIC)
@@ -5392,6 +5392,7 @@
 #if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
 	|| defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MAC) \
+	|| defined(FEAT_GUI_QT) \
 	|| defined(PROTO)
 
 #ifdef FEAT_WINDOWS
diff -urN vim-src/src/gui.h vim-qt-src/src/gui.h
--- vim-src/src/gui.h	2013-10-09 22:09:06.000000000 +0200
+++ vim-qt-src/src/gui.h	2013-10-09 22:07:10.000000000 +0200
@@ -62,7 +62,7 @@
  * On some systems scrolling needs to be done right away instead of in the
  * main loop.
  */
-#if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 # define USE_ON_FLY_SCROLL
 #endif
 
@@ -138,7 +138,7 @@
 #define DRAW_BOLD		0x02	/* draw bold text */
 #define DRAW_UNDERL		0x04	/* draw underline text */
 #define DRAW_UNDERC		0x08	/* draw undercurl text */
-#if defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 # define DRAW_ITALIC		0x10	/* draw italic text */
 #endif
 #define DRAW_CURSOR		0x20	/* drawing block cursor (win32) */
@@ -169,6 +169,10 @@
 				   is no console input possible */
 #endif
 
+#ifdef FEAT_GUI_QT
+struct VimScrollBar;
+#endif
+
 typedef struct GuiScrollbar
 {
     long	ident;		/* Unique identifier for each scrollbar */
@@ -209,6 +213,9 @@
 #ifdef FEAT_GUI_PHOTON
     PtWidget_t	*id;
 #endif
+#ifdef FEAT_GUI_QT
+    struct VimScrollBar* wid;
+#endif
 } scrollbar_T;
 
 typedef long	    guicolor_T;	/* handle for a GUI color; for X11 this should
@@ -236,10 +243,19 @@
 #   define NOFONT	(GuiFont)0
 #   define NOFONTSET	(GuiFontset)0
 #  else
+
+#   ifdef FEAT_GUI_QT
+  struct QFont;
+  typedef struct QFont*	GuiFont;
+  typedef void*		GuiFontset;
+#  define NOFONT	(GuiFont)NULL
+#  define NOFONTSET	(GuiFontset)NULL
+#   else
   typedef long_u	GuiFont;	/* handle for a GUI font */
   typedef long_u	GuiFontset;	/* handle for a GUI fontset */
 #   define NOFONT	(GuiFont)0
 #   define NOFONTSET	(GuiFontset)0
+#   endif
 #  endif
 # endif
 #endif
@@ -303,6 +319,10 @@
 				     * The styled font variants are not used. */
 #endif
 
+#ifdef FEAT_GUI_QT
+    int		char_ul_pos;        /* underline position - distance from the baseline */
+#endif
+
 #if defined(FEAT_MENU) && !defined(FEAT_GUI_GTK)
 # ifdef FONTSET_ALWAYS
     GuiFontset	menu_fontset;	    /* set of fonts for multi-byte chars */
diff -urN vim-src/src/gui_qt.cpp vim-qt-src/src/gui_qt.cpp
--- vim-src/src/gui_qt.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/gui_qt.cpp	2014-01-11 00:34:30.624264228 +0100
@@ -0,0 +1,1748 @@
+#include <QApplication>
+#include <QMessageBox>
+#include <QDesktopWidget>
+#include <QSettings>
+#include <QFile>
+#include <QFileInfo>
+#include <QDir>
+#include <QClipboard>
+#include <QMenu>
+#include <QMenuBar>
+#include <QToolBar>
+#include <QFileDialog>
+#include <QPushButton>
+
+#include "qvimshell.h"
+#include "mainwindow.h"
+#include "vimaction.h"
+#include "vimscrollbar.h"
+#include "fontdialog.h"
+
+extern "C" {
+
+#include "vim.h"
+#include "globals.h"
+
+static QVimShell *vimshell = NULL;
+static MainWindow *window = NULL;
+
+static QColor foregroundColor;
+static QColor backgroundColor;
+static QColor specialColor;
+
+
+/*
+ * We delay Qt initialization and pass
+ * QApplication a pair of fake arguments
+ */
+static int dummy_argc = 1;
+static char *dummy_argv[] = {"qvim", NULL};
+
+/**
+ * If vim calls for a fullscreen window
+ * before the window is created we have to
+ * store this state.
+ *
+ * This is checked in gui_mch_init when creaating the GUI
+ */
+static bool start_fullscreen = false;
+
+void gui_mch_enter_fullscreen()
+{
+	if (!window) {
+		start_fullscreen = true;
+		return;
+	}
+
+	window->setWindowState( window->windowState() | Qt::WindowFullScreen );
+}
+
+void gui_mch_leave_fullscreen()
+{
+	if (!window) {
+		return;
+	}
+
+	window->setWindowState( window->windowState() & ~Qt::WindowFullScreen );
+}
+
+void gui_mch_update_fuoptions(char_u *optstr)
+{
+	//
+	// FIXME: We don't support fuopts at this point
+	// set fuoptions=maxvert,maxhoriz
+
+}
+
+/**
+ * Raise application window
+ */
+void
+gui_mch_set_foreground()
+{
+	window->activateWindow();
+	window->raise();
+}
+
+/**
+ * Get the font with the given name
+ *
+ */
+GuiFont
+gui_mch_get_font(char_u *name, int giveErrorIfMissing)
+{
+	QString family = VimWrapper::convertFrom(name);
+	QFont font;
+	font.setStyleHint(QFont::TypeWriter);
+	font.setStyleStrategy(QFont::StyleStrategy(QFont::PreferDefault | QFont::ForceIntegerMetrics) );
+
+	if ( name == NULL ) { // Fallback font
+		font.setFamily("Monospace");
+		font.setFixedPitch(true);
+		font.setPointSize(10);
+		font.setKerning(false);
+		return new QFont(font);
+	}
+
+	bool ok;
+	int size = family.section(' ', -1).trimmed().toInt(&ok);
+	if ( ok ) {
+		QString realname = family.section(' ', 0, -2).trimmed();
+		font.setFamily(realname);
+		font.setPointSize(size);
+	} else if ( !font.fromString(family) ) {
+		font.setRawName(family);
+	}
+
+	font.setBold(false);
+	font.setItalic(false);
+	font.setKerning(false);
+
+	//
+	// When you ask for a font you may get a different font. This happens
+	// when the font system does some form of substitution (such as as virtual fonts).
+	// This bit of code checks if the font that is requested is the font that is returned.
+	//
+	// In a nutshell this is what is done:
+	// - If the font exists and has fixed width, load it
+	// - If the font does not exist or is not monospace, don't load the font
+	// + If giveErrorIfMissing is true, throw an error message, otherwise fail silently
+	// * We open an exception for the Monospace font, we ALWAYS load the monospace font
+	//
+	QFontInfo fi(font);
+
+	if ( fi.family().compare(font.family(), Qt::CaseInsensitive) != 0 && 
+		font.family().compare("Monospace", Qt::CaseInsensitive) != 0) {
+
+		if ( giveErrorIfMissing ) {
+			EMSG2(e_font, name);
+		}
+		return NOFONT;
+	}
+
+	if ( !fi.fixedPitch() ) {
+		if ( giveErrorIfMissing ) {
+			EMSG2(e_font, name);
+		}
+		return NOFONT;
+	}
+
+	return new QFont(font);
+}
+
+/**
+ * Get the name of the given font
+ */
+char_u *
+gui_mch_get_fontname(GuiFont font, char_u  *name)
+{
+	if (font == NULL || name == NULL) {
+		return NULL;
+	}
+
+	char_u *s = vim_strsave( name );
+	return s;
+}
+
+/**
+ * Free font object
+ */
+void
+gui_mch_free_font(GuiFont font)
+{
+	delete font;
+}
+
+/**
+ * Trigger the visual bell
+ */
+void
+gui_mch_flash(int msec)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QApplication::alert(window, msec);
+}
+
+/*
+ * GUI input routine called by gui_wait_for_chars().  Waits for a character
+ * from the keyboard.
+ *  wtime == -1	    Wait forever.
+ *  wtime == 0	    This should never happen.
+ *  wtime > 0	    Wait wtime milliseconds for a character.
+ * Returns OK if a character was found to be available within the given time,
+ * or FAIL otherwise.
+ */
+int
+gui_mch_wait_for_chars(long wtime)
+{
+	if (!vim_is_input_buf_empty()) {
+		return OK;
+	}
+
+	return vimshell->processEvents(wtime, true);
+}
+
+/**
+ * Catch up with any queued X events.  This may put keyboard input into the
+ * input buffer, call resize call-backs, trigger timers etc.  If there is
+ * nothing in the X event queue (& no timers pending), then we return
+ * immediately.
+ */
+void
+gui_mch_update()
+{
+	vimshell->processEvents();
+}
+
+
+/** 
+ * Flush any output to the screen 
+ */
+void
+gui_mch_flush()
+{
+	vimshell->processEvents(0, true);
+}
+
+/**
+ * Set the foreground color
+ */
+void
+gui_mch_set_fg_color(guicolor_T	color)
+{
+	if ( color != INVALCOLOR ) {
+		foregroundColor = VimWrapper::fromColor(color);
+	}
+}
+
+/**
+ * Set the current text background color.
+ */
+void
+gui_mch_set_bg_color(guicolor_T color)
+{
+	// The shell needs a hint background color
+	// to paint the back when resizing
+	if ( color != INVALCOLOR ) {
+		backgroundColor = VimWrapper::fromColor(color);
+	}
+}
+
+
+/**
+ * Start the cursor blinking.  If it was already blinking, this restarts the
+ * waiting time and shows the cursor.
+ *
+ */
+void
+gui_mch_start_blink()
+{
+	vimshell->startBlinking();
+}
+
+/**
+ * Start the cursor blinking.
+ *
+ */
+void
+gui_mch_stop_blink()
+{
+	vimshell->stopBlinking();
+	gui_update_cursor(TRUE, FALSE);
+}
+
+/**
+ * Sound the bell
+ */
+void
+gui_mch_beep() 
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QApplication::beep();
+}
+
+/**
+ * Clear the entire shell, i.e. paint it with the
+ * background color
+ */
+void
+gui_mch_clear_all()
+{
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::CLEARALL;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Update Vim metrics
+ */
+static void
+update_char_metrics(const QFontMetrics& metric)
+{
+	gui.char_width = metric.width("M");
+
+	// The actual linespace plus Vim's fake linespace
+	gui.char_height = metric.lineSpacing() + p_linespace;
+	if ( metric.underlinePos() >= metric.descent() ) {
+		gui.char_height += metric.underlinePos() - metric.descent() + metric.lineWidth();
+	}
+
+	gui.char_ascent = metric.ascent() + p_linespace/2 + metric.leading();
+	gui.char_ul_pos = metric.underlinePos();
+}
+
+/**
+ * Initialise vim to use the font "font_name".  If it's NULL, pick a default
+ * font.
+ * If "fontset" is TRUE, load the "font_name" as a fontset.
+ * Return FAIL if the font could not be loaded, OK otherwise.
+ */
+int
+gui_mch_init_font(char_u *font_name, int do_fontset)
+{
+	QFont *qf = gui_mch_get_font(font_name, FALSE);
+	if ( qf == NULL ) {
+		return FAIL;
+	}
+
+	QFontMetrics metric( *qf );
+
+	if ( VimWrapper::isFakeMonospace(*qf) || getenv("QVIM_DRAW_STRING_SLOW") ) {
+		vimshell->setSlowStringDrawing( true );
+	} else {
+		vimshell->setSlowStringDrawing( false );
+	}
+
+	gui.norm_font = qf;
+	update_char_metrics(metric);
+	vimshell->setCharWidth(gui.char_width);
+
+	return OK;
+}
+
+/**
+ * Get current mouse coordinates in text window.
+ */
+void
+gui_mch_getmouse(int *x, int *y)
+{
+	QPoint pos = vimshell->mapFromGlobal( QCursor::pos() );
+	*x = pos.x();
+	*y = pos.y();
+}
+
+/**
+ * Move the mouse pointer to the given position
+ */
+void
+gui_mch_setmouse(int x, int y)
+{
+	QPoint pos = vimshell->mapToGlobal(QPoint(x, y));
+	QCursor::setPos(pos.x(), pos.y());
+}
+
+/* Table for shape IDs.  Keep in sync with the mshape_names[] table in
+ * misc2.c! */
+static Qt::CursorShape mshape_ids[] =
+{
+    Qt::ArrowCursor,
+    Qt::BlankCursor,
+    Qt::IBeamCursor,
+    Qt::SizeVerCursor,
+    Qt::SizeFDiagCursor,
+    Qt::SizeHorCursor,
+    Qt::SizeFDiagCursor,
+    Qt::BusyCursor,
+    Qt::ForbiddenCursor,
+    Qt::CrossCursor,
+    Qt::OpenHandCursor,
+    Qt::ClosedHandCursor,
+    Qt::ArrowCursor,
+    Qt::WhatsThisCursor,
+    Qt::ArrowCursor,
+    Qt::UpArrowCursor
+};
+
+/**
+ * Set mouse pointer shape
+ */
+void
+mch_set_mouse_shape(int shape)
+{
+	vimshell->setCursor(QCursor(mshape_ids[shape]));
+}
+
+/**
+ * Return the RGB value of a pixel as a long.
+ */
+long_u
+gui_mch_get_rgb(guicolor_T pixel)
+{
+	return (long_u)pixel;
+}
+
+/**
+ * Clear the block with the given coordinates
+ */
+void
+gui_mch_clear_block(int row1, int col1, int row2, int col2)
+{
+	QRect rect = VimWrapper::mapBlock(row1, col1, row2, col2); 
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	op.rect = rect;
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Clear the shell margin
+ *
+ * The shell is a grid whose size is a multiple of its column/row size.
+ * Sometimes an extra margin is in place, this paints that margin.
+ */
+static void
+clear_shell_border()
+{
+	QPoint tl, br;
+
+	tl.setX(0);
+	tl.setY( vimshell->height() - (vimshell->height() % gui.char_height ));
+	
+	br.setX(vimshell->width());
+	br.setY(vimshell->height());
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	op.rect = QRect(tl, br);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Insert the given number of lines before the given row, scrolling down any
+ * following text within the scroll region.
+ */
+void
+gui_mch_insert_lines(int row, int num_lines)
+{
+	QRect scrollRect = VimWrapper::mapBlock(row, gui.scroll_region_left, 
+					gui.scroll_region_bot, gui.scroll_region_right);
+
+	QVimShell::PaintOperation op1;
+	op1.type = QVimShell::SCROLLRECT;
+	op1.rect = scrollRect;
+	op1.pos = QPoint(0, num_lines*gui.char_height);
+	op1.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op1);
+
+	clear_shell_border();
+}
+
+/*
+ * Delete the given number of lines from the given row, scrolling up any
+ * text further down within the scroll region.
+ */
+void
+gui_mch_delete_lines(int row, int num_lines)
+{
+	// This used to be Bottom+1 and right+1
+	QRect scrollRect = VimWrapper::mapBlock(row, gui.scroll_region_left, 
+					gui.scroll_region_bot, gui.scroll_region_right);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::SCROLLRECT;
+	op.rect = scrollRect;
+	op.pos = QPoint(0, -num_lines*gui.char_height);
+	op.color = VimWrapper::fromColor(gui.back_pixel);
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Get the size of the screen where the application window is placed
+ */
+void
+gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
+{
+	QDesktopWidget *dw = QApplication::desktop();
+
+	QRect geo = dw->screenGeometry(window);
+	*screen_w = geo.width();
+	*screen_h = geo.height();
+}
+
+/**
+ * Initialize vim
+ *
+ * - Set default colors
+ * - Create window and shell
+ * - Read settings
+ */
+int
+gui_mch_init()
+{
+
+#ifdef Q_WS_X11
+	bool useGUI = getenv("DISPLAY") != 0;
+#else
+	bool useGUI = true;
+#endif
+	QApplication *app = new QApplication(dummy_argc, dummy_argv, useGUI);
+
+
+	window = new MainWindow(&gui);
+
+	// Load qVim settings
+	QSettings settings("Vim", "qVim");
+	settings.beginGroup("mainwindow");
+	window->restoreState( settings.value("state").toByteArray() );
+	settings.endGroup();
+
+	vimshell = window->vimShell();
+
+	// Load qVim style
+	QSettings ini(QSettings::IniFormat, QSettings::UserScope, "Vim", "qVim");
+	QFile styleFile( QFileInfo(ini.fileName()).absoluteDir().absoluteFilePath("qVim.style") );
+
+	if ( styleFile.open(QIODevice::ReadOnly) ) {
+		window->setStyleSheet( styleFile.readAll() );
+		styleFile.close();
+	}
+
+	//
+	// Hide the tab/menu/tool-bars, if needed they will become visible later.
+	// Otherwise the use might see these items when Vim is loading
+	//
+	window->showMenu(false);
+	window->showToolbar(false);
+	window->showTabline(false);
+
+	// Clipboard - order matters, for safety
+	clip_star.clipboardMode = QClipboard::Selection;
+	clip_plus.clipboardMode = QClipboard::Clipboard;
+
+	display_errors();
+
+	/* Colors */
+	gui.norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.back_pixel = VimWrapper::toColor(QColor(Qt::white));
+
+	set_normal_colors();
+	gui_check_colors();
+	highlight_gui_started();
+
+	gui.def_norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.def_back_pixel = VimWrapper::toColor(QColor(Qt::white));
+
+	// The Scrollbar manages the scrollbars
+	gui.scrollbar_width = 0;
+	gui.scrollbar_height = 0;
+
+	// Background color hint
+	vimshell->setBackground(VimWrapper::backgroundColor() );
+
+	if ( start_fullscreen ) {
+		gui_mch_enter_fullscreen();
+	}
+
+	return OK;
+}
+
+/**
+ * Set blinking time duration 
+ *
+ */
+void
+gui_mch_set_blinking(long waittime, long on, long off)
+{
+	vimshell->setBlinkTime(waittime, on, off);
+}
+
+/**
+ * Initialise Qt, pass in command line arguments
+ */
+void
+gui_mch_prepare(int *argc, char **argv)
+{
+#ifdef Q_WS_X11
+	QColor::setAllowX11ColorNames(true);
+#endif
+}
+
+/**
+ * Resize the shell
+ */
+void
+gui_mch_set_shellsize(int width, int height, int min_width, int min_height,
+		    int base_width, int base_height, int direction)
+{
+	// We actually resize the window, not the shell, i.e. we resize the window
+	// to the new dimensions plus the difference between the window and the shell.
+	// This does not ensure the final size is what Vim requested.
+	//
+	// The actual resize size must take into consideration
+	// - The new shell widget size
+	// - The toolbar/menubar/etc size
+	//
+	// New size <= shell size - window size + new size
+	//
+
+	QDesktopWidget *dw = QApplication::desktop();
+	QSize desktopSize = dw->availableGeometry(window).size();
+
+	if ( !window->isVisible() ) {
+		// We can't resize properly if the window is not
+		// visible just resize the window to the intended size
+		if ( width > desktopSize.width() ) {
+			width = desktopSize.width();
+		}
+		if ( height > desktopSize.height() ) {
+			height = desktopSize.height();
+		}
+
+		window->resize(width, height);
+		return;
+	}
+
+	int decoWidth = (window->frameGeometry().width() - window->width());
+	int decoHeight = (window->frameGeometry().height() - window->height());
+	int frameWidth = (window->size().width() - vimshell->size().width());
+	int frameHeight = (window->size().height() - vimshell->size().height());
+
+	int new_width = frameWidth + width;
+	int new_height = frameHeight + height;
+
+	// If the given dimenstions are too large,
+	// cap them at available desktop dimensions minus the window decorations
+	if ( new_width + decoWidth > desktopSize.width() ) {
+		new_width = desktopSize.width() - decoWidth;
+	}
+	if ( new_height + decoWidth > desktopSize.height() ) {
+		new_height = desktopSize.height() - decoHeight;
+	}
+
+	if (window->windowState() & Qt::WindowFullScreen ) {
+		// In fullscreen mode, resize the widget
+		vimshell->setMaximumSize(width, height);
+	} else if ( window->isMaximized() ) {
+		// Nothing to do here - the windows is maximized
+	} else {
+		window->resize( new_width, new_height );
+	}
+
+	//
+	// Spin the loop to handle the resize event. This will
+	// cause gui_resize_shell() to be called
+	gui_mch_update();
+
+	// Seems redundant but there are cases were the shell might not
+	// call this - because its size is unchanged
+	gui_resize_shell(vimshell->width(), vimshell->height());
+
+	// SHOCKING: it seems gui_get_shellsize() updates the proper values for
+	// the columns and rows, after a resize.
+	gui_get_shellsize();
+}
+
+/**
+ * Called when the foreground or background color has been changed.
+ */
+void
+gui_mch_new_colors()
+{
+	vimshell->setBackground(VimWrapper::backgroundColor() );
+}
+
+/**
+ * Move the application window
+ */
+void
+gui_mch_set_winpos(int x, int y)
+{
+	window->move(x, y);
+}
+
+/**
+ * Set the window title and icon.
+ *
+ * FIXME: We don't use the icon argument
+ */
+void
+gui_mch_settitle(char_u *title, char_u *icon)
+{
+	if ( title != NULL ) {
+		window->setWindowTitle( VimWrapper::convertFrom(title) );
+	}
+}
+
+/**
+ * Show/Hide the mouse pointer
+ */
+void
+gui_mch_mousehide(int hide)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	if ( hide ) {
+		QApplication::setOverrideCursor(Qt::BlankCursor);
+	} else {
+		QApplication::restoreOverrideCursor();
+	}
+}
+
+/**
+ * Adjust gui.char_height (after 'linespace' was changed).
+ */
+int
+gui_mch_adjust_charheight()
+{
+	QFontMetrics metric( *gui.norm_font );
+	update_char_metrics(metric);
+	return OK;
+}
+
+/**
+ * Return OK if the key with the termcap name "name" is supported.
+ */
+int
+gui_mch_haskey(char_u *name)
+{
+	int i;
+	qDebug() << __func__;
+
+	for (i = 0; special_keys[i].code1 != NUL; i++) {
+		if (name[0] == special_keys[i].code0 &&
+					 name[1] == special_keys[i].code1) {
+			return OK;
+		}
+	}
+	return FAIL;
+}
+
+/**
+ * Iconify application window
+ */
+void
+gui_mch_iconify()
+{
+	window->showMinimized();
+}
+
+
+/**
+ * Invert a rectangle from row r, column c, for nr rows and nc columns.
+ */
+void
+gui_mch_invert_rectangle(int row, int col, int nr, int nc)
+{
+	QRect rect = VimWrapper::mapBlock(row, col, row+nr-1, col +nc-1);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::INVERTRECT;
+	op.rect = rect;
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Set the current text font.
+ */
+void
+gui_mch_set_font(GuiFont font)
+{
+	if (font == NULL) {
+		return;
+	}
+	vimshell->setFont(*font);
+}
+
+
+/**
+ * Close the application
+ */
+void
+gui_mch_exit(int rc)
+{
+	if ( !QApplication::instance() )
+		return;
+
+	QSettings settings("Vim", "qVim");
+	settings.beginGroup("mainwindow");
+	settings.setValue("state", window->saveState());
+	settings.endGroup();
+
+	QApplication::quit();
+}
+
+/**
+ * Check if the GUI can be started..
+ * Return OK or FAIL.
+ */
+int
+gui_mch_init_check()
+{
+#ifdef Q_WS_X11
+	return (getenv("DISPLAY") != 0);
+#else
+	return OK;
+#endif
+}
+
+/* Clipboard */
+
+/**
+ * Own the selection and return OK if it worked.
+ * 
+ */
+int
+clip_mch_own_selection(VimClipboard *cbd)
+{
+	return OK;
+}
+
+/**
+ * Disown the selection.
+ */
+void
+clip_mch_lose_selection(VimClipboard *cbd)
+{
+}
+
+/**
+ * Send the current selection to the clipboard
+ */
+void
+clip_mch_set_selection(VimClipboard *cbd)
+{
+	int type;
+	long size;
+	char_u *str = NULL;
+
+	if (!cbd->owned) {
+		return;
+	}
+
+	cbd->owned = TRUE;
+	clip_get_selection(cbd);
+	cbd->owned = FALSE;
+
+	type = clip_convert_selection(&str, (long_u *)&size, cbd);
+	if (type >= 0) {
+		QClipboard *clip = QApplication::clipboard();
+		clip->setText( VimWrapper::convertFrom(str, size), (QClipboard::Mode)cbd->clipboardMode);
+	}
+
+	vim_free(str);
+}
+
+/**
+ * Get selection from clipboard
+ *
+ */
+void
+clip_mch_request_selection(VimClipboard *cbd)
+{
+	QClipboard *clip = QApplication::clipboard();
+	if ( clip->text((QClipboard::Mode)cbd->clipboardMode).size() == 0 ) {
+		return;
+	}
+
+	QByteArray text = VimWrapper::convertTo(clip->text( (QClipboard::Mode)cbd->clipboardMode));
+
+	if ( text.isEmpty() ) {
+		// This should not happen, but if it does vim
+		// behaves badly so lets be extra carefull
+		return;
+	}
+
+	char_u	*buffer;
+	buffer = lalloc( text.size(), TRUE);
+	if (buffer == NULL)
+		return;
+
+	for (int i = 0; i < text.size(); ++i) {
+		buffer[i] = text[i];
+	}
+
+	clip_yank_selection(MAUTO, buffer, text.size(), cbd);
+	vim_free(buffer);
+}
+
+/**
+ * Open the GUI window which was created by a call to gui_mch_init().
+ */
+int
+gui_mch_open()
+{
+	if ( window == NULL ) {
+		return FAIL;
+	}
+
+	window->show();
+    	if (gui_win_x != -1 && gui_win_y != -1) {
+		gui_mch_set_winpos(gui_win_x, gui_win_y);
+	}
+
+	return OK;
+}
+
+/**
+ * Draw a cursor without focus.
+ */
+void
+gui_mch_draw_hollow_cursor(guicolor_T color)
+{
+	int w = gui.char_width;
+	int h = gui.char_height;
+
+	QPoint tl = QPoint(FILL_X(gui.col), 
+			FILL_Y(gui.row) + gui.char_height-h );
+	QPoint br = QPoint(FILL_X(gui.col)+w-2, 
+			FILL_Y(gui.row)+gui.char_height-2);
+	QRect rect(tl, br);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWRECT;
+	op.rect = rect;
+	op.color = VimWrapper::fromColor(color);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Draw part of a cursor, only w pixels wide, and h pixels high.
+ */
+void
+gui_mch_draw_part_cursor(int w, int h, guicolor_T color)
+{
+	int x, y;
+
+#ifdef FEAT_RIGHTLEFT
+	if ( CURSOR_BAR_RIGHT ) {
+		x = (gui.col+1)*gui.char_width- w;
+	} else
+#endif
+	{
+		x = gui.col*gui.char_width;
+	}
+	y = gui.row*gui.char_height + gui.char_height - h;
+
+	QRect rect( x, y, w, h);
+
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::FILLRECT;
+	op.rect = rect;
+	op.color = VimWrapper::fromColor(color);
+	vimshell->queuePaintOp(op);
+}
+
+/**
+ * Set the current text special color.
+ */
+void
+gui_mch_set_sp_color(guicolor_T color) 
+{
+	if ( color != INVALCOLOR ) {
+		specialColor = VimWrapper::fromColor(color);
+	}
+}
+
+/**
+ * Draw a string in the shell
+ */
+void
+gui_mch_draw_string(
+    int		row,
+    int		col,
+    char_u	*s,
+    int		len,
+    int		flags)
+{
+	QString str = VimWrapper::convertFrom(s, len);
+	
+	// Font
+	QFont f = vimshell->font();
+	f.setBold( flags & DRAW_BOLD);
+	f.setUnderline( flags & DRAW_UNDERL);
+	f.setItalic( flags & DRAW_ITALIC);
+
+	QFontMetrics fm(f);
+
+	int cellwidth = VimWrapper::stringCellWidth(str);
+	QPoint pos = VimWrapper::mapText(row, col);
+	QRect rect( pos.x(), pos.y(), gui.char_width*cellwidth, gui.char_height);
+
+	if (flags & DRAW_TRANSP) {
+		// Do we need to do anything?
+	} else {
+		// Fill in the background
+		QVimShell::PaintOperation op;
+		op.type = QVimShell::FILLRECT;
+		op.rect = rect;
+		op.color = backgroundColor;
+		vimshell->queuePaintOp(op);
+	}
+
+	// Remove upper linespace from rect
+	QRect rect_text( pos.x(), pos.y() + p_linespace/2, gui.char_width*cellwidth, gui.char_height);
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWSTRING;
+	op.font = f;
+	op.rect = rect_text;
+	op.str = str;
+	op.color = foregroundColor;
+	op.undercurl = flags & DRAW_UNDERC;
+	if ( op.undercurl ) { // FIXME: Refactor QVimShell::PaintOperation
+		op.curlcolor = specialColor;
+	}
+
+	// op.pos is the text baseline
+	op.pos = rect.topLeft();
+	op.pos.setY( op.pos.y() + gui.char_ascent );
+
+	vimshell->queuePaintOp(op);
+}
+
+
+/**
+ * Return the Pixel value (color) for the given color name.
+ * Return INVALCOLOR for error.
+ */
+guicolor_T
+gui_mch_get_color(char_u *reqname)
+{
+	if ( reqname == NULL ) {
+		return INVALCOLOR;
+	}
+	QColor c = vimshell->color(VimWrapper::convertFrom(reqname));
+	if ( c.isValid() ) {
+		return VimWrapper::toColor(c);
+	}
+
+	return INVALCOLOR;
+}
+
+/**
+ * Get the position of the top left corner of the window.
+ */
+int
+gui_mch_get_winpos(int *x, int *y)
+{
+	QPoint pos = window->pos();
+
+	*x = pos.x();
+	*y = pos.y();
+
+	return OK;
+}
+
+void
+gui_mch_set_text_area_pos(int x, int y, int w, int h)
+{
+	/* Do we need to do anything here? */
+}
+
+void
+gui_mch_new_tooltip_font()
+{
+	qDebug() << __func__;
+
+}
+
+void
+gui_mch_new_tooltip_colors()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Show/Hide toolbar
+ */
+void
+gui_mch_show_toolbar(int showit)
+{
+	if ( showit ) {
+		window->showToolbar(true);
+	} else {
+		window->showToolbar(false);
+	}
+}
+
+int
+gui_mch_compute_toolbar_height()
+{
+	/* Do nothing - the main window handles this */
+	return 0;
+}
+
+void
+gui_mch_set_toolbar_pos(int x, int y, int w, int h)
+{
+	/* Do nothing - the main window handles this */
+}
+
+//
+// MENU
+//
+///////////////////
+
+/**
+ * Disable/Enable tearoff for all menus - I'm kind of shocked there is no trivial way to do this
+ *
+ * Given a widget, recursively find all submenus an set tearoff
+ *
+ */
+static void
+toggle_tearoffs(QWidget *widget, bool enable)
+{
+	foreach (QAction *action, widget->actions()) {
+		if ( action->menu() ) {
+			action->menu()->setTearOffEnabled(enable);
+			toggle_tearoffs(action->menu(), enable);
+		}
+	}
+}
+
+/**
+ * Enable/Disable tearoff for all menus
+ */
+void
+gui_mch_toggle_tearoffs(int enable)
+{
+	QMenuBar *mb = window->menuBar();
+	toggle_tearoffs(mb, enable != 0);
+}
+
+/**
+ * Called after all menus are set,
+ */
+void
+gui_mch_draw_menubar()
+{
+}
+
+/**
+ * Disable a menu entry
+ */
+void
+gui_mch_menu_grey(vimmenu_T *menu, int grey)
+{
+	if ( menu == NULL || menu->qaction == NULL )  {
+		return;
+	}
+	menu->qaction->setEnabled( (grey == 0) );
+}
+
+void
+gui_mch_new_menu_colors()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Enable/Disable the application menubar
+ */
+void
+gui_mch_enable_menu(int flag)
+{
+	if (flag) {
+		window->showMenu(true);
+	} else {
+		window->showMenu(false);
+	}
+}
+
+/**
+ * Conceal menu entry
+ */
+void
+gui_mch_menu_hidden(vimmenu_T *menu, int hidden)
+{
+	if ( menu == NULL || menu->qaction == NULL ) {
+		return;
+	}
+	menu->qaction->setVisible( hidden == 0 );
+}
+
+/**
+ * Set the menubar position
+ *
+ * @warn We do nothing - The mainwindow handles this
+ */
+void
+gui_mch_set_menu_pos(int x, int y, int w, int h)
+{
+}
+
+/**
+ * Add a new ( menubar menu | toolbar action | )
+ */
+void
+gui_mch_add_menu(vimmenu_T *menu, int idx)
+{
+	menu->qmenu = NULL;
+	QAction *before=NULL;
+
+	if ( menu_is_popup(menu->name) ) {
+		menu->qmenu = new QMenu(VimWrapper::convertFrom(menu->name), vimshell);
+	} else if ( menu_is_toolbar(menu->name) ) {
+		menu->qmenu = window->toolBar();
+	} else if ( menu->parent == NULL ) {
+		QList<QAction*> actions = window->menuBar()->actions();
+		if ( idx < actions.size() ) {
+			before = actions.at(idx);
+		}
+
+		QMenu *m = new QMenu(VimWrapper::convertFrom(menu->name), window);
+		window->menuBar()->insertMenu( before, m);
+		menu->qmenu = m;
+	} else if ( menu->parent && menu->parent->qmenu ) {
+		QMenu *parent = (QMenu*)menu->parent->qmenu;
+		QList<QAction*> actions = parent->actions();
+		if ( idx < actions.size() ) {
+			before = actions.at(idx);
+		}
+
+		QMenu *m = new QMenu(VimWrapper::convertFrom(menu->name), window);
+		parent->insertMenu( before, m);
+		menu->qmenu = m;
+	}
+}
+
+/**
+ * Add menu item to menu
+ */
+void
+gui_mch_add_menu_item(vimmenu_T *menu, int idx)
+{
+	menu->qmenu = NULL;
+	if ( menu->parent == NULL || menu->parent->qmenu == NULL ) {
+		return;
+	}
+
+	QList<QAction*> actions = menu->parent->qmenu->actions();
+	QAction *before=NULL;
+	if ( idx < actions.size() ) {
+		before = actions.at(idx);
+	}
+
+	if ( menu_is_toolbar(menu->parent->name) ) {
+		// Toolbar
+		QToolBar *b = (QToolBar*)menu->parent->qmenu;
+		if (menu_is_separator(menu->name)) {
+			b->addSeparator();
+		} else {
+			QAction *action = new VimAction( menu, window );
+			b->insertAction(before, action);
+			menu->qaction = action;
+		}
+	} else {
+		// Menu entries
+		QMenu *m = (QMenu *)menu->parent->qmenu;
+		if (menu_is_separator(menu->name)) {
+			m->addSeparator();
+		} else {
+			QAction *action = new VimAction( menu, window );
+			m->insertAction(before, action);
+			menu->qaction = action;
+		}
+	}
+}
+
+void
+gui_mch_new_menu_font()
+{
+	qDebug() << __func__;
+
+}
+
+/**
+ * Destroy menu 
+ *
+ * Remove menu from parent and delete it
+ */
+void
+gui_mch_destroy_menu(vimmenu_T *menu)
+{
+	QMenu *parent = NULL;
+	if ( menu->parent ) {
+		parent = (QMenu*)menu->parent->qmenu;
+	}
+
+	if ( menu->qmenu != NULL ) {
+		QMenu *m = (QMenu*)menu->qmenu;
+
+		if ( parent ) {
+			parent->removeAction(m->menuAction());
+		} else {
+			window->menuBar()->removeAction(m->menuAction());
+		}
+		menu->qmenu->deleteLater();
+	}
+
+	if ( menu->qaction != NULL ) {
+		QAction *a = (QAction*)menu->qaction;
+
+		if ( parent ) {
+			parent->removeAction(a);
+		}
+		menu->qaction->deleteLater();
+	}
+
+}
+
+void gui_mch_show_popupmenu(vimmenu_T *menu)
+{
+	if ( menu == NULL || menu->qmenu == NULL ) {
+		return;
+	}
+
+	QMenu *m = (QMenu*)menu->qmenu;
+	m->popup( QCursor::pos() );
+}
+
+/**
+ * Set the menu and scrollbar colors to their default values.
+ */
+void
+gui_mch_def_colors()
+{
+	gui.norm_pixel = VimWrapper::toColor(QColor(Qt::black));
+	gui.back_pixel = VimWrapper::toColor(QColor(Qt::white));
+	gui.def_norm_pixel = gui.norm_pixel;
+	gui.def_back_pixel = gui.back_pixel;
+}
+
+//
+//
+// Scrollbar 
+// 
+
+void
+gui_mch_set_scrollbar_thumb(scrollbar_T *sb, long val, long size, long max)
+{
+	sb->wid->setValue(val);
+	sb->wid->setMaximum(max);
+	sb->wid->setPageStep(size);
+
+	sb->wid->setEnabled( !(size > max) );
+}
+
+/**
+ * Set scrollbar geometry
+ */
+void
+gui_mch_set_scrollbar_pos(scrollbar_T *sb, int x, int y, int width, int height)
+{
+	switch(sb->type) {
+	case SBAR_RIGHT:
+	case SBAR_LEFT:
+		sb->wid->setLength(height);
+		sb->wid->setIndex(y);
+		break;
+	default:
+		sb->wid->setLength(width);
+		sb->wid->setIndex(x);
+	}
+}
+
+/**
+ *
+ * Hide/Show scrollbar
+ *
+ */
+void
+gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)
+{
+	/*
+	sb->wid->setVisible(flag);
+	*/
+}
+
+/**
+ * Create a new scrollbar
+ */
+void
+gui_mch_create_scrollbar( scrollbar_T *sb, int orient)
+{
+	Qt::Orientation dir;
+	if ( orient == SBAR_HORIZ) {
+		dir = Qt::Horizontal;
+	} else {
+		dir = Qt::Vertical;
+	}
+
+	VimScrollBar *widget = new VimScrollBar( sb, dir, window);
+	widget->setVisible(false);
+	sb->wid = widget;
+
+	switch(sb->type) {
+	case SBAR_RIGHT:
+//		window->addScrollbarRight(widget);
+		break;
+	case SBAR_LEFT:
+//		window->addScrollbarLeft(widget);
+		break;
+	case SBAR_BOTTOM:
+//		window->addScrollbarBottom(widget);
+		break;
+	}
+}
+
+/**
+ * Destroy a scrollbar
+ */
+void
+gui_mch_destroy_scrollbar(scrollbar_T *sb)
+{
+	sb->wid->hide();
+	sb->wid->deleteLater();
+	sb->wid = NULL;
+}
+
+/**
+ *
+ * Pop open a file browser and return the file selected, in allocated memory,
+ * or NULL if Cancel is hit.
+ *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
+ *  title   - Title message for the file browser dialog.
+ *  dflt    - Default name of file.
+ *  ext     - Default extension to be added to files without extensions.
+ *  initdir - directory in which to open the browser (NULL = current dir)
+ *  filter  - Filter for matched files to choose from.
+ *
+ *  @see :h browsefilter
+ */
+char_u *
+gui_mch_browse(int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *vimfilter)
+{
+
+	QStringList res_filter ;
+	QString filters = VimWrapper::convertFrom(vimfilter);
+	filters.replace("(", "[").replace(")", "]");
+	QStringListIterator it(filters.split('\n', QString::SkipEmptyParts));
+	while (it.hasNext())
+	{
+		QString s = it.next();
+		int index = s.lastIndexOf('\t');
+		if (-1 != index)
+		{
+			QString new_str = s.mid(index+1).replace(";"," ");
+			res_filter << s.left(index) << "(" << new_str << ")" << ";;" ;
+		}
+	}
+	QString filterstr =  res_filter.join("") ;
+
+	QString dir;
+	if ( initdir == NULL ) {
+		dir = "";
+	} else {
+		dir = VimWrapper::convertFrom(initdir);
+	}
+
+	window->setEnabled(false);
+	QString file;
+	if ( saving ) {
+		file = QFileDialog::getSaveFileName(window, VimWrapper::convertFrom(title), dir, filterstr);
+	} else {
+		file = QFileDialog::getOpenFileName(window, VimWrapper::convertFrom(title), dir, filterstr);
+	}
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	if ( file.isEmpty() ) {
+		return NULL;
+	}
+
+	return vim_strsave((char_u *) VimWrapper::convertTo(file).data());
+}
+
+
+/**
+ * Open a dialog window
+ */
+int
+gui_mch_dialog(int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd)
+{
+	QMessageBox msgBox(window);
+	msgBox.setText( VimWrapper::convertFrom(message) );
+	msgBox.setWindowTitle( VimWrapper::convertFrom(title) );
+	
+	// Set icon
+	QMessageBox::Icon icon;
+	switch (type)
+	{
+		case VIM_GENERIC:
+			icon = QMessageBox::NoIcon;
+			break;
+		case VIM_ERROR:
+			icon = QMessageBox::Critical;
+			break;
+		case VIM_WARNING:
+			icon = QMessageBox::Warning;
+			break;
+		case VIM_INFO:
+			icon = QMessageBox::Information;
+			break;
+		case VIM_QUESTION:
+			icon = QMessageBox::Question;
+			break;
+		default:      
+			icon = QMessageBox::NoIcon;
+	};
+	msgBox.setIcon(icon);
+
+	// Add buttons
+	QList<QPushButton *> buttonList;
+	if ( buttons != NULL ) {
+		QStringList b_string;
+
+		b_string = VimWrapper::convertFrom(buttons).split(DLG_BUTTON_SEP);
+
+		QListIterator<QString> it(b_string);
+		int bt=1;
+		while(it.hasNext()) {
+			QPushButton *b = msgBox.addButton( it.next(), QMessageBox::ApplyRole);
+			buttonList.append(b);
+
+			if ( bt == dfltbutton ) {
+				b->setDefault(true);
+			}
+			bt++;
+		}
+	}
+
+	window->setEnabled(false);
+	msgBox.setEnabled(true);
+
+	msgBox.exec();
+
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	if ( msgBox.clickedButton() == 0 ) {
+		return 0;
+	}
+
+	int i=1;
+	QListIterator<QPushButton *> it(buttonList);
+	while( it.hasNext() ){
+		QPushButton *b = it.next();
+		if ( b == msgBox.clickedButton() ) {
+			return i;
+		}
+		i++;
+	}
+	return -1;
+}
+
+//
+// TabLine 
+//
+
+/**
+ * Show or hide the tabline.
+ */
+void
+gui_mch_show_tabline(int showit)
+{
+	window->showTabline(showit != 0);
+}
+
+/**
+ * Return TRUE when tabline is displayed.
+ */
+int
+gui_mch_showing_tabline(void)
+{
+	if ( window->tablineVisible() ) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/**
+ * Update the labels of the tabline.
+ */
+void
+gui_mch_update_tabline(void)
+{
+	tabpage_T *tp;
+	int current = 0;
+	int nr = 0;
+
+	for (tp = first_tabpage; tp != NULL; tp = tp->tp_next, nr++)
+	{
+		if (tp == curtab) {
+			current = nr;
+		}
+
+		get_tabline_label(tp, FALSE);
+		char_u *labeltext = CONVERT_TO_UTF8(NameBuff);
+		window->setTab( nr, VimWrapper::convertFrom(labeltext));
+		CONVERT_TO_UTF8_FREE(labeltext);
+	}
+	window->removeTabs(nr);
+	window->setCurrentTab(current);
+}
+
+/**
+ * Change the current tab
+ */
+void
+gui_mch_set_curtab(int nr)
+{
+	window->setCurrentTab(nr-1);
+}
+
+/**
+ * Launch font selection dialog
+ * @oldval is the name of the current font
+ *
+ * @return The name of the font or NULL on cancel 
+ */
+char_u *
+gui_mch_font_dialog(char_u *oldval)
+{
+	QFont *oldfont = gui_mch_get_font(oldval, 0);
+
+	char_u *rval = NULL;
+	bool ok;
+	static FontDialog *dialog = new FontDialog(window);
+	if ( oldfont != NULL ) {
+		dialog->selectCurrentFont(*oldfont);
+	}
+
+	window->setEnabled(false);
+	dialog->setEnabled(true);
+	if ( dialog->exec() == QDialog::Accepted ) {
+		QFont f =  dialog->selectedFont();
+		QByteArray text = VimWrapper::convertTo( QString("%1 %2").arg(f.family()).arg(f.pointSize()) );
+		if ( text.isEmpty() ) {
+			// This should not happen, but if it does vim
+			// behaves badly so lets be extra carefull
+			goto out;
+		}
+		text.append('\0');
+
+		char_u *buffer;
+		buffer = lalloc( text.size(), TRUE);
+		for (int i = 0; i < text.size(); ++i) {
+			buffer[i] = text[i];
+		}
+		rval = buffer;
+	}
+
+out:
+	window->setEnabled(true);
+	vimshell->setFocus();
+
+	return rval;
+}
+
+/**
+ * Draw an icon in the shell widget
+ * 
+ */
+void
+gui_mch_drawsign(int row, int col, int typenr)
+{
+	QIcon *icon = (QIcon *)sign_get_image(typenr);
+	if ( !icon ) {
+		return;
+	}
+
+	QPoint pos = VimWrapper::mapText(row, col);
+	QVimShell::PaintOperation op;
+	op.type = QVimShell::DRAWSIGN;
+	op.pos = pos;
+	op.sign = icon->pixmap( VimWrapper::charWidth()*2, VimWrapper::charHeight() );
+	op.rect = QRect(pos, QSize(VimWrapper::charWidth()*2, VimWrapper::charHeight()));
+
+	if (op.sign.isNull()) {
+		// FIXME: this should not happen
+		return;
+	}
+	vimshell->queuePaintOp(op);
+}
+
+
+/*
+ * Free memory associated with the sign
+ */
+void
+gui_mch_destroy_sign(void *sign)
+{
+	if ( sign ) {
+		delete (QIcon*)sign;
+	}
+}
+
+/**
+ * Register an icon with the given name
+ *
+ * The name can be:
+ *  1. A file path to an icon
+ *  1. A theme icon name
+ *
+ */
+void *
+gui_mch_register_sign(char_u *signfile)
+{
+	if ( !signfile || !signfile[0] ) {
+		return NULL;
+	}
+
+	QString name = VimWrapper::convertFrom(signfile);
+	QIcon icon(name);
+
+	//
+	// FIXME: QIcon::isNull may be false even the icon cannot
+	// provide a pixmap, so far this is the best alternative I
+	// have
+	if ( icon.availableSizes().isEmpty() ) {
+		icon = QIcon(QIcon::fromTheme(name));
+		if ( icon.availableSizes().isEmpty() ) {
+			EMSG(e_signdata);
+			return NULL;
+		}
+	}
+	
+	if ( icon.availableSizes().isEmpty() ) {
+		return NULL;
+	}
+
+	return new QIcon(icon);
+}
+
+} // extern "C"
diff -urN vim-src/src/main.c vim-qt-src/src/main.c
--- vim-src/src/main.c	2014-09-24 20:45:28.933425486 +0200
+++ vim-qt-src/src/main.c	2014-09-24 20:43:02.523348633 +0200
@@ -1624,7 +1624,7 @@
     }
 
     /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
-    if (TOLOWER_ASC(initstr[0]) == 'g')
+    if (TOLOWER_ASC(initstr[0]) == 'g' || TOLOWER_ASC(initstr[0]) == 'q')
     {
 	main_start_gui();
 #ifdef FEAT_GUI
diff -urN vim-src/src/menu.c vim-qt-src/src/menu.c
--- vim-src/src/menu.c	2014-09-24 20:45:28.940425440 +0200
+++ vim-qt-src/src/menu.c	2014-09-24 20:43:02.529348596 +0200
@@ -272,7 +272,7 @@
 	EMSG(_(e_trailing));
 	goto theend;
     }
-#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
+#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || FEAT_GUI_QT)
     old_menu_height = gui.menu_height;
 # if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_W16)
     old_toolbar_height = gui.toolbar_height;
@@ -391,7 +391,7 @@
 	vim_free(map_buf);
     }
 
-#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK))
+#if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT))
     /* If the menubar height changed, resize the window */
     if (gui.in_use
 	    && (gui.menu_height != old_menu_height
diff -urN vim-src/src/message.c vim-qt-src/src/message.c
--- vim-src/src/message.c	2014-09-24 20:45:28.942425427 +0200
+++ vim-qt-src/src/message.c	2014-09-24 20:43:02.530348590 +0200
@@ -3852,7 +3852,7 @@
 	    filter = BROWSE_FILTER_DEFAULT;
 	if (flags & BROWSE_DIR)
 	{
-#  if defined(FEAT_GUI_GTK) || defined(WIN3264)
+#  if defined(FEAT_GUI_GTK) || defined(WIN3264) && !defined(FEAT_GUI_QT)
 	    /* For systems that have a directory dialog. */
 	    fname = gui_mch_browsedir(title, initdir);
 #  else
@@ -3860,7 +3860,7 @@
 	     * remove the file name. */
 	    fname = gui_mch_browse(0, title, dflt, ext, initdir, (char_u *)"");
 #  endif
-#  if !defined(FEAT_GUI_GTK)
+#  if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_QT)
 	    /* Win32 adds a dummy file name, others return an arbitrary file
 	     * name.  GTK+ 2 returns only the directory, */
 	    if (fname != NULL && *fname != NUL && !mch_isdir(fname))
diff -urN vim-src/src/normal.c vim-qt-src/src/normal.c
--- vim-src/src/normal.c	2014-09-24 20:45:28.954425348 +0200
+++ vim-qt-src/src/normal.c	2014-09-24 20:43:02.536348554 +0200
@@ -2637,7 +2637,7 @@
 	     * Windows only shows the popup menu on the button up event.
 	     */
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
-			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT)
 	    if (!is_click)
 		return FALSE;
 #endif
@@ -2647,7 +2647,7 @@
 #endif
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
 	    || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON)
+	    || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_QT)
 	    if (gui.in_use)
 	    {
 		jump_flags = 0;
diff -urN vim-src/src/ops.c vim-qt-src/src/ops.c
--- vim-src/src/ops.c	2014-09-24 20:45:28.957425328 +0200
+++ vim-qt-src/src/ops.c	2014-09-24 20:43:02.537348549 +0200
@@ -29,7 +29,7 @@
 #define DELETION_REGISTER	36
 #ifdef FEAT_CLIPBOARD
 # define STAR_REGISTER		37
-#  ifdef FEAT_X11
+#  if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 #   define PLUS_REGISTER	38
 #  else
 #   define PLUS_REGISTER	STAR_REGISTER	    /* there is only one */
@@ -2968,7 +2968,7 @@
     char_u		*p;
     char_u		*pnew;
     struct block_def	bd;
-#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+#if defined(FEAT_CLIPBOARD) && ( defined(FEAT_X11) || defined(FEAT_GUI_QT) )
     int			did_star = FALSE;
 #endif
 
@@ -3237,12 +3237,12 @@
 
 	clip_own_selection(&clip_star);
 	clip_gen_set_selection(&clip_star);
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
 	did_star = TRUE;
 # endif
     }
 
-# ifdef FEAT_X11
+# if defined(FEAT_X11) || defined(FEAT_GUI_QT)
     /*
      * If we were yanking to the '+' register, send result to selection.
      * Also copy to the '*' register, in case auto-select is off.
diff -urN vim-src/src/option.c vim-qt-src/src/option.c
--- vim-src/src/option.c	2014-09-24 20:45:28.961425301 +0200
+++ vim-qt-src/src/option.c	2014-09-24 20:43:02.673347733 +0200
@@ -1254,6 +1254,28 @@
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+
+    {"fullscreen",    "fu", P_BOOL|P_NO_MKRC,
+#ifdef FEAT_FULLSCREEN
+			    (char_u *)&p_fullscreen, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+
+    {"fuoptions",  "fuopt", P_STRING|P_COMMA|P_NODUP|P_VI_DEF,
+#ifdef FEAT_FULLSCREEN
+			    (char_u *)&p_fuoptions, PV_NONE,
+			    {(char_u *)"", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)NULL, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+
+
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
@@ -6436,7 +6458,7 @@
 	if (gui.in_use)
 	{
 	    p = p_guifont;
-# if defined(FEAT_GUI_GTK)
+# if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
 	    /*
 	     * Put up a font dialog and let the user select a new value.
 	     * If this is cancelled go back to the old value but don't
@@ -6969,6 +6991,14 @@
     }
 #endif
 
+#ifdef FEAT_FULLSCREEN
+    /* 'fuoptions' */
+    else if (varp == &p_fuoptions)
+    {
+        gui_mch_update_fuoptions(p_fuoptions);
+    }
+#endif
+
 #ifdef FEAT_VIRTUALEDIT
     /* 'virtualedit' */
     else if (varp == &p_ve)
@@ -7873,6 +7903,18 @@
 	set_fileformat(curbuf->b_p_tx ? EOL_DOS : EOL_UNIX, opt_flags);
     }
 
+#ifdef FEAT_FULLSCREEN
+    else if ((int *)varp == &p_fullscreen && (gui.in_use || gui.starting))
+    {
+	if ( p_fullscreen && !old_value )
+	{
+	    gui_mch_enter_fullscreen();
+	} else if ( !p_fullscreen && old_value ) {
+	    gui_mch_leave_fullscreen();
+	}
+    }
+#endif
+
     /* when 'textauto' is set or reset also change 'fileformats' */
     else if ((int *)varp == &p_ta)
 	set_string_option_direct((char_u *)"ffs", -1,
@@ -7968,7 +8010,7 @@
 	p_wiv = (*T_XS != NUL);
     }
 
-#ifdef FEAT_BEVAL
+#if defined(FEAT_BEVAL) && !defined(FEAT_GUI_QT) 
     else if ((int *)varp == &p_beval)
     {
 	if (p_beval && !old_value)
diff -urN vim-src/src/option.h vim-qt-src/src/option.h
--- vim-src/src/option.h	2014-09-24 20:45:28.962425295 +0200
+++ vim-qt-src/src/option.h	2014-09-24 20:43:02.674347727 +0200
@@ -481,6 +481,10 @@
 #ifdef HAVE_FSYNC
 EXTERN int	p_fs;		/* 'fsync' */
 #endif
+#ifdef FEAT_FULLSCREEN
+EXTERN int	p_fullscreen;	/* fullscreen gui window */
+EXTERN char_u	*p_fuoptions;	/* fullscreen options */
+#endif
 EXTERN int	p_gd;		/* 'gdefault' */
 #ifdef FEAT_PRINTER
 EXTERN char_u	*p_pdev;	/* 'printdevice' */
diff -urN vim-src/src/os_mswin.c vim-qt-src/src/os_mswin.c
--- vim-src/src/os_mswin.c	2014-09-24 20:45:28.965425275 +0200
+++ vim-qt-src/src/os_mswin.c	2014-09-24 20:43:02.675347721 +0200
@@ -155,7 +155,7 @@
 extern char g_szOrigTitle[];
 #endif
 
-#ifdef FEAT_GUI
+#if defined(FEAT_GUI) && !defined(FEAT_GUI_QT)
 extern HWND s_hwnd;
 #else
 static HWND s_hwnd = 0;	    /* console window handle, set by GetConsoleHwnd() */
diff -urN vim-src/src/os_unix.c vim-qt-src/src/os_unix.c
--- vim-src/src/os_unix.c	2014-09-24 20:45:28.968425255 +0200
+++ vim-qt-src/src/os_unix.c	2014-09-24 20:43:02.676347715 +0200
@@ -2109,7 +2109,7 @@
     if (get_x11_windis() == OK)
 	type = 1;
 #else
-# if defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK)
+# if defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_QT)
     if (gui.in_use)
 	type = 1;
 # endif
@@ -2121,6 +2121,7 @@
      */
     if ((type || *T_TS != NUL) && title != NULL)
     {
+
 	if (oldtitle == NULL
 #ifdef FEAT_GUI
 		&& !gui.in_use
@@ -2138,7 +2139,7 @@
 	    set_x11_title(title);		/* x11 */
 #endif
 #if defined(FEAT_GUI_GTK) \
-	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_QT)
 	else
 	    gui_mch_settitle(title, icon);
 #endif
diff -urN vim-src/src/os_win32.c vim-qt-src/src/os_win32.c
--- vim-src/src/os_win32.c	2014-09-24 20:45:28.972425229 +0200
+++ vim-qt-src/src/os_win32.c	2014-09-24 20:43:02.678347703 +0200
@@ -2037,9 +2037,9 @@
     if (!executable_exists("findstr.exe", NULL))
 	set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
     win_clip_init();
-#endif
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 }
 
 
@@ -2522,9 +2522,9 @@
     g_fMouseAvail = GetSystemMetrics(SM_MOUSEPRESENT);
 #endif
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
     win_clip_init();
-#endif
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 
     /* This will be NULL on anything but NT 4.0 */
     s_pfnGetConsoleKeyboardLayoutName =
diff -urN vim-src/src/pathdef.cmake.in vim-qt-src/src/pathdef.cmake.in
--- vim-src/src/pathdef.cmake.in	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/pathdef.cmake.in	2011-06-16 16:58:04.000000000 +0200
@@ -0,0 +1,7 @@
+#include "vim.h"
+char_u *default_vim_dir = (char_u *)"${CMAKE_INSTALL_PREFIX}/share/vim/current";
+char_u *default_vimruntime_dir = (char_u *)"";
+char_u *all_cflags = (char_u *)"gcc -c -I. -Iproto -DHAVE_CONFIG_H -DFEAT_GUI_ATHENA -DFUNCPROTO=15 -DNARROWPROTO    -g -O2 -D_FORTIFY_SOURCE=1      ";
+char_u *all_lflags = (char_u *)"gcc   -L/usr/local/lib -o vim -lXaw -lXmu -lXext -lXt -lSM -lICE -lXpm -lXt -lX11 -lXdmcp -lSM -lICE -ldl -lm -lncurses -lnsl  -lacl -lattr -lgpm          ";
+char_u *compiled_user = (char_u *)"raf-r";
+char_u *compiled_sys = (char_u *)"${SITE_NAME}";
diff -urN vim-src/src/proto/gui_qt.pro vim-qt-src/src/proto/gui_qt.pro
--- vim-src/src/proto/gui_qt.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/proto/gui_qt.pro	2014-01-11 00:34:30.624264228 +0100
@@ -0,0 +1,83 @@
+
+/* Prototypes - I am probably missing something here */
+
+char_u *gui_mch_get_fontname __ARGS((GuiFont font, char_u *name));
+int gui_mch_get_winpos __ARGS((int *x, int *y));
+void gui_mch_set_winpos __ARGS((int x, int y));
+GuiFont gui_mch_get_font __ARGS((char_u *name, int giveErrorIfMissing));
+void gui_mch_set_foreground __ARGS((void));
+void gui_mch_enable_scrollbar __ARGS((scrollbar_T *sb, int flag));
+void gui_mch_free_font __ARGS((GuiFont font));
+void gui_mch_set_curtab __ARGS((int nr));
+void gui_mch_setmouse __ARGS((int x, int y));
+void gui_mch_settitle __ARGS((char_u *title, char_u *icon));
+void gui_mch_add_menu_item __ARGS((vimmenu_T *menu, int idx));
+void gui_mch_add_menu __ARGS((vimmenu_T *menu, int pos));
+void gui_mch_destroy_menu __ARGS((vimmenu_T *menu));
+void gui_mch_draw_menubar __ARGS((void));
+void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
+char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
+void gui_mch_menu_hidden __ARGS((vimmenu_T *menu, int hidden));
+void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
+void gui_mch_update_tabline __ARGS((void));
+void gui_mch_getmouse __ARGS((int *x, int *y));
+int gui_mch_adjust_charheight __ARGS((void));
+void gui_mch_update __ARGS((void));
+void gui_mch_prepare __ARGS((int *argc, char **argv));
+int gui_mch_init_check __ARGS((void));
+int gui_mch_init __ARGS((void));
+int gui_mch_open __ARGS((void));
+void gui_mch_exit __ARGS((int));
+int gui_mch_init_font __ARGS((char_u *font_name, int fontset));
+void gui_mch_set_font __ARGS((GuiFont font));
+void gui_mch_iconify __ARGS((void));
+void gui_mch_invert_rectangle __ARGS((int r, int c, int nr, int nc));
+void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
+void clip_mch_request_selection __ARGS((VimClipboard *cbd));
+void clip_mch_set_selection __ARGS((VimClipboard *cbd));
+int clip_mch_own_selection __ARGS((VimClipboard *cbd));
+void gui_mch_enable_scrollbar __ARGS((scrollbar_T *sb, int flag));
+void gui_mch_set_scrollbar_thumb __ARGS((scrollbar_T *sb, long val, long size, long max));
+void gui_mch_set_scrollbar_pos __ARGS((scrollbar_T *sb, int x, int y, int w, int h));
+void gui_mch_create_scrollbar __ARGS((scrollbar_T *sb, int orient));
+void gui_mch_destroy_scrollbar __ARGS((scrollbar_T *sb));
+guicolor_T gui_mch_get_color __ARGS((char_u *name));
+void gui_mch_mousehide __ARGS((int hide));
+void gui_mch_flush __ARGS((void));
+int gui_mch_haskey __ARGS((char_u *name));
+void gui_mch_beep __ARGS((void));
+void gui_mch_flash __ARGS((int msec));
+void gui_mch_set_blinking __ARGS((long wait, long on, long off));
+void gui_mch_stop_blink __ARGS((void));
+void gui_mch_start_blink __ARGS((void));
+void mch_set_mouse_shape __ARGS((int shape));
+char_u *gui_mch_font_dialog __ARGS((char_u *oldval));
+void gui_mch_show_toolbar __ARGS((int showit));
+void gui_mch_new_colors __ARGS((void));
+long_u gui_mch_get_rgb __ARGS((guicolor_T pixel));
+int gui_mch_wait_for_chars __ARGS((long int wtime));
+void gui_mch_draw_hollow_cursor __ARGS((guicolor_T color));
+void gui_mch_draw_part_cursor __ARGS((int w, int h, guicolor_T color));
+void gui_mch_set_menu_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_set_text_area_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
+void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
+void gui_mch_clear_block __ARGS((int row1, int col1, int row2, int col2));
+void gui_mch_set_fg_color __ARGS((guicolor_T color));
+void gui_mch_set_bg_color __ARGS((guicolor_T color));
+void gui_mch_set_sp_color __ARGS((guicolor_T color));
+void gui_mch_delete_lines __ARGS((int row, int num_lines));
+void gui_mch_insert_lines __ARGS((int row, int num_lines));
+void gui_mch_clear_all __ARGS((void));
+void gui_mch_draw_string __ARGS((int row, int col, char_u *s, int len, int flags));
+int gui_mch_showing_tabline __ARGS((void));
+void gui_mch_enable_menu __ARGS((int flag));
+void gui_mch_show_tabline __ARGS((int showit));
+void gui_mch_enter_fullscreen __ARGS((void));
+void gui_mch_leave_fullscreen __ARGS((void));
+void* gui_mch_register_sign __ARGS((char_u *signfile));
+void gui_mch_destroy_sign __ARGS((void *sign));
+void gui_mch_drawsign __ARGS((int row, int col, int typenr));
+void gui_mch_update_fuoptions __ARGS((char_u *optstr));
+
diff -urN vim-src/src/proto.h vim-qt-src/src/proto.h
--- vim-src/src/proto.h	2014-09-24 20:45:28.991425104 +0200
+++ vim-qt-src/src/proto.h	2014-09-24 20:43:02.746347295 +0200
@@ -252,6 +252,9 @@
 #  ifdef FEAT_SUN_WORKSHOP
 #   include "workshop.pro"
 #  endif
+#  ifdef FEAT_GUI_QT
+#   include "gui_qt.pro"
+#  endif
 # endif	/* FEAT_GUI */
 
 # ifdef FEAT_OLE
diff -urN vim-src/src/qt/colortable.cpp vim-qt-src/src/qt/colortable.cpp
--- vim-src/src/qt/colortable.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/colortable.cpp	2012-08-23 19:26:45.000000000 +0200
@@ -0,0 +1,697 @@
+#include "colortable.h"
+
+
+ColorTable ColorTable::m_instance;
+
+ColorTable::ColorTable()
+{
+	ColorTable& m_colorMap = m_instance;
+
+	/*
+	 * For some reason these are not in rgb.txt
+	 */
+	m_colorMap["lightmagenta"] = QColor(255, 160, 240);
+	m_colorMap["lightred"] = QColor(255, 160, 160);
+
+	/*
+	 * DONT EDIT - auto generated from rgb.txt
+	 */
+	m_colorMap["snow"] = QColor(255, 250, 250);
+	m_colorMap["ghostwhite"] = QColor(248, 248, 255);
+	m_colorMap["whitesmoke"] = QColor(245, 245, 245);
+	m_colorMap["gainsboro"] = QColor(220, 220, 220);
+	m_colorMap["floralwhite"] = QColor(255, 250, 240);
+	m_colorMap["oldlace"] = QColor(253, 245, 230);
+	m_colorMap["linen"] = QColor(250, 240, 230);
+	m_colorMap["antiquewhite"] = QColor(250, 235, 215);
+	m_colorMap["papayawhip"] = QColor(255, 239, 213);
+	m_colorMap["blanchedalmond"] = QColor(255, 235, 205);
+	m_colorMap["bisque"] = QColor(255, 228, 196);
+	m_colorMap["peachpuff"] = QColor(255, 218, 185);
+	m_colorMap["navajowhite"] = QColor(255, 222, 173);
+	m_colorMap["moccasin"] = QColor(255, 228, 181);
+	m_colorMap["cornsilk"] = QColor(255, 248, 220);
+	m_colorMap["ivory"] = QColor(255, 255, 240);
+	m_colorMap["lemonchiffon"] = QColor(255, 250, 205);
+	m_colorMap["seashell"] = QColor(255, 245, 238);
+	m_colorMap["honeydew"] = QColor(240, 255, 240);
+	m_colorMap["mintcream"] = QColor(245, 255, 250);
+	m_colorMap["azure"] = QColor(240, 255, 255);
+	m_colorMap["aliceblue"] = QColor(240, 248, 255);
+	m_colorMap["lavender"] = QColor(230, 230, 250);
+	m_colorMap["lavenderblush"] = QColor(255, 240, 245);
+	m_colorMap["mistyrose"] = QColor(255, 228, 225);
+	m_colorMap["white"] = QColor(255, 255, 255);
+	m_colorMap["black"] = QColor(0, 0, 0);
+	m_colorMap["darkslategray"] = QColor(47, 79, 79);
+	m_colorMap["darkslategrey"] = QColor(47, 79, 79);
+	m_colorMap["dimgray"] = QColor(105, 105, 105);
+	m_colorMap["dimgrey"] = QColor(105, 105, 105);
+	m_colorMap["slategray"] = QColor(112, 128, 144);
+	m_colorMap["slategrey"] = QColor(112, 128, 144);
+	m_colorMap["lightslategray"] = QColor(119, 136, 153);
+	m_colorMap["lightslategrey"] = QColor(119, 136, 153);
+	m_colorMap["gray"] = QColor(190, 190, 190);
+	m_colorMap["grey"] = QColor(190, 190, 190);
+	m_colorMap["lightgrey"] = QColor(211, 211, 211);
+	m_colorMap["lightgray"] = QColor(211, 211, 211);
+	m_colorMap["midnightblue"] = QColor(25, 25, 112);
+	m_colorMap["navy"] = QColor(0, 0, 128);
+	m_colorMap["navyblue"] = QColor(0, 0, 128);
+	m_colorMap["cornflowerblue"] = QColor(100, 149, 237);
+	m_colorMap["darkslateblue"] = QColor(72, 61, 139);
+	m_colorMap["slateblue"] = QColor(106, 90, 205);
+	m_colorMap["mediumslateblue"] = QColor(123, 104, 238);
+	m_colorMap["lightslateblue"] = QColor(132, 112, 255);
+	m_colorMap["mediumblue"] = QColor(0, 0, 205);
+	m_colorMap["royalblue"] = QColor(65, 105, 225);
+	m_colorMap["blue"] = QColor(0, 0, 255);
+	m_colorMap["dodgerblue"] = QColor(30, 144, 255);
+	m_colorMap["deepskyblue"] = QColor(0, 191, 255);
+	m_colorMap["skyblue"] = QColor(135, 206, 235);
+	m_colorMap["lightskyblue"] = QColor(135, 206, 250);
+	m_colorMap["steelblue"] = QColor(70, 130, 180);
+	m_colorMap["lightsteelblue"] = QColor(176, 196, 222);
+	m_colorMap["lightblue"] = QColor(173, 216, 230);
+	m_colorMap["powderblue"] = QColor(176, 224, 230);
+	m_colorMap["paleturquoise"] = QColor(175, 238, 238);
+	m_colorMap["darkturquoise"] = QColor(0, 206, 209);
+	m_colorMap["mediumturquoise"] = QColor(72, 209, 204);
+	m_colorMap["turquoise"] = QColor(64, 224, 208);
+	m_colorMap["cyan"] = QColor(0, 255, 255);
+	m_colorMap["lightcyan"] = QColor(224, 255, 255);
+	m_colorMap["cadetblue"] = QColor(95, 158, 160);
+	m_colorMap["mediumaquamarine"] = QColor(102, 205, 170);
+	m_colorMap["aquamarine"] = QColor(127, 255, 212);
+	m_colorMap["darkgreen"] = QColor(0, 100, 0);
+	m_colorMap["darkolivegreen"] = QColor(85, 107, 47);
+	m_colorMap["darkseagreen"] = QColor(143, 188, 143);
+	m_colorMap["seagreen"] = QColor(46, 139, 87);
+	m_colorMap["mediumseagreen"] = QColor(60, 179, 113);
+	m_colorMap["lightseagreen"] = QColor(32, 178, 170);
+	m_colorMap["palegreen"] = QColor(152, 251, 152);
+	m_colorMap["springgreen"] = QColor(0, 255, 127);
+	m_colorMap["lawngreen"] = QColor(124, 252, 0);
+	m_colorMap["green"] = QColor(0, 255, 0);
+	m_colorMap["chartreuse"] = QColor(127, 255, 0);
+	m_colorMap["mediumspringgreen"] = QColor(0, 250, 154);
+	m_colorMap["greenyellow"] = QColor(173, 255, 47);
+	m_colorMap["limegreen"] = QColor(50, 205, 50);
+	m_colorMap["yellowgreen"] = QColor(154, 205, 50);
+	m_colorMap["forestgreen"] = QColor(34, 139, 34);
+	m_colorMap["olivedrab"] = QColor(107, 142, 35);
+	m_colorMap["darkkhaki"] = QColor(189, 183, 107);
+	m_colorMap["khaki"] = QColor(240, 230, 140);
+	m_colorMap["palegoldenrod"] = QColor(238, 232, 170);
+	m_colorMap["lightgoldenrodyellow"] = QColor(250, 250, 210);
+	m_colorMap["lightyellow"] = QColor(255, 255, 224);
+	m_colorMap["yellow"] = QColor(255, 255, 0);
+	m_colorMap["gold"] = QColor(255, 215, 0);
+	m_colorMap["lightgoldenrod"] = QColor(238, 221, 130);
+	m_colorMap["goldenrod"] = QColor(218, 165, 32);
+	m_colorMap["darkgoldenrod"] = QColor(184, 134, 11);
+	m_colorMap["rosybrown"] = QColor(188, 143, 143);
+	m_colorMap["indianred"] = QColor(205, 92, 92);
+	m_colorMap["saddlebrown"] = QColor(139, 69, 19);
+	m_colorMap["sienna"] = QColor(160, 82, 45);
+	m_colorMap["peru"] = QColor(205, 133, 63);
+	m_colorMap["burlywood"] = QColor(222, 184, 135);
+	m_colorMap["beige"] = QColor(245, 245, 220);
+	m_colorMap["wheat"] = QColor(245, 222, 179);
+	m_colorMap["sandybrown"] = QColor(244, 164, 96);
+	m_colorMap["tan"] = QColor(210, 180, 140);
+	m_colorMap["chocolate"] = QColor(210, 105, 30);
+	m_colorMap["firebrick"] = QColor(178, 34, 34);
+	m_colorMap["brown"] = QColor(165, 42, 42);
+	m_colorMap["darksalmon"] = QColor(233, 150, 122);
+	m_colorMap["salmon"] = QColor(250, 128, 114);
+	m_colorMap["lightsalmon"] = QColor(255, 160, 122);
+	m_colorMap["orange"] = QColor(255, 165, 0);
+	m_colorMap["darkorange"] = QColor(255, 140, 0);
+	m_colorMap["coral"] = QColor(255, 127, 80);
+	m_colorMap["lightcoral"] = QColor(240, 128, 128);
+	m_colorMap["tomato"] = QColor(255, 99, 71);
+	m_colorMap["orangered"] = QColor(255, 69, 0);
+	m_colorMap["red"] = QColor(255, 0, 0);
+	m_colorMap["hotpink"] = QColor(255, 105, 180);
+	m_colorMap["deeppink"] = QColor(255, 20, 147);
+	m_colorMap["pink"] = QColor(255, 192, 203);
+	m_colorMap["lightpink"] = QColor(255, 182, 193);
+	m_colorMap["palevioletred"] = QColor(219, 112, 147);
+	m_colorMap["maroon"] = QColor(176, 48, 96);
+	m_colorMap["mediumvioletred"] = QColor(199, 21, 133);
+	m_colorMap["violetred"] = QColor(208, 32, 144);
+	m_colorMap["magenta"] = QColor(255, 0, 255);
+	m_colorMap["violet"] = QColor(238, 130, 238);
+	m_colorMap["plum"] = QColor(221, 160, 221);
+	m_colorMap["orchid"] = QColor(218, 112, 214);
+	m_colorMap["mediumorchid"] = QColor(186, 85, 211);
+	m_colorMap["darkorchid"] = QColor(153, 50, 204);
+	m_colorMap["darkviolet"] = QColor(148, 0, 211);
+	m_colorMap["blueviolet"] = QColor(138, 43, 226);
+	m_colorMap["purple"] = QColor(160, 32, 240);
+	m_colorMap["mediumpurple"] = QColor(147, 112, 219);
+	m_colorMap["thistle"] = QColor(216, 191, 216);
+	m_colorMap["snow1"] = QColor(255, 250, 250);
+	m_colorMap["snow2"] = QColor(238, 233, 233);
+	m_colorMap["snow3"] = QColor(205, 201, 201);
+	m_colorMap["snow4"] = QColor(139, 137, 137);
+	m_colorMap["seashell1"] = QColor(255, 245, 238);
+	m_colorMap["seashell2"] = QColor(238, 229, 222);
+	m_colorMap["seashell3"] = QColor(205, 197, 191);
+	m_colorMap["seashell4"] = QColor(139, 134, 130);
+	m_colorMap["antiquewhite1"] = QColor(255, 239, 219);
+	m_colorMap["antiquewhite2"] = QColor(238, 223, 204);
+	m_colorMap["antiquewhite3"] = QColor(205, 192, 176);
+	m_colorMap["antiquewhite4"] = QColor(139, 131, 120);
+	m_colorMap["bisque1"] = QColor(255, 228, 196);
+	m_colorMap["bisque2"] = QColor(238, 213, 183);
+	m_colorMap["bisque3"] = QColor(205, 183, 158);
+	m_colorMap["bisque4"] = QColor(139, 125, 107);
+	m_colorMap["peachpuff1"] = QColor(255, 218, 185);
+	m_colorMap["peachpuff2"] = QColor(238, 203, 173);
+	m_colorMap["peachpuff3"] = QColor(205, 175, 149);
+	m_colorMap["peachpuff4"] = QColor(139, 119, 101);
+	m_colorMap["navajowhite1"] = QColor(255, 222, 173);
+	m_colorMap["navajowhite2"] = QColor(238, 207, 161);
+	m_colorMap["navajowhite3"] = QColor(205, 179, 139);
+	m_colorMap["navajowhite4"] = QColor(139, 121, 94);
+	m_colorMap["lemonchiffon1"] = QColor(255, 250, 205);
+	m_colorMap["lemonchiffon2"] = QColor(238, 233, 191);
+	m_colorMap["lemonchiffon3"] = QColor(205, 201, 165);
+	m_colorMap["lemonchiffon4"] = QColor(139, 137, 112);
+	m_colorMap["cornsilk1"] = QColor(255, 248, 220);
+	m_colorMap["cornsilk2"] = QColor(238, 232, 205);
+	m_colorMap["cornsilk3"] = QColor(205, 200, 177);
+	m_colorMap["cornsilk4"] = QColor(139, 136, 120);
+	m_colorMap["ivory1"] = QColor(255, 255, 240);
+	m_colorMap["ivory2"] = QColor(238, 238, 224);
+	m_colorMap["ivory3"] = QColor(205, 205, 193);
+	m_colorMap["ivory4"] = QColor(139, 139, 131);
+	m_colorMap["honeydew1"] = QColor(240, 255, 240);
+	m_colorMap["honeydew2"] = QColor(224, 238, 224);
+	m_colorMap["honeydew3"] = QColor(193, 205, 193);
+	m_colorMap["honeydew4"] = QColor(131, 139, 131);
+	m_colorMap["lavenderblush1"] = QColor(255, 240, 245);
+	m_colorMap["lavenderblush2"] = QColor(238, 224, 229);
+	m_colorMap["lavenderblush3"] = QColor(205, 193, 197);
+	m_colorMap["lavenderblush4"] = QColor(139, 131, 134);
+	m_colorMap["mistyrose1"] = QColor(255, 228, 225);
+	m_colorMap["mistyrose2"] = QColor(238, 213, 210);
+	m_colorMap["mistyrose3"] = QColor(205, 183, 181);
+	m_colorMap["mistyrose4"] = QColor(139, 125, 123);
+	m_colorMap["azure1"] = QColor(240, 255, 255);
+	m_colorMap["azure2"] = QColor(224, 238, 238);
+	m_colorMap["azure3"] = QColor(193, 205, 205);
+	m_colorMap["azure4"] = QColor(131, 139, 139);
+	m_colorMap["slateblue1"] = QColor(131, 111, 255);
+	m_colorMap["slateblue2"] = QColor(122, 103, 238);
+	m_colorMap["slateblue3"] = QColor(105, 89, 205);
+	m_colorMap["slateblue4"] = QColor(71, 60, 139);
+	m_colorMap["royalblue1"] = QColor(72, 118, 255);
+	m_colorMap["royalblue2"] = QColor(67, 110, 238);
+	m_colorMap["royalblue3"] = QColor(58, 95, 205);
+	m_colorMap["royalblue4"] = QColor(39, 64, 139);
+	m_colorMap["blue1"] = QColor(0, 0, 255);
+	m_colorMap["blue2"] = QColor(0, 0, 238);
+	m_colorMap["blue3"] = QColor(0, 0, 205);
+	m_colorMap["blue4"] = QColor(0, 0, 139);
+	m_colorMap["dodgerblue1"] = QColor(30, 144, 255);
+	m_colorMap["dodgerblue2"] = QColor(28, 134, 238);
+	m_colorMap["dodgerblue3"] = QColor(24, 116, 205);
+	m_colorMap["dodgerblue4"] = QColor(16, 78, 139);
+	m_colorMap["steelblue1"] = QColor(99, 184, 255);
+	m_colorMap["steelblue2"] = QColor(92, 172, 238);
+	m_colorMap["steelblue3"] = QColor(79, 148, 205);
+	m_colorMap["steelblue4"] = QColor(54, 100, 139);
+	m_colorMap["deepskyblue1"] = QColor(0, 191, 255);
+	m_colorMap["deepskyblue2"] = QColor(0, 178, 238);
+	m_colorMap["deepskyblue3"] = QColor(0, 154, 205);
+	m_colorMap["deepskyblue4"] = QColor(0, 104, 139);
+	m_colorMap["skyblue1"] = QColor(135, 206, 255);
+	m_colorMap["skyblue2"] = QColor(126, 192, 238);
+	m_colorMap["skyblue3"] = QColor(108, 166, 205);
+	m_colorMap["skyblue4"] = QColor(74, 112, 139);
+	m_colorMap["lightskyblue1"] = QColor(176, 226, 255);
+	m_colorMap["lightskyblue2"] = QColor(164, 211, 238);
+	m_colorMap["lightskyblue3"] = QColor(141, 182, 205);
+	m_colorMap["lightskyblue4"] = QColor(96, 123, 139);
+	m_colorMap["slategray1"] = QColor(198, 226, 255);
+	m_colorMap["slategray2"] = QColor(185, 211, 238);
+	m_colorMap["slategray3"] = QColor(159, 182, 205);
+	m_colorMap["slategray4"] = QColor(108, 123, 139);
+	m_colorMap["lightsteelblue1"] = QColor(202, 225, 255);
+	m_colorMap["lightsteelblue2"] = QColor(188, 210, 238);
+	m_colorMap["lightsteelblue3"] = QColor(162, 181, 205);
+	m_colorMap["lightsteelblue4"] = QColor(110, 123, 139);
+	m_colorMap["lightblue1"] = QColor(191, 239, 255);
+	m_colorMap["lightblue2"] = QColor(178, 223, 238);
+	m_colorMap["lightblue3"] = QColor(154, 192, 205);
+	m_colorMap["lightblue4"] = QColor(104, 131, 139);
+	m_colorMap["lightcyan1"] = QColor(224, 255, 255);
+	m_colorMap["lightcyan2"] = QColor(209, 238, 238);
+	m_colorMap["lightcyan3"] = QColor(180, 205, 205);
+	m_colorMap["lightcyan4"] = QColor(122, 139, 139);
+	m_colorMap["paleturquoise1"] = QColor(187, 255, 255);
+	m_colorMap["paleturquoise2"] = QColor(174, 238, 238);
+	m_colorMap["paleturquoise3"] = QColor(150, 205, 205);
+	m_colorMap["paleturquoise4"] = QColor(102, 139, 139);
+	m_colorMap["cadetblue1"] = QColor(152, 245, 255);
+	m_colorMap["cadetblue2"] = QColor(142, 229, 238);
+	m_colorMap["cadetblue3"] = QColor(122, 197, 205);
+	m_colorMap["cadetblue4"] = QColor(83, 134, 139);
+	m_colorMap["turquoise1"] = QColor(0, 245, 255);
+	m_colorMap["turquoise2"] = QColor(0, 229, 238);
+	m_colorMap["turquoise3"] = QColor(0, 197, 205);
+	m_colorMap["turquoise4"] = QColor(0, 134, 139);
+	m_colorMap["cyan1"] = QColor(0, 255, 255);
+	m_colorMap["cyan2"] = QColor(0, 238, 238);
+	m_colorMap["cyan3"] = QColor(0, 205, 205);
+	m_colorMap["cyan4"] = QColor(0, 139, 139);
+	m_colorMap["darkslategray1"] = QColor(151, 255, 255);
+	m_colorMap["darkslategray2"] = QColor(141, 238, 238);
+	m_colorMap["darkslategray3"] = QColor(121, 205, 205);
+	m_colorMap["darkslategray4"] = QColor(82, 139, 139);
+	m_colorMap["aquamarine1"] = QColor(127, 255, 212);
+	m_colorMap["aquamarine2"] = QColor(118, 238, 198);
+	m_colorMap["aquamarine3"] = QColor(102, 205, 170);
+	m_colorMap["aquamarine4"] = QColor(69, 139, 116);
+	m_colorMap["darkseagreen1"] = QColor(193, 255, 193);
+	m_colorMap["darkseagreen2"] = QColor(180, 238, 180);
+	m_colorMap["darkseagreen3"] = QColor(155, 205, 155);
+	m_colorMap["darkseagreen4"] = QColor(105, 139, 105);
+	m_colorMap["seagreen1"] = QColor(84, 255, 159);
+	m_colorMap["seagreen2"] = QColor(78, 238, 148);
+	m_colorMap["seagreen3"] = QColor(67, 205, 128);
+	m_colorMap["seagreen4"] = QColor(46, 139, 87);
+	m_colorMap["palegreen1"] = QColor(154, 255, 154);
+	m_colorMap["palegreen2"] = QColor(144, 238, 144);
+	m_colorMap["palegreen3"] = QColor(124, 205, 124);
+	m_colorMap["palegreen4"] = QColor(84, 139, 84);
+	m_colorMap["springgreen1"] = QColor(0, 255, 127);
+	m_colorMap["springgreen2"] = QColor(0, 238, 118);
+	m_colorMap["springgreen3"] = QColor(0, 205, 102);
+	m_colorMap["springgreen4"] = QColor(0, 139, 69);
+	m_colorMap["green1"] = QColor(0, 255, 0);
+	m_colorMap["green2"] = QColor(0, 238, 0);
+	m_colorMap["green3"] = QColor(0, 205, 0);
+	m_colorMap["green4"] = QColor(0, 139, 0);
+	m_colorMap["chartreuse1"] = QColor(127, 255, 0);
+	m_colorMap["chartreuse2"] = QColor(118, 238, 0);
+	m_colorMap["chartreuse3"] = QColor(102, 205, 0);
+	m_colorMap["chartreuse4"] = QColor(69, 139, 0);
+	m_colorMap["olivedrab1"] = QColor(192, 255, 62);
+	m_colorMap["olivedrab2"] = QColor(179, 238, 58);
+	m_colorMap["olivedrab3"] = QColor(154, 205, 50);
+	m_colorMap["olivedrab4"] = QColor(105, 139, 34);
+	m_colorMap["darkolivegreen1"] = QColor(202, 255, 112);
+	m_colorMap["darkolivegreen2"] = QColor(188, 238, 104);
+	m_colorMap["darkolivegreen3"] = QColor(162, 205, 90);
+	m_colorMap["darkolivegreen4"] = QColor(110, 139, 61);
+	m_colorMap["khaki1"] = QColor(255, 246, 143);
+	m_colorMap["khaki2"] = QColor(238, 230, 133);
+	m_colorMap["khaki3"] = QColor(205, 198, 115);
+	m_colorMap["khaki4"] = QColor(139, 134, 78);
+	m_colorMap["lightgoldenrod1"] = QColor(255, 236, 139);
+	m_colorMap["lightgoldenrod2"] = QColor(238, 220, 130);
+	m_colorMap["lightgoldenrod3"] = QColor(205, 190, 112);
+	m_colorMap["lightgoldenrod4"] = QColor(139, 129, 76);
+	m_colorMap["lightyellow1"] = QColor(255, 255, 224);
+	m_colorMap["lightyellow2"] = QColor(238, 238, 209);
+	m_colorMap["lightyellow3"] = QColor(205, 205, 180);
+	m_colorMap["lightyellow4"] = QColor(139, 139, 122);
+	m_colorMap["yellow1"] = QColor(255, 255, 0);
+	m_colorMap["yellow2"] = QColor(238, 238, 0);
+	m_colorMap["yellow3"] = QColor(205, 205, 0);
+	m_colorMap["yellow4"] = QColor(139, 139, 0);
+	m_colorMap["gold1"] = QColor(255, 215, 0);
+	m_colorMap["gold2"] = QColor(238, 201, 0);
+	m_colorMap["gold3"] = QColor(205, 173, 0);
+	m_colorMap["gold4"] = QColor(139, 117, 0);
+	m_colorMap["goldenrod1"] = QColor(255, 193, 37);
+	m_colorMap["goldenrod2"] = QColor(238, 180, 34);
+	m_colorMap["goldenrod3"] = QColor(205, 155, 29);
+	m_colorMap["goldenrod4"] = QColor(139, 105, 20);
+	m_colorMap["darkgoldenrod1"] = QColor(255, 185, 15);
+	m_colorMap["darkgoldenrod2"] = QColor(238, 173, 14);
+	m_colorMap["darkgoldenrod3"] = QColor(205, 149, 12);
+	m_colorMap["darkgoldenrod4"] = QColor(139, 101, 8);
+	m_colorMap["rosybrown1"] = QColor(255, 193, 193);
+	m_colorMap["rosybrown2"] = QColor(238, 180, 180);
+	m_colorMap["rosybrown3"] = QColor(205, 155, 155);
+	m_colorMap["rosybrown4"] = QColor(139, 105, 105);
+	m_colorMap["indianred1"] = QColor(255, 106, 106);
+	m_colorMap["indianred2"] = QColor(238, 99, 99);
+	m_colorMap["indianred3"] = QColor(205, 85, 85);
+	m_colorMap["indianred4"] = QColor(139, 58, 58);
+	m_colorMap["sienna1"] = QColor(255, 130, 71);
+	m_colorMap["sienna2"] = QColor(238, 121, 66);
+	m_colorMap["sienna3"] = QColor(205, 104, 57);
+	m_colorMap["sienna4"] = QColor(139, 71, 38);
+	m_colorMap["burlywood1"] = QColor(255, 211, 155);
+	m_colorMap["burlywood2"] = QColor(238, 197, 145);
+	m_colorMap["burlywood3"] = QColor(205, 170, 125);
+	m_colorMap["burlywood4"] = QColor(139, 115, 85);
+	m_colorMap["wheat1"] = QColor(255, 231, 186);
+	m_colorMap["wheat2"] = QColor(238, 216, 174);
+	m_colorMap["wheat3"] = QColor(205, 186, 150);
+	m_colorMap["wheat4"] = QColor(139, 126, 102);
+	m_colorMap["tan1"] = QColor(255, 165, 79);
+	m_colorMap["tan2"] = QColor(238, 154, 73);
+	m_colorMap["tan3"] = QColor(205, 133, 63);
+	m_colorMap["tan4"] = QColor(139, 90, 43);
+	m_colorMap["chocolate1"] = QColor(255, 127, 36);
+	m_colorMap["chocolate2"] = QColor(238, 118, 33);
+	m_colorMap["chocolate3"] = QColor(205, 102, 29);
+	m_colorMap["chocolate4"] = QColor(139, 69, 19);
+	m_colorMap["firebrick1"] = QColor(255, 48, 48);
+	m_colorMap["firebrick2"] = QColor(238, 44, 44);
+	m_colorMap["firebrick3"] = QColor(205, 38, 38);
+	m_colorMap["firebrick4"] = QColor(139, 26, 26);
+	m_colorMap["brown1"] = QColor(255, 64, 64);
+	m_colorMap["brown2"] = QColor(238, 59, 59);
+	m_colorMap["brown3"] = QColor(205, 51, 51);
+	m_colorMap["brown4"] = QColor(139, 35, 35);
+	m_colorMap["salmon1"] = QColor(255, 140, 105);
+	m_colorMap["salmon2"] = QColor(238, 130, 98);
+	m_colorMap["salmon3"] = QColor(205, 112, 84);
+	m_colorMap["salmon4"] = QColor(139, 76, 57);
+	m_colorMap["lightsalmon1"] = QColor(255, 160, 122);
+	m_colorMap["lightsalmon2"] = QColor(238, 149, 114);
+	m_colorMap["lightsalmon3"] = QColor(205, 129, 98);
+	m_colorMap["lightsalmon4"] = QColor(139, 87, 66);
+	m_colorMap["orange1"] = QColor(255, 165, 0);
+	m_colorMap["orange2"] = QColor(238, 154, 0);
+	m_colorMap["orange3"] = QColor(205, 133, 0);
+	m_colorMap["orange4"] = QColor(139, 90, 0);
+	m_colorMap["darkorange1"] = QColor(255, 127, 0);
+	m_colorMap["darkorange2"] = QColor(238, 118, 0);
+	m_colorMap["darkorange3"] = QColor(205, 102, 0);
+	m_colorMap["darkorange4"] = QColor(139, 69, 0);
+	m_colorMap["coral1"] = QColor(255, 114, 86);
+	m_colorMap["coral2"] = QColor(238, 106, 80);
+	m_colorMap["coral3"] = QColor(205, 91, 69);
+	m_colorMap["coral4"] = QColor(139, 62, 47);
+	m_colorMap["tomato1"] = QColor(255, 99, 71);
+	m_colorMap["tomato2"] = QColor(238, 92, 66);
+	m_colorMap["tomato3"] = QColor(205, 79, 57);
+	m_colorMap["tomato4"] = QColor(139, 54, 38);
+	m_colorMap["orangered1"] = QColor(255, 69, 0);
+	m_colorMap["orangered2"] = QColor(238, 64, 0);
+	m_colorMap["orangered3"] = QColor(205, 55, 0);
+	m_colorMap["orangered4"] = QColor(139, 37, 0);
+	m_colorMap["red1"] = QColor(255, 0, 0);
+	m_colorMap["red2"] = QColor(238, 0, 0);
+	m_colorMap["red3"] = QColor(205, 0, 0);
+	m_colorMap["red4"] = QColor(139, 0, 0);
+	m_colorMap["deeppink1"] = QColor(255, 20, 147);
+	m_colorMap["deeppink2"] = QColor(238, 18, 137);
+	m_colorMap["deeppink3"] = QColor(205, 16, 118);
+	m_colorMap["deeppink4"] = QColor(139, 10, 80);
+	m_colorMap["hotpink1"] = QColor(255, 110, 180);
+	m_colorMap["hotpink2"] = QColor(238, 106, 167);
+	m_colorMap["hotpink3"] = QColor(205, 96, 144);
+	m_colorMap["hotpink4"] = QColor(139, 58, 98);
+	m_colorMap["pink1"] = QColor(255, 181, 197);
+	m_colorMap["pink2"] = QColor(238, 169, 184);
+	m_colorMap["pink3"] = QColor(205, 145, 158);
+	m_colorMap["pink4"] = QColor(139, 99, 108);
+	m_colorMap["lightpink1"] = QColor(255, 174, 185);
+	m_colorMap["lightpink2"] = QColor(238, 162, 173);
+	m_colorMap["lightpink3"] = QColor(205, 140, 149);
+	m_colorMap["lightpink4"] = QColor(139, 95, 101);
+	m_colorMap["palevioletred1"] = QColor(255, 130, 171);
+	m_colorMap["palevioletred2"] = QColor(238, 121, 159);
+	m_colorMap["palevioletred3"] = QColor(205, 104, 137);
+	m_colorMap["palevioletred4"] = QColor(139, 71, 93);
+	m_colorMap["maroon1"] = QColor(255, 52, 179);
+	m_colorMap["maroon2"] = QColor(238, 48, 167);
+	m_colorMap["maroon3"] = QColor(205, 41, 144);
+	m_colorMap["maroon4"] = QColor(139, 28, 98);
+	m_colorMap["violetred1"] = QColor(255, 62, 150);
+	m_colorMap["violetred2"] = QColor(238, 58, 140);
+	m_colorMap["violetred3"] = QColor(205, 50, 120);
+	m_colorMap["violetred4"] = QColor(139, 34, 82);
+	m_colorMap["magenta1"] = QColor(255, 0, 255);
+	m_colorMap["magenta2"] = QColor(238, 0, 238);
+	m_colorMap["magenta3"] = QColor(205, 0, 205);
+	m_colorMap["magenta4"] = QColor(139, 0, 139);
+	m_colorMap["orchid1"] = QColor(255, 131, 250);
+	m_colorMap["orchid2"] = QColor(238, 122, 233);
+	m_colorMap["orchid3"] = QColor(205, 105, 201);
+	m_colorMap["orchid4"] = QColor(139, 71, 137);
+	m_colorMap["plum1"] = QColor(255, 187, 255);
+	m_colorMap["plum2"] = QColor(238, 174, 238);
+	m_colorMap["plum3"] = QColor(205, 150, 205);
+	m_colorMap["plum4"] = QColor(139, 102, 139);
+	m_colorMap["mediumorchid1"] = QColor(224, 102, 255);
+	m_colorMap["mediumorchid2"] = QColor(209, 95, 238);
+	m_colorMap["mediumorchid3"] = QColor(180, 82, 205);
+	m_colorMap["mediumorchid4"] = QColor(122, 55, 139);
+	m_colorMap["darkorchid1"] = QColor(191, 62, 255);
+	m_colorMap["darkorchid2"] = QColor(178, 58, 238);
+	m_colorMap["darkorchid3"] = QColor(154, 50, 205);
+	m_colorMap["darkorchid4"] = QColor(104, 34, 139);
+	m_colorMap["purple1"] = QColor(155, 48, 255);
+	m_colorMap["purple2"] = QColor(145, 44, 238);
+	m_colorMap["purple3"] = QColor(125, 38, 205);
+	m_colorMap["purple4"] = QColor(85, 26, 139);
+	m_colorMap["mediumpurple1"] = QColor(171, 130, 255);
+	m_colorMap["mediumpurple2"] = QColor(159, 121, 238);
+	m_colorMap["mediumpurple3"] = QColor(137, 104, 205);
+	m_colorMap["mediumpurple4"] = QColor(93, 71, 139);
+	m_colorMap["thistle1"] = QColor(255, 225, 255);
+	m_colorMap["thistle2"] = QColor(238, 210, 238);
+	m_colorMap["thistle3"] = QColor(205, 181, 205);
+	m_colorMap["thistle4"] = QColor(139, 123, 139);
+	m_colorMap["gray0"] = QColor(0, 0, 0);
+	m_colorMap["grey0"] = QColor(0, 0, 0);
+	m_colorMap["gray1"] = QColor(3, 3, 3);
+	m_colorMap["grey1"] = QColor(3, 3, 3);
+	m_colorMap["gray2"] = QColor(5, 5, 5);
+	m_colorMap["grey2"] = QColor(5, 5, 5);
+	m_colorMap["gray3"] = QColor(8, 8, 8);
+	m_colorMap["grey3"] = QColor(8, 8, 8);
+	m_colorMap["gray4"] = QColor(10, 10, 10);
+	m_colorMap["grey4"] = QColor(10, 10, 10);
+	m_colorMap["gray5"] = QColor(13, 13, 13);
+	m_colorMap["grey5"] = QColor(13, 13, 13);
+	m_colorMap["gray6"] = QColor(15, 15, 15);
+	m_colorMap["grey6"] = QColor(15, 15, 15);
+	m_colorMap["gray7"] = QColor(18, 18, 18);
+	m_colorMap["grey7"] = QColor(18, 18, 18);
+	m_colorMap["gray8"] = QColor(20, 20, 20);
+	m_colorMap["grey8"] = QColor(20, 20, 20);
+	m_colorMap["gray9"] = QColor(23, 23, 23);
+	m_colorMap["grey9"] = QColor(23, 23, 23);
+	m_colorMap["gray10"] = QColor(26, 26, 26);
+	m_colorMap["grey10"] = QColor(26, 26, 26);
+	m_colorMap["gray11"] = QColor(28, 28, 28);
+	m_colorMap["grey11"] = QColor(28, 28, 28);
+	m_colorMap["gray12"] = QColor(31, 31, 31);
+	m_colorMap["grey12"] = QColor(31, 31, 31);
+	m_colorMap["gray13"] = QColor(33, 33, 33);
+	m_colorMap["grey13"] = QColor(33, 33, 33);
+	m_colorMap["gray14"] = QColor(36, 36, 36);
+	m_colorMap["grey14"] = QColor(36, 36, 36);
+	m_colorMap["gray15"] = QColor(38, 38, 38);
+	m_colorMap["grey15"] = QColor(38, 38, 38);
+	m_colorMap["gray16"] = QColor(41, 41, 41);
+	m_colorMap["grey16"] = QColor(41, 41, 41);
+	m_colorMap["gray17"] = QColor(43, 43, 43);
+	m_colorMap["grey17"] = QColor(43, 43, 43);
+	m_colorMap["gray18"] = QColor(46, 46, 46);
+	m_colorMap["grey18"] = QColor(46, 46, 46);
+	m_colorMap["gray19"] = QColor(48, 48, 48);
+	m_colorMap["grey19"] = QColor(48, 48, 48);
+	m_colorMap["gray20"] = QColor(51, 51, 51);
+	m_colorMap["grey20"] = QColor(51, 51, 51);
+	m_colorMap["gray21"] = QColor(54, 54, 54);
+	m_colorMap["grey21"] = QColor(54, 54, 54);
+	m_colorMap["gray22"] = QColor(56, 56, 56);
+	m_colorMap["grey22"] = QColor(56, 56, 56);
+	m_colorMap["gray23"] = QColor(59, 59, 59);
+	m_colorMap["grey23"] = QColor(59, 59, 59);
+	m_colorMap["gray24"] = QColor(61, 61, 61);
+	m_colorMap["grey24"] = QColor(61, 61, 61);
+	m_colorMap["gray25"] = QColor(64, 64, 64);
+	m_colorMap["grey25"] = QColor(64, 64, 64);
+	m_colorMap["gray26"] = QColor(66, 66, 66);
+	m_colorMap["grey26"] = QColor(66, 66, 66);
+	m_colorMap["gray27"] = QColor(69, 69, 69);
+	m_colorMap["grey27"] = QColor(69, 69, 69);
+	m_colorMap["gray28"] = QColor(71, 71, 71);
+	m_colorMap["grey28"] = QColor(71, 71, 71);
+	m_colorMap["gray29"] = QColor(74, 74, 74);
+	m_colorMap["grey29"] = QColor(74, 74, 74);
+	m_colorMap["gray30"] = QColor(77, 77, 77);
+	m_colorMap["grey30"] = QColor(77, 77, 77);
+	m_colorMap["gray31"] = QColor(79, 79, 79);
+	m_colorMap["grey31"] = QColor(79, 79, 79);
+	m_colorMap["gray32"] = QColor(82, 82, 82);
+	m_colorMap["grey32"] = QColor(82, 82, 82);
+	m_colorMap["gray33"] = QColor(84, 84, 84);
+	m_colorMap["grey33"] = QColor(84, 84, 84);
+	m_colorMap["gray34"] = QColor(87, 87, 87);
+	m_colorMap["grey34"] = QColor(87, 87, 87);
+	m_colorMap["gray35"] = QColor(89, 89, 89);
+	m_colorMap["grey35"] = QColor(89, 89, 89);
+	m_colorMap["gray36"] = QColor(92, 92, 92);
+	m_colorMap["grey36"] = QColor(92, 92, 92);
+	m_colorMap["gray37"] = QColor(94, 94, 94);
+	m_colorMap["grey37"] = QColor(94, 94, 94);
+	m_colorMap["gray38"] = QColor(97, 97, 97);
+	m_colorMap["grey38"] = QColor(97, 97, 97);
+	m_colorMap["gray39"] = QColor(99, 99, 99);
+	m_colorMap["grey39"] = QColor(99, 99, 99);
+	m_colorMap["gray40"] = QColor(102, 102, 102);
+	m_colorMap["grey40"] = QColor(102, 102, 102);
+	m_colorMap["gray41"] = QColor(105, 105, 105);
+	m_colorMap["grey41"] = QColor(105, 105, 105);
+	m_colorMap["gray42"] = QColor(107, 107, 107);
+	m_colorMap["grey42"] = QColor(107, 107, 107);
+	m_colorMap["gray43"] = QColor(110, 110, 110);
+	m_colorMap["grey43"] = QColor(110, 110, 110);
+	m_colorMap["gray44"] = QColor(112, 112, 112);
+	m_colorMap["grey44"] = QColor(112, 112, 112);
+	m_colorMap["gray45"] = QColor(115, 115, 115);
+	m_colorMap["grey45"] = QColor(115, 115, 115);
+	m_colorMap["gray46"] = QColor(117, 117, 117);
+	m_colorMap["grey46"] = QColor(117, 117, 117);
+	m_colorMap["gray47"] = QColor(120, 120, 120);
+	m_colorMap["grey47"] = QColor(120, 120, 120);
+	m_colorMap["gray48"] = QColor(122, 122, 122);
+	m_colorMap["grey48"] = QColor(122, 122, 122);
+	m_colorMap["gray49"] = QColor(125, 125, 125);
+	m_colorMap["grey49"] = QColor(125, 125, 125);
+	m_colorMap["gray50"] = QColor(127, 127, 127);
+	m_colorMap["grey50"] = QColor(127, 127, 127);
+	m_colorMap["gray51"] = QColor(130, 130, 130);
+	m_colorMap["grey51"] = QColor(130, 130, 130);
+	m_colorMap["gray52"] = QColor(133, 133, 133);
+	m_colorMap["grey52"] = QColor(133, 133, 133);
+	m_colorMap["gray53"] = QColor(135, 135, 135);
+	m_colorMap["grey53"] = QColor(135, 135, 135);
+	m_colorMap["gray54"] = QColor(138, 138, 138);
+	m_colorMap["grey54"] = QColor(138, 138, 138);
+	m_colorMap["gray55"] = QColor(140, 140, 140);
+	m_colorMap["grey55"] = QColor(140, 140, 140);
+	m_colorMap["gray56"] = QColor(143, 143, 143);
+	m_colorMap["grey56"] = QColor(143, 143, 143);
+	m_colorMap["gray57"] = QColor(145, 145, 145);
+	m_colorMap["grey57"] = QColor(145, 145, 145);
+	m_colorMap["gray58"] = QColor(148, 148, 148);
+	m_colorMap["grey58"] = QColor(148, 148, 148);
+	m_colorMap["gray59"] = QColor(150, 150, 150);
+	m_colorMap["grey59"] = QColor(150, 150, 150);
+	m_colorMap["gray60"] = QColor(153, 153, 153);
+	m_colorMap["grey60"] = QColor(153, 153, 153);
+	m_colorMap["gray61"] = QColor(156, 156, 156);
+	m_colorMap["grey61"] = QColor(156, 156, 156);
+	m_colorMap["gray62"] = QColor(158, 158, 158);
+	m_colorMap["grey62"] = QColor(158, 158, 158);
+	m_colorMap["gray63"] = QColor(161, 161, 161);
+	m_colorMap["grey63"] = QColor(161, 161, 161);
+	m_colorMap["gray64"] = QColor(163, 163, 163);
+	m_colorMap["grey64"] = QColor(163, 163, 163);
+	m_colorMap["gray65"] = QColor(166, 166, 166);
+	m_colorMap["grey65"] = QColor(166, 166, 166);
+	m_colorMap["gray66"] = QColor(168, 168, 168);
+	m_colorMap["grey66"] = QColor(168, 168, 168);
+	m_colorMap["gray67"] = QColor(171, 171, 171);
+	m_colorMap["grey67"] = QColor(171, 171, 171);
+	m_colorMap["gray68"] = QColor(173, 173, 173);
+	m_colorMap["grey68"] = QColor(173, 173, 173);
+	m_colorMap["gray69"] = QColor(176, 176, 176);
+	m_colorMap["grey69"] = QColor(176, 176, 176);
+	m_colorMap["gray70"] = QColor(179, 179, 179);
+	m_colorMap["grey70"] = QColor(179, 179, 179);
+	m_colorMap["gray71"] = QColor(181, 181, 181);
+	m_colorMap["grey71"] = QColor(181, 181, 181);
+	m_colorMap["gray72"] = QColor(184, 184, 184);
+	m_colorMap["grey72"] = QColor(184, 184, 184);
+	m_colorMap["gray73"] = QColor(186, 186, 186);
+	m_colorMap["grey73"] = QColor(186, 186, 186);
+	m_colorMap["gray74"] = QColor(189, 189, 189);
+	m_colorMap["grey74"] = QColor(189, 189, 189);
+	m_colorMap["gray75"] = QColor(191, 191, 191);
+	m_colorMap["grey75"] = QColor(191, 191, 191);
+	m_colorMap["gray76"] = QColor(194, 194, 194);
+	m_colorMap["grey76"] = QColor(194, 194, 194);
+	m_colorMap["gray77"] = QColor(196, 196, 196);
+	m_colorMap["grey77"] = QColor(196, 196, 196);
+	m_colorMap["gray78"] = QColor(199, 199, 199);
+	m_colorMap["grey78"] = QColor(199, 199, 199);
+	m_colorMap["gray79"] = QColor(201, 201, 201);
+	m_colorMap["grey79"] = QColor(201, 201, 201);
+	m_colorMap["gray80"] = QColor(204, 204, 204);
+	m_colorMap["grey80"] = QColor(204, 204, 204);
+	m_colorMap["gray81"] = QColor(207, 207, 207);
+	m_colorMap["grey81"] = QColor(207, 207, 207);
+	m_colorMap["gray82"] = QColor(209, 209, 209);
+	m_colorMap["grey82"] = QColor(209, 209, 209);
+	m_colorMap["gray83"] = QColor(212, 212, 212);
+	m_colorMap["grey83"] = QColor(212, 212, 212);
+	m_colorMap["gray84"] = QColor(214, 214, 214);
+	m_colorMap["grey84"] = QColor(214, 214, 214);
+	m_colorMap["gray85"] = QColor(217, 217, 217);
+	m_colorMap["grey85"] = QColor(217, 217, 217);
+	m_colorMap["gray86"] = QColor(219, 219, 219);
+	m_colorMap["grey86"] = QColor(219, 219, 219);
+	m_colorMap["gray87"] = QColor(222, 222, 222);
+	m_colorMap["grey87"] = QColor(222, 222, 222);
+	m_colorMap["gray88"] = QColor(224, 224, 224);
+	m_colorMap["grey88"] = QColor(224, 224, 224);
+	m_colorMap["gray89"] = QColor(227, 227, 227);
+	m_colorMap["grey89"] = QColor(227, 227, 227);
+	m_colorMap["gray90"] = QColor(229, 229, 229);
+	m_colorMap["grey90"] = QColor(229, 229, 229);
+	m_colorMap["gray91"] = QColor(232, 232, 232);
+	m_colorMap["grey91"] = QColor(232, 232, 232);
+	m_colorMap["gray92"] = QColor(235, 235, 235);
+	m_colorMap["grey92"] = QColor(235, 235, 235);
+	m_colorMap["gray93"] = QColor(237, 237, 237);
+	m_colorMap["grey93"] = QColor(237, 237, 237);
+	m_colorMap["gray94"] = QColor(240, 240, 240);
+	m_colorMap["grey94"] = QColor(240, 240, 240);
+	m_colorMap["gray95"] = QColor(242, 242, 242);
+	m_colorMap["grey95"] = QColor(242, 242, 242);
+	m_colorMap["gray96"] = QColor(245, 245, 245);
+	m_colorMap["grey96"] = QColor(245, 245, 245);
+	m_colorMap["gray97"] = QColor(247, 247, 247);
+	m_colorMap["grey97"] = QColor(247, 247, 247);
+	m_colorMap["gray98"] = QColor(250, 250, 250);
+	m_colorMap["grey98"] = QColor(250, 250, 250);
+	m_colorMap["gray99"] = QColor(252, 252, 252);
+	m_colorMap["grey99"] = QColor(252, 252, 252);
+	m_colorMap["gray100"] = QColor(255, 255, 255);
+	m_colorMap["grey100"] = QColor(255, 255, 255);
+	m_colorMap["darkgrey"] = QColor(169, 169, 169);
+	m_colorMap["darkgray"] = QColor(169, 169, 169);
+	m_colorMap["darkblue"] = QColor(0, 0, 139);
+	m_colorMap["darkcyan"] = QColor(0, 139, 139);
+	m_colorMap["darkmagenta"] = QColor(139, 0, 139);
+	m_colorMap["darkred"] = QColor(139, 0, 0);
+	m_colorMap["lightgreen"] = QColor(144, 238, 144);
+}
+
+/**
+ * Get a color by name
+ *
+ * The color name can be any Vim or Qt color including html #colors.
+ * Color names are case and space insensitive, i.e. "Dark Blue" 
+ * and "darkblue" are the same color.
+ *
+ */
+QColor ColorTable::get(const QString& name, const QColor& fallback)
+{
+	QString cname = name.toLower().remove(' ');
+	QColor c = m_instance.value(cname, QColor());
+	if ( !c.isValid() && cname != "transparent" ) {
+		c.setNamedColor(cname);
+	}
+
+	return c;
+}
+
+
diff -urN vim-src/src/qt/colortable.h vim-qt-src/src/qt/colortable.h
--- vim-src/src/qt/colortable.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/colortable.h	2012-08-23 19:26:45.000000000 +0200
@@ -0,0 +1,20 @@
+#ifndef VIM_QT_COLORTABLE
+#define VIM_QT_COLORTABLE
+
+#include <QColor>
+#include <QString>
+#include <QHash>
+
+class ColorTable: public QHash<QString, QColor>
+{
+public:
+	static QColor get(const QString& name, const QColor &fallback=QColor());
+
+protected:
+	ColorTable();
+	
+private:
+	static ColorTable m_instance;
+};
+
+#endif
diff -urN vim-src/src/qt/fontdialog.cpp vim-qt-src/src/qt/fontdialog.cpp
--- vim-src/src/qt/fontdialog.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/fontdialog.cpp	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,226 @@
+#include "fontdialog.moc"
+
+#include <QLineEdit>
+#include <QPushButton>
+#include <QFontDialog>
+
+// some of the style names which could indicate the "regular" one
+const QRegExp FontDialog::regular_rx = QRegExp("Regular|Normal|Book|Roman|Plain|Upright|Medium|Light|Sans");
+
+/**
+ * Custom font dialog
+ *
+ * This custom font selection dialog allows us to do
+ * things the regular one does not:
+ * - Enforce use of fixed-pitch fonts
+ * - Enforce the selected font style to "regular" style
+ *
+ *  ____________________________
+ * |         |       | Styles   |
+ * | Family  | Font  | ----     |
+ * |  List   | Sizes | Scripts  |
+ * |_________|_______|__________|
+ * |                            |
+ * |   Preview font text line   |
+ * |____________________________|
+ * |          OK/Cancel buttons |
+ * |____________________________|
+ *
+ * TODO:
+ *  - list non-scalable fonts after scalable
+ *  - remove the requirement to select size each time
+ * TODO?:
+ *  - allow translation of "Styles and Scripts"
+ *  - add preview of other styles
+ */
+
+
+FontDialog::FontDialog(QWidget *parent)
+:QDialog(parent)
+{
+	// 1. Initialize data holders
+	// fontDatabase is declared/initialized in the header file
+	regularStyle = "";      // to store the name of the "regular" style
+
+	// 2. Construct all widgets and layouts
+	vlayout  = new QVBoxLayout(this);     //top layout
+	hlayout  = new QHBoxLayout();           //inside vlayout
+	// font family and size lists (with selectable items)
+	fontList = new QListWidget(this);     //top sub-widget 1
+	sizeList = new QListWidget(this);     //top sub-widget 2
+
+	// style and writing info: three Labels wrapped in GroupBox and ScrollArea
+	scrollInfo   = new QScrollArea(this); //top sub-widget 3
+	groupboxInfo = new QGroupBox("Styles and Scripts", scrollInfo);
+	vlayoutInfo  = new QVBoxLayout(groupboxInfo);  //inside groupboxInfo
+
+	styleInfo     = new QLabel(groupboxInfo);
+	separatorInfo = new QLabel(groupboxInfo);
+	writingInfo   = new QLabel(groupboxInfo);
+
+	// font preview line
+	preview = new QLineEdit(this);        //top sub-widget 4
+	// dialog buttons
+	buttons = new QDialogButtonBox( QDialogButtonBox::Ok | QDialogButtonBox::Cancel, Qt::Horizontal, this);   //top sub-widget 5
+
+
+	// 3. Nest and connect widgets and layouts, set formatting details
+	// font family list
+	foreach (QString family, fontDatabase.families()) {
+		if ( fontDatabase.isFixedPitch(family) ) {
+			QListWidgetItem *item = new QListWidgetItem(fontList);
+			item->setText(family);
+		}
+	}
+	fontList->setMinimumWidth(80);  // to reduce stretching
+	connect(fontList, SIGNAL(itemSelectionChanged()),
+			this, SLOT(updateFonts()));
+	hlayout->addWidget(fontList,5);
+	// font size list (filled later in updateFonts())
+	sizeList->setMinimumWidth(40);  // to reduce stretching
+	sizeList->setMaximumWidth(60);
+	connect(sizeList, SIGNAL(itemSelectionChanged()),
+			this, SLOT(fontSelected()));
+	hlayout->addWidget(sizeList,1);
+	// font family info: styles, separator, scripts (see updateFonts())
+	// styles
+	styleInfo->setWordWrap(true);
+	styleInfo->setAlignment(Qt::AlignTop);
+	vlayoutInfo->addWidget(styleInfo);
+	// separator
+	separatorInfo->setFrameStyle(QFrame::HLine);
+	vlayoutInfo->addWidget(separatorInfo);
+	// scripts (writing systems)
+	writingInfo->setWordWrap(true);
+	vlayoutInfo->addWidget(writingInfo);
+	groupboxInfo->setLayout(vlayoutInfo);
+	scrollInfo->setWidget(groupboxInfo);
+	scrollInfo->setWidgetResizable(true);
+	scrollInfo->setFocusPolicy(Qt::NoFocus);
+	scrollInfo->setMinimumWidth(80);  // to reduce stretching
+	hlayout->addWidget(scrollInfo,5);
+	vlayout->addLayout(hlayout);
+	// font preview line
+	preview->setText("The quick brown fox jumps over the lazy dog");
+	preview->setAlignment(Qt::AlignCenter | Qt::AlignBottom);
+	preview->setEnabled(false);
+	preview->setMinimumHeight(40);  // to reduce vertical resizing
+	vlayout->addWidget(preview);
+	// dialog OK and Cancel buttons
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
+
+	connect( buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
+			this, SLOT(accept()));
+	connect( buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
+			this, SLOT(reject()));
+	vlayout->addWidget(buttons);
+
+	this->setLayout(vlayout);
+}
+
+/** update the list of sizes available for the given family
+ *  and the name of the "regular" style in regularStyle
+ *  and the styleInfo
+ */
+
+void FontDialog::updateFonts()
+{
+	sizeList->clear();
+
+	QString family;
+	if ( fontList->currentItem() == NULL ) {
+		return;
+	} else {
+		family = fontList->currentItem()->text();
+	}
+
+	QStringList styles = fontDatabase.styles(family);
+	// try to guess which of the styles is the "regular" one
+	//int match_idx = styles.indexOf(QRegExp("Regular|Normal|Book|Roman|Plain|Upright|Medium|Light|Sans"));
+	int match_idx = styles.indexOf(regular_rx);
+	regularStyle = match_idx == -1 ? styles.at(0) : styles.at(match_idx);
+
+	// offer sizes for the regular style
+	QList<int> fsizes = fontDatabase.smoothSizes(family, regularStyle);
+	if ( fsizes.isEmpty() ) {
+		fsizes = fontDatabase.pointSizes(family, regularStyle);
+	}
+	// or simply all sizes(?), if the above fails
+	if ( fsizes.isEmpty() ) {
+		fsizes = fontDatabase.standardSizes();
+	}
+
+	// fill the size list for the selected family
+	foreach ( int points, fsizes ) {
+		QListWidgetItem *item = new QListWidgetItem(sizeList);
+		item->setText(QString::number(points));
+	}
+
+	// scripts (writing systems) supported by the family
+	QString wsystems = "";
+	foreach ( const QFontDatabase::WritingSystem &writing, fontDatabase.writingSystems(family) ) {
+	    wsystems += fontDatabase.writingSystemName(writing) + ", ";
+	}
+	wsystems.chop(2);   // no trailing comma
+
+	// update the info widgets, buttons and preview
+	styleInfo->setText(styles.join("\n") );
+	writingInfo->setText(wsystems);
+
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(false);
+	preview->setEnabled(false);
+}
+
+void FontDialog::fontSelected()
+{
+	QListWidgetItem *currentF = fontList->currentItem();
+	QListWidgetItem *currentS = sizeList->currentItem();
+
+	if ( currentF == NULL || currentS == NULL ) {
+		return;
+	}
+
+	buttons->button(QDialogButtonBox::Ok)->setEnabled(true);
+
+	QFont f = fontDatabase.font( currentF->text(),
+			regularStyle, currentS->text().toInt());
+	preview->setFont(f);
+	preview->setEnabled(true);
+}
+
+QFont FontDialog::selectedFont()
+{
+	if ( fontList->currentItem() && sizeList->currentItem() ) {
+		return QFont( fontList->currentItem()->text(), sizeList->currentItem()->text().toInt() );
+	}
+
+	return QFont();
+}
+
+QFont FontDialog::getFont(bool *ok, const QFont& oldfont, QWidget *parent)
+{
+	FontDialog dialog;
+	dialog.selectCurrentFont(oldfont);
+
+	if ( dialog.exec() == QDialog::Accepted ) {
+		*ok = true;
+		return dialog.selectedFont();
+	}
+
+	*ok = false;
+	return QFont();
+}
+
+void FontDialog::selectCurrentFont(const QFont& f)
+{
+	QList<QListWidgetItem *> items = fontList->findItems(f.family(), Qt::MatchFixedString);
+	if ( items.size() > 0 ) {
+		fontList->setCurrentItem(items.at(0));
+
+		QList<QListWidgetItem *> sizeItems = sizeList->findItems(QString::number(f.pointSize()), Qt::MatchFixedString);
+		if ( sizeItems.size() > 0 ) {
+			sizeList->setCurrentItem(sizeItems.at(0));
+		}
+	}
+}
+
diff -urN vim-src/src/qt/fontdialog.h vim-qt-src/src/qt/fontdialog.h
--- vim-src/src/qt/fontdialog.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/fontdialog.h	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,48 @@
+#ifndef __VIM_QT_FONTDIALOG__
+#define __VIM_QT_FONTDIALOG__
+
+#include <QDialog>
+#include <QHBoxLayout>
+#include <QListWidget>
+#include <QFontDatabase>
+#include <QDialogButtonBox>
+#include <QScrollArea>
+#include <QGroupBox>
+#include <QLabel>
+
+class FontDialog: public QDialog
+{
+	Q_OBJECT
+public:
+	FontDialog(QWidget *parent=0);
+	QFont selectedFont();
+
+	static QFont getFont(bool *ok, const QFont &, QWidget *parent=0);
+	void selectCurrentFont(const QFont&);
+
+protected slots:
+	void updateFonts();
+	void fontSelected();
+
+private:
+	// layouts and widgets
+	QHBoxLayout   *hlayout;
+	QVBoxLayout   *vlayout;
+	QVBoxLayout   *vlayoutInfo;
+	QListWidget   *fontList;
+	QListWidget   *sizeList;
+	QDialogButtonBox *buttons;
+	QLineEdit     *preview;
+	QScrollArea   *scrollInfo;
+	QGroupBox     *groupboxInfo;
+	QLabel        *styleInfo;
+	QLabel        *writingInfo;
+	QLabel        *separatorInfo;
+	// data
+	QFontDatabase fontDatabase;
+	QString       regularStyle;
+	// constants
+	static const  QRegExp regular_rx;
+};
+
+#endif
Binary files vim-src/src/qt/icons/document-new.png and vim-qt-src/src/qt/icons/document-new.png differ
Binary files vim-src/src/qt/icons/document-open.png and vim-qt-src/src/qt/icons/document-open.png differ
Binary files vim-src/src/qt/icons/document-print.png and vim-qt-src/src/qt/icons/document-print.png differ
Binary files vim-src/src/qt/icons/document-save-all.png and vim-qt-src/src/qt/icons/document-save-all.png differ
Binary files vim-src/src/qt/icons/document-save-as.png and vim-qt-src/src/qt/icons/document-save-as.png differ
Binary files vim-src/src/qt/icons/document-save.png and vim-qt-src/src/qt/icons/document-save.png differ
Binary files vim-src/src/qt/icons/edit-copy.png and vim-qt-src/src/qt/icons/edit-copy.png differ
Binary files vim-src/src/qt/icons/edit-cut.png and vim-qt-src/src/qt/icons/edit-cut.png differ
Binary files vim-src/src/qt/icons/edit-find-replace.png and vim-qt-src/src/qt/icons/edit-find-replace.png differ
Binary files vim-src/src/qt/icons/edit-find.png and vim-qt-src/src/qt/icons/edit-find.png differ
Binary files vim-src/src/qt/icons/edit-paste.png and vim-qt-src/src/qt/icons/edit-paste.png differ
Binary files vim-src/src/qt/icons/edit-redo.png and vim-qt-src/src/qt/icons/edit-redo.png differ
Binary files vim-src/src/qt/icons/edit-undo.png and vim-qt-src/src/qt/icons/edit-undo.png differ
Binary files vim-src/src/qt/icons/folder-new.png and vim-qt-src/src/qt/icons/folder-new.png differ
Binary files vim-src/src/qt/icons/folder-open.png and vim-qt-src/src/qt/icons/folder-open.png differ
Binary files vim-src/src/qt/icons/go-jump.png and vim-qt-src/src/qt/icons/go-jump.png differ
Binary files vim-src/src/qt/icons/go-next.png and vim-qt-src/src/qt/icons/go-next.png differ
Binary files vim-src/src/qt/icons/go-previous.png and vim-qt-src/src/qt/icons/go-previous.png differ
Binary files vim-src/src/qt/icons/help-contents.png and vim-qt-src/src/qt/icons/help-contents.png differ
Binary files vim-src/src/qt/icons/help-faq.png and vim-qt-src/src/qt/icons/help-faq.png differ
Binary files vim-src/src/qt/icons/run-build-clean.png and vim-qt-src/src/qt/icons/run-build-clean.png differ
Binary files vim-src/src/qt/icons/run-build.png and vim-qt-src/src/qt/icons/run-build.png differ
Binary files vim-src/src/qt/icons/system-run.png and vim-qt-src/src/qt/icons/system-run.png differ
Binary files vim-src/src/qt/icons/tab-new.png and vim-qt-src/src/qt/icons/tab-new.png differ
Binary files vim-src/src/qt/icons/table.png and vim-qt-src/src/qt/icons/table.png differ
Binary files vim-src/src/qt/icons/utilities-terminal.png and vim-qt-src/src/qt/icons/utilities-terminal.png differ
Binary files vim-src/src/qt/icons/view-split-left-right.png and vim-qt-src/src/qt/icons/view-split-left-right.png differ
Binary files vim-src/src/qt/icons/view-split-top-bottom.png and vim-qt-src/src/qt/icons/view-split-top-bottom.png differ
Binary files vim-src/src/qt/icons/vim-qt.png and vim-qt-src/src/qt/icons/vim-qt.png differ
Binary files vim-src/src/qt/icons/window-close.png and vim-qt-src/src/qt/icons/window-close.png differ
Binary files vim-src/src/qt/icons/zoom-fit-height.png and vim-qt-src/src/qt/icons/zoom-fit-height.png differ
Binary files vim-src/src/qt/icons/zoom-fit-width.png and vim-qt-src/src/qt/icons/zoom-fit-width.png differ
diff -urN vim-src/src/qt/icons.qrc vim-qt-src/src/qt/icons.qrc
--- vim-src/src/qt/icons.qrc	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/icons.qrc	2012-06-20 16:40:38.000000000 +0200
@@ -0,0 +1,36 @@
+ <!DOCTYPE RCC><RCC version="1.0">
+ <qresource>
+     <file>icons/document-open.png</file>
+     <file>icons/document-save.png</file>
+     <file>icons/document-save-all.png</file>
+     <file>icons/document-print.png</file>
+     <file>icons/document-new.png</file>
+     <file>icons/edit-undo.png</file>
+     <file>icons/edit-redo.png</file>
+     <file>icons/edit-cut.png</file>
+     <file>icons/edit-copy.png</file>
+     <file>icons/edit-paste.png</file>
+     <file>icons/edit-find-replace.png</file>
+     <file>icons/edit-find.png</file>
+     <file>icons/go-next.png</file>
+     <file>icons/go-previous.png</file>
+     <file>icons/folder-open.png</file>
+     <file>icons/document-save-as.png</file>
+     <file>icons/folder-new.png</file>
+     <file>icons/run-build-clean.png</file>
+     <file>icons/run-build.png</file>
+     <file>icons/table.png</file>
+     <file>icons/go-jump.png</file>
+     <file>icons/help-contents.png</file>
+     <file>icons/help-faq.png</file>
+     <file>icons/vim-qt.png</file>
+     <file>icons/tab-new.png</file>
+     <file>icons/system-run.png</file>
+     <file>icons/view-split-left-right.png</file>
+     <file>icons/view-split-top-bottom.png</file>
+     <file>icons/window-close.png</file>
+     <file>icons/zoom-fit-height.png</file>
+     <file>icons/zoom-fit-width.png</file>
+     <file>icons/utilities-terminal.png</file>
+ </qresource>
+ </RCC>
diff -urN vim-src/src/qt/mainwindow.cpp vim-qt-src/src/qt/mainwindow.cpp
--- vim-src/src/qt/mainwindow.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/mainwindow.cpp	2014-03-25 19:44:30.528844476 +0100
@@ -0,0 +1,226 @@
+#include "mainwindow.moc"
+
+#include <QToolBar>
+#include <QMenuBar>
+#include <QEvent>
+
+MainWindow::MainWindow( gui_T* gui, QWidget *parent)
+:QMainWindow(parent), m_keepTabbar(false)
+{
+	setWindowIcon(QIcon(":/icons/vim-qt.png"));
+	setContextMenuPolicy(Qt::PreventContextMenu);
+
+	// Tool bar
+	toolbar = addToolBar("ToolBar");
+	toolbar->setObjectName("toolbar");
+
+	// Vim shell
+	vimshell = new QVimShell(this);
+
+	scrollarea = new ScrollArea(this);
+	scrollarea->setWidget(vimshell);
+	connect(vimshell, SIGNAL(backgroundColorChanged(QColor)),
+		scrollarea, SLOT(setBackgroundColor(QColor)) );
+
+	setCentralWidget(scrollarea);
+
+	// TabLine
+	tabtoolbar = addToolBar("tabline");
+	tabtoolbar->setObjectName("tabline");
+
+	connect( tabtoolbar, SIGNAL(orientationChanged(Qt::Orientation)),
+			this, SLOT(updateTabOrientation()) );
+	connect( tabtoolbar, SIGNAL(topLevelChanged(bool)),
+			this, SLOT(updateTabOrientation()));
+
+	tabbar = new TabBar(tabtoolbar);
+	tabbar->setTabsClosable(true);
+	tabbar->setExpanding(false);
+	tabbar->setFocusPolicy(Qt::NoFocus);
+	tabbar->setDrawBase(false);
+	tabbar->setMovable(true);
+	connect(tabbar, SIGNAL(tabMoved(int, int)),
+			this, SLOT(tabMoved(int, int)));
+
+
+	tabbar->addTab("VIM"); // One tab must always exist
+
+	tabtoolbar->addWidget(tabbar);
+	QAction *newTab = tabtoolbar->addAction( VimWrapper::icon("tab-new"), "New Tab");
+
+	connect( tabbar, SIGNAL(tabCloseRequested(int)),
+			this, SLOT(closeTab(int)));
+	connect( tabbar, SIGNAL(currentChanged(int)),
+			this, SLOT(switchTab(int)));
+	connect( newTab, SIGNAL(triggered()),
+			this, SLOT(openNewTab()));
+
+
+	vimshell->setFocus();
+}
+
+void MainWindow::tabMoved(int from, int to)
+{
+	//
+	// 1. In some cases Qt will not drag the tab you expect
+	// for example if you have two tabs (1,2) and drag 
+	// tab 1 to place 2 -> Qt might trigger the reverse
+	// event i.e. move tab 2 to place 1
+	//
+	// 2. It also seems that QTabbar::currentIndex() always 
+	// returns the current tab, i.e. after the movement event
+	// it returns the destination position - which is exactly
+	// what we want.
+	//
+	// 3. Also, both tabpage_move and Qt use 0-indexed tab positions
+	//
+
+	tabpage_move(tabbar->currentIndex());
+}
+
+void MainWindow::updateTabOrientation()
+{
+
+	if ( tabtoolbar->orientation() == Qt::Horizontal ) {
+		if ( toolBarArea(tabtoolbar) == Qt::BottomToolBarArea ) {
+			tabbar->setShape( QTabBar::RoundedSouth );
+		} else {
+			tabbar->setShape( QTabBar::RoundedNorth );
+		}
+	} else {
+		if ( toolBarArea(tabtoolbar) == Qt::LeftToolBarArea ) {
+			tabbar->setShape( QTabBar::RoundedWest );
+		} else {
+			tabbar->setShape( QTabBar::RoundedEast );
+		}
+	}
+
+	if ( tabtoolbar->isFloating() ) {
+		tabtoolbar->resize(tabtoolbar->minimumWidth(), tabtoolbar->sizeHint().height());
+	}
+}
+
+bool MainWindow::restoreState(const QByteArray& state, int version)
+{
+	bool ret = QMainWindow::restoreState(state, version);
+	if ( keepTabbar() ) {
+		showTabline(true);
+	}
+
+	return ret;
+}
+
+QVimShell* MainWindow::vimShell()
+{
+	return this->vimshell;
+}
+
+QToolBar* MainWindow::toolBar() const
+{
+	return toolbar;
+}
+
+void MainWindow::closeEvent (QCloseEvent * event)
+{
+	vimshell->closeEvent(event);
+}
+
+void MainWindow::changeEvent( QEvent *ev)
+{
+	if (ev->type() == QEvent::WindowStateChange) {
+		VimWrapper::setFullscreen( windowState() & Qt::WindowFullScreen );
+
+		if ( ! (windowState() & Qt::WindowFullScreen) ) {
+			// Reset vimshell size policy when leaving fullscreen
+			vimshell->setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
+			vimshell->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+			vimshell->updateGeometry();
+		}
+	}
+	QMainWindow::changeEvent(ev);
+}
+
+void MainWindow::showTabline(bool show)
+{
+	// VIM never removes the second tab,
+	// instead it hides the entire tab bar
+	if ( keepTabbar() && !show ) {
+		removeTabs(1);
+	}
+
+	if ( keepTabbar() ) {
+		tabtoolbar->setVisible(true);
+	} else {
+		tabtoolbar->setVisible(show);
+	}
+}
+
+void MainWindow::showToolbar(bool show)
+{
+	toolbar->setVisible(show);
+}
+
+void MainWindow::showMenu(bool show)
+{
+	QMainWindow::menuBar()->setVisible(show);
+}
+
+bool MainWindow::tablineVisible()
+{
+	return tabtoolbar->isVisible();
+}
+
+void MainWindow::setCurrentTab(int idx)
+{
+	tabbar->setCurrentIndex(idx);
+}
+
+void MainWindow::setTab( int idx, const QString& label)
+{
+	while ( tabbar->count() <= idx ) {
+		tabbar->addTab("[No name]");
+	}
+
+	tabbar->setTabText(idx, label);
+}
+
+
+void MainWindow::removeTabs(int idx)
+{
+	int i;
+	for ( i=idx; i<tabbar->count(); i++) {
+		tabbar->removeTab(i);
+	}
+}
+
+void MainWindow::switchTab(int idx)
+{
+	vimshell->switchTab(idx+1);
+}
+
+void MainWindow::closeTab(int idx)
+{
+	if ( keepTabbar() && tabbar->count() == 1 ) {
+		vimshell->close();
+	} else {
+		vimshell->closeTab(idx+1);
+	}
+}
+
+void MainWindow::openNewTab()
+{
+	// The amusing +1 trick opens the
+	// tab at the right of other tabs
+	VimWrapper::newTab(tabbar->count()+1);
+}
+
+void MainWindow::setKeepTabbar(bool keep)
+{
+	m_keepTabbar = keep;
+}
+
+bool MainWindow::keepTabbar()
+{
+	return m_keepTabbar;
+}
+
diff -urN vim-src/src/qt/mainwindow.h vim-qt-src/src/qt/mainwindow.h
--- vim-src/src/qt/mainwindow.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/mainwindow.h	2014-03-25 19:44:30.528844476 +0100
@@ -0,0 +1,57 @@
+#ifndef __GUI_QT_MAINWINDOW__
+#define __GUI_QT_MAINWINDOW__
+
+#include <QMainWindow>
+#include "qvimshell.h"
+#include "tabbar.h"
+#include "scrollarea.h"
+
+
+class MainWindow: public QMainWindow
+{
+	Q_OBJECT
+	Q_PROPERTY(bool m_keepTabbar READ keepTabbar WRITE setKeepTabbar )
+public:
+	MainWindow(gui_T *, QWidget *parent=0);
+	QVimShell* vimShell();
+
+	bool tablineVisible();
+
+	QToolBar* toolBar() const;
+	bool keepTabbar();
+
+	bool restoreState(const QByteArray& state, int version=0);
+
+public slots:
+	void showTabline(bool show);
+	void showMenu(bool show);
+	void showToolbar(bool show);
+	void setCurrentTab(int idx);
+	void setTab( int, const QString& );
+	void removeTabs(int);
+	void switchTab(int idx);
+	void closeTab(int idx);
+	void setKeepTabbar(bool);
+	void openNewTab();
+
+protected:
+	virtual void closeEvent( QCloseEvent *);
+	virtual void changeEvent( QEvent *ev );
+
+protected slots:
+	void updateTabOrientation();
+	void tabMoved(int from, int to);
+
+private:
+	QToolBar *toolbar;
+
+	ScrollArea *scrollarea;
+	QVimShell *vimshell;
+	QToolBar *tabtoolbar;
+	TabBar *tabbar;
+	
+
+	bool m_keepTabbar;
+};
+
+#endif
diff -urN vim-src/src/qt/qt_features.h vim-qt-src/src/qt/qt_features.h
--- vim-src/src/qt/qt_features.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qt_features.h	2012-04-05 17:31:22.000000000 +0200
@@ -0,0 +1,20 @@
+
+//
+// Feature defines for the Vim-Qt Gui
+// :Lets try to stay away from the core Vim code, shall we :D
+//
+// The only features that are moved here are those that are stricty dependent
+// on the GUI
+//
+
+#define FEAT_TOOLBAR
+#define FEAT_GUI_TABLINE
+#define FEAT_BROWSE
+#define FEAT_DND
+#define FEAT_MOUSESHAPE
+#define FEAT_SIGN_ICONS
+#define FEAT_FULLSCREEN
+
+
+#undef HAVE_X11
+
diff -urN vim-src/src/qt/qvimshell.cpp vim-qt-src/src/qt/qvimshell.cpp
--- vim-src/src/qt/qvimshell.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qvimshell.cpp	2014-03-25 19:44:30.529844485 +0100
@@ -0,0 +1,735 @@
+#include "qvimshell.moc"
+
+#include <QResizeEvent>
+#include <QPainter>
+#include <QApplication>
+#include <QDebug>
+#include <QFile>
+#include <QTimer>
+#include <QMimeData>
+
+extern "C" {
+#include "proto/gui.pro"
+}
+
+#include "colortable.h"
+
+QVimShell::QVimShell(QWidget *parent)
+:QWidget(parent), m_encoding_utf8(true),
+	m_lastClickEvent(-1), m_tooltip(0), m_slowStringDrawing(false),
+	m_mouseHidden(false)
+{
+	setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+
+	// cursor blinking
+	timer_cursorBlinkOn = new QTimer();
+	timer_cursorBlinkOff = new QTimer();
+	timer_firstOff = new QTimer();
+	timer_firstOn = new QTimer();
+	timer_firstOn->setSingleShot(true);
+	timer_firstOff->setSingleShot(true);
+	blinkState = BLINK_NONE;
+	connect(timer_cursorBlinkOn, SIGNAL(timeout()), this, SLOT(cursorOn()));
+	connect(timer_firstOn, SIGNAL(timeout()), this, SLOT(startBlinkOnTimer()));
+	connect(timer_firstOff, SIGNAL(timeout()), this, SLOT(startBlinkOffTimer()));
+	connect(timer_cursorBlinkOff, SIGNAL(timeout()), this, SLOT(cursorOff()));
+
+	// IM Tooltip
+	m_tooltip = new QLabel(this);
+	m_tooltip->setVisible(false);
+	m_tooltip->setTextFormat(Qt::PlainText);
+	m_tooltip->setTextInteractionFlags(Qt::NoTextInteraction);
+	m_tooltip->setAutoFillBackground(true);
+
+	// Widget Attributes
+	setAttribute(Qt::WA_KeyCompression, false);
+	setAttribute(Qt::WA_InputMethodEnabled, true);
+	setAttribute(Qt::WA_OpaquePaintEvent, true);
+	setAttribute(Qt::WA_StaticContents, true);
+	setAcceptDrops(true);
+	setMouseTracking(true);
+
+	PaintOperation op;
+	op.type = CLEARALL;
+	op.color = background();
+	queuePaintOp(op);
+}
+
+void QVimShell::setBackground(const QColor color)
+{
+	m_background = color;
+	emit backgroundColorChanged(m_background);
+}
+
+void QVimShell::switchTab(int idx)
+{
+	sendTablineEvent(idx);
+}
+
+void QVimShell::closeTab(int idx)
+{
+	sendTablineMenuEvent(idx, TABLINE_MENU_CLOSE);
+}
+
+
+QColor QVimShell::background()
+{
+	return m_background;
+}
+
+void QVimShell::resizeEvent(QResizeEvent *ev)
+{
+	PaintOperation op;
+	op.type = FILLRECT;
+	op.color = background();
+
+	int dWidth = ev->size().width() - ev->oldSize().width();
+	if (dWidth > 0)
+	{
+		op.rect = QRect(ev->oldSize().width(), 0, dWidth, ev->size().height());
+		queuePaintOp(op);
+	}
+
+	int dHeight = ev->size().height() - ev->oldSize().height();
+	if (dHeight > 0)
+	{
+		op.rect = QRect(0, ev->oldSize().height(), ev->size().width(), dHeight);
+		queuePaintOp(op);
+	}
+
+	//
+	// Vim might trigger another resize, postpone the call
+	// to guiResizeShell - otherwise we might be called
+	// recursivelly and crash
+	//
+	postGuiResizeShell(ev->size().width(), ev->size().height());
+}
+
+int_u QVimShell::vimKeyboardModifiers(Qt::KeyboardModifiers mod)
+{
+	int_u vim = 0x00;
+
+	if ( mod & Qt::ShiftModifier ) {
+		vim |= MOD_MASK_SHIFT;
+	} 
+	if ( mod & Qt::ControlModifier ) {
+		vim |= MOD_MASK_CTRL;
+	}
+	if ( mod & Qt::AltModifier ) {
+		vim |= MOD_MASK_ALT;
+	}
+
+	return vim;
+}
+
+int_u QVimShell::vimMouseModifiers(Qt::KeyboardModifiers mod)
+{
+	int_u vim = 0x00;
+
+	if ( mod & Qt::ShiftModifier ) {
+		vim |= MOUSE_SHIFT;
+	} 
+	if ( mod & Qt::ControlModifier ) {
+		vim |= MOUSE_CTRL;
+	}
+	if ( mod & Qt::AltModifier ) {
+		vim |= MOUSE_ALT;
+	}
+
+	return vim;
+}
+
+
+
+void QVimShell::keyPressEvent ( QKeyEvent *ev)
+{
+	// mousehide - conceal mouse pointer when typing
+	if (p_mh && !m_mouseHidden ) {
+		QApplication::setOverrideCursor(Qt::BlankCursor);
+		m_mouseHidden = true;
+	}
+
+	int key_char = 0;
+	int vimModifiers = vimKeyboardModifiers(QApplication::keyboardModifiers());
+	if ( !ev->text().isEmpty() ) {
+		key_char = ev->text()[0].unicode(); // key compression is off
+	}
+
+	/* Find the special key */
+	int i;
+	bool isSpecial = false;
+	for (i = 0; special_keys[i].key_sym != 0; ++i) {
+		if (special_keys[i].key_sym == ev->key())
+		{
+
+			if (special_keys[i].code1 == NUL) {
+				key_char = special_keys[i].code0;
+			} else {
+				key_char = TO_SPECIAL(special_keys[i].code0, special_keys[i].code1);
+				key_char = simplify_key(key_char,
+					(int *)&vimModifiers);
+				isSpecial = TRUE;
+			}
+			break;
+		}
+	}
+
+	if ( key_char == 0 ) {
+		return;
+	}
+
+	/* TODO: Intercept CMD-. and CTRL-c ?*/
+
+	//
+	// For the most part this is same code as the one found in gui_mac.c, plus our
+	// additional special keys bits, I've also kept the original comments because I
+	// find them informative and slightly amusing
+	//
+	if (!isSpecial)
+	{
+		/* remove SHIFT for keys that are already shifted, e.g.,
+		 * '(' and '*' */
+		if (key_char < 0x100 && !isalpha(key_char) && isprint(key_char)) {
+			vimModifiers &= ~MOD_MASK_SHIFT;
+		}
+
+		/* remove CTRL from keys that already have it */
+		if (key_char < 0x20) {
+			vimModifiers &= ~MOD_MASK_CTRL;
+		}
+
+		/* don't process unicode characters here */
+		if (!IS_SPECIAL(key_char)) {
+			/* Following code to simplify and consolidate vimModifiers
+			 * taken liberally from gui_w48.c */
+			key_char = simplify_key(key_char, (int *)&vimModifiers);
+
+			/* Interpret META, include SHIFT, etc. */
+			key_char = extract_modifiers(key_char, (int *)&vimModifiers);
+			if (key_char == CSI) {
+				key_char = K_CSI;
+			}
+
+			if (IS_SPECIAL(key_char)) {
+				isSpecial = TRUE;
+			}
+		}
+	}
+
+	char_u result[3];
+	if (vimModifiers) {
+		result[0] = CSI;
+		result[1] = KS_MODIFIER;
+		result[2] = vimModifiers;
+		add_to_input_buf(result, 3);
+	}
+
+	if (isSpecial && IS_SPECIAL(key_char)) {
+		result[0] = CSI;
+		result[1] = K_SECOND(key_char);
+		result[2] = K_THIRD(key_char);
+		add_to_input_buf(result, 3);
+	} else {
+		QByteArray utf8 = QString(QChar(key_char)).toUtf8();
+		add_to_input_buf_csi( (char_u *) utf8.data(), utf8.size());
+	}
+}
+
+void QVimShell::close()
+{
+	guiShellClosed();
+}
+
+void QVimShell::closeEvent(QCloseEvent *event)
+{
+	close();
+	event->ignore();
+}
+
+/*
+ * @Deprecated
+ *
+ * Either by sheer absurdity or font substitution magic, some
+ * monospace fonts end up having different widths for each
+ * style (regular, bold, etc). This causes text painting to
+ * misspaint - particularly when painting a selection -  because
+ * the text will be too wide to fit in its place..
+ *
+ * This obscure piece of code tries to find a pointSize for the
+ * same font that respects the monospace char width. Hopefully
+ * you have a decent monospace font and this is never called!!
+ *
+ */
+QFont QVimShell::fixPainterFont( const QFont& pfont )
+{
+	QFontMetrics fm(pfont);
+
+	if ( fm.averageCharWidth() != charWidth() ) {
+		qDebug() << __func__ << "Font size mismatch a.k.a. this is not a proper monospace font";
+
+		int V = (fm.averageCharWidth() > charWidth() ) ? -1 :1;
+		int newsize;
+
+		QFont f1 = pfont;
+		newsize = f1.pointSize()-V;
+
+		if ( newsize < 0 ) {
+			return pfont;
+		}
+		f1.setPointSize(newsize);
+		QFontMetrics fm1(f1);
+
+		float wdiff = ((float)fm1.averageCharWidth() - fm.averageCharWidth())*V;
+		int pt = (fm.averageCharWidth() - charWidth())/wdiff;
+
+		QFont f = pfont;
+		newsize = f.pointSize()+pt;
+		if ( newsize < 0 ) {
+			return pfont;
+		}
+		f.setPointSize(newsize);
+
+		return f;
+	}
+
+	return pfont;
+}
+
+/*
+ * Slow text painting strategy
+ *
+ * - Paints one character at a time
+ * - Looks perfect in any condition
+ * - Takes a looong time
+ * - FIXME: add support for proper undercurl
+ */
+void QVimShell::drawStringSlow( const PaintOperation& op, QPainter &painter )
+{
+	QFont f = op.font;
+	painter.setFont(f);
+	painter.setPen( op.color );
+
+	QRect rect = op.rect;
+	foreach(QChar c, op.str) {
+		if ( VimWrapper::charCellWidth(c) == 1 ) {
+			rect.setWidth(VimWrapper::charWidth());
+		} else if (VimWrapper::charCellWidth(c) == 2) {
+			rect.setWidth(2*VimWrapper::charWidth());
+		} else {
+			qDebug() << __func__ << "invalid lenght" << c << VimWrapper::charCellWidth(c);
+			continue;
+		}
+
+		QPoint pos = op.pos;
+		pos.setX(rect.left());
+		painter.drawText(pos, c);
+		rect.moveTo( rect.x() + rect.width(), rect.y() );
+	}
+}
+
+/**
+ * Draw a string into the canvas
+ *
+ */
+void QVimShell::drawString( const PaintOperation& op, QPainter &painter)
+{
+	painter.setPen( op.color );
+	painter.setFont(op.font);
+	painter.drawText( op.pos, op.str);
+}
+
+void QVimShell::paintEvent ( QPaintEvent *ev )
+{
+	QPainter painter(this);
+	while ( !paintOps.isEmpty() ) {
+		painter.save();
+
+		PaintOperation op = paintOps.dequeue();
+		switch( op.type ) {
+		case CLEARALL:
+			painter.fillRect(this->rect(), op.color);
+			break;
+		case FILLRECT:
+			painter.fillRect(op.rect, op.color);
+			break;
+		case DRAWRECT:
+			painter.setPen(op.color);
+			painter.drawRect(op.rect);
+			break;
+		case DRAWSTRING:
+			painter.setClipRect(op.rect);
+
+			// Disable underline if undercurl is in place
+			if (op.undercurl && op.font.underline()) {
+				op.font.setUnderline(false);
+			}
+
+			if ( m_slowStringDrawing ) {
+				drawStringSlow(op, painter);
+			} else if ( op.str.length() != VimWrapper::stringCellWidth(op.str) ) {
+				drawStringSlow(op, painter);
+			} else {
+				drawString(op, painter);
+			}
+
+			// Draw undercurl
+			// FIXME: we are doing it wrong - the underlinePos needs
+			// to be stored someplace else
+			if (op.undercurl) {
+				QPoint start(op.rect.bottomLeft());
+				start.setY(op.pos.y() + 1 + gui.char_ul_pos );
+				QPoint end(start);
+				end.setX(op.rect.right());
+
+				QPen pen(op.curlcolor, 1, Qt::DashDotDotLine);
+				painter.setPen(pen);
+				painter.drawLine(QLine(start, end));
+			}
+
+			break;
+		case DRAWSIGN:
+			painter.drawPixmap( op.pos, op.sign);
+			break;
+		case INVERTRECT:
+			painter.setCompositionMode( QPainter::RasterOp_SourceXorDestination );
+			painter.fillRect( op.rect, Qt::color0);
+			painter.setCompositionMode( QPainter::CompositionMode_SourceOver );
+			break;
+		case SCROLLRECT:
+			painter.restore();
+			painter.end();
+
+			this->scroll(op.pos.x(), op.pos.y(), op.rect);
+
+			painter.begin(this);
+
+			// Repaint exposed background. Vim won't redraw areas exposed by
+			// scroll if it considers them empty because it assumes we already
+			// cleared that area of the screen.
+			QRect rect;
+			rect.setWidth(op.rect.width());
+			rect.setHeight(abs(op.pos.y()));
+			if (op.pos.y() > 0)
+				rect.moveTopLeft(op.rect.topLeft());
+			else
+				rect.moveBottomRight(op.rect.bottomRight());
+			painter.fillRect(rect, op.color);
+
+			continue; // exception, skip painter restore
+		}
+
+		painter.restore();
+	}
+}
+
+//
+// Mouse events
+// FIXME: not handling modifiers
+
+void QVimShell::mouseMoveEvent(QMouseEvent *ev)
+{
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	if ( ev->buttons() ) {
+		int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+		guiSendMouseEvent(MOUSE_DRAG, ev->pos().x(),
+					  ev->pos().y(), FALSE, vmod);
+	} else {
+		guiMouseMoved(ev->pos().x(), ev->pos().y());
+	}
+}
+
+void QVimShell::mousePressEvent(QMouseEvent *ev)
+{
+	int but;
+
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	if ( !hasFocus() ) {
+		setFocus(Qt::MouseFocusReason);
+	}
+
+	switch( ev->button() ) {
+	case Qt::LeftButton:
+		but = MOUSE_LEFT;
+		break;
+	case Qt::RightButton:
+		but = MOUSE_RIGHT;
+		break;
+	case Qt::MidButton:
+		but = MOUSE_MIDDLE;
+		break;
+	default:
+		return;
+	}
+
+	int repeat=0;
+
+	if ( !m_lastClick.isNull() 
+		&& m_lastClick.elapsed() < QApplication::doubleClickInterval() 
+		&& m_lastClickEvent == ev->button() ) {
+		repeat = 1;
+	}
+
+	m_lastClick.restart();
+	m_lastClickEvent = ev->button();
+
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+
+	guiSendMouseEvent(but, ev->pos().x(),
+					  ev->pos().y(), repeat, vmod);
+}
+
+void QVimShell::mouseReleaseEvent(QMouseEvent *ev)
+{
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+	guiSendMouseEvent(MOUSE_RELEASE, ev->pos().x(),
+					  ev->pos().y(), FALSE, vmod);
+}
+
+void QVimShell::wheelEvent(QWheelEvent *ev)
+{
+	int_u vmod = vimMouseModifiers(QApplication::keyboardModifiers());
+	guiSendMouseEvent((ev->delta() > 0) ? MOUSE_4 : MOUSE_5,
+					    ev->pos().x(), ev->pos().y(), FALSE, vmod);
+}
+
+/**
+ * Get a color by name
+ *
+ * The color name can be any Vim or Qt color including html #colors.
+ * Color names are case and space insensitive, i.e. "Dark Blue" 
+ * and "darkblue" are the same color.
+ *
+ */
+QColor QVimShell::color(const QString& name)
+{
+	QString cname = name.toLower().remove(' ');
+	QColor c = ColorTable::get(cname, QColor());
+	if ( !c.isValid() && cname != "transparent" ) {
+		c.setNamedColor(cname);
+	}
+
+	return c;
+}
+
+void QVimShell::queuePaintOp(PaintOperation op)
+{
+	paintOps.enqueue(op);
+	if ( op.rect.isValid() ) {
+		update(op.rect);
+	} else {
+		update();
+	}
+}
+
+void QVimShell::setEncodingUtf8(bool enabled)
+{
+	m_encoding_utf8 = enabled;
+}
+
+void QVimShell::dragEnterEvent(QDragEnterEvent *ev)
+{
+	if ( ev->mimeData()->hasFormat("text/uri-list") ||
+		ev->mimeData()->hasFormat("text/html") ||
+		ev->mimeData()->hasFormat("UTF8_STRING") ||
+		ev->mimeData()->hasFormat("STRING") ||
+	  	ev->mimeData()->hasFormat("text/plain") ) {
+		ev->acceptProposedAction();
+	}
+}
+
+void QVimShell::dropEvent(QDropEvent *ev)
+{
+
+	if ( ev->mimeData()->hasFormat("text/uri-list") ) {
+		QList<QUrl> urls = ev->mimeData()->urls();
+		if ( urls.size() == 0 ) {
+			return;
+		}
+		guiHandleDrop(ev->pos(), 0, urls);
+
+	} else {
+		guiHandleDropText(ev->mimeData()->text());
+	}
+	ev->acceptProposedAction();
+}
+
+void QVimShell::focusInEvent(QFocusEvent *ev)
+{
+	// mousehide - show mouse pointer
+	restoreCursor();
+
+	guiFocusChanged(TRUE);
+	QWidget::focusInEvent(ev);
+	update();
+}
+
+void QVimShell::leaveEvent(QEvent *ev)
+{
+	restoreCursor();
+	QWidget::leaveEvent(ev);
+}
+
+void QVimShell::enterEvent(QEvent *ev)
+{
+	restoreCursor();
+	QWidget::leaveEvent(ev);
+}
+
+void QVimShell::focusOutEvent(QFocusEvent *ev)
+{
+	guiFocusChanged(FALSE);
+	QWidget::focusOutEvent(ev);
+	update();
+}
+
+bool QVimShell::focusNextPrevChild(bool next)
+{
+	return false;
+}
+
+void QVimShell::setCharWidth(int w)
+{
+	m_charWidth = w;
+}
+
+int QVimShell::charWidth()
+{
+	return m_charWidth;
+}
+
+void QVimShell::inputMethodEvent(QInputMethodEvent *ev)
+{
+	if ( !ev->commitString().isEmpty() ) {
+		QByteArray s = VimWrapper::convertTo(ev->commitString());
+		add_to_input_buf_csi( (char_u *) s.data(), s.size() );
+		tooltip("");
+	} else {
+		tooltip( ev->preeditString());
+	}
+}
+
+QVariant QVimShell::inputMethodQuery(Qt::InputMethodQuery query) const
+{
+	if ( query == Qt::ImFont) {
+		return font();
+	} else if ( query == Qt::ImMicroFocus ) {
+		return QRect(VimWrapper::cursorPosition(), QSize(0, charHeight()));
+	}
+
+	return QVariant();
+}
+
+/*
+ * Display a tooltip over the shell, covering underlying shell content.
+ * The tooltip is placed at the current shell cursor position.
+ *
+ * When the given string is empty the tooltip is concealed.
+ *
+ * FIXME: Colors could use improving
+ */
+void QVimShell::tooltip(const QString& text)
+{
+	m_tooltip->setText(text);
+	if ( text.isEmpty() ) {
+		m_tooltip->hide();
+		return;
+	}
+
+	if ( !m_tooltip->isVisible() ) {
+		m_tooltip->setMinimumHeight(VimWrapper::charHeight());
+		m_tooltip->move( VimWrapper::cursorPosition() );
+		m_tooltip->show();
+	}
+
+	m_tooltip->setMinimumWidth( QFontMetrics(m_tooltip->font()).width(text) );
+	m_tooltip->setMaximumWidth( QFontMetrics(m_tooltip->font()).width(text) );
+	m_tooltip->update();
+}
+
+/*
+ * If the cursor is invisible, make it visible again
+ *
+ */
+void QVimShell::restoreCursor()
+{
+	QCursor *cursor = QApplication::overrideCursor();
+
+	if ( cursor && m_mouseHidden ) {
+		QApplication::restoreOverrideCursor();
+		m_mouseHidden = false;
+	}
+}
+
+
+void QVimShell::setBlinkTime(const long waittime, const long ontime, const long offtime)
+{
+	m_blinkWaitTime = waittime;
+	m_blinkOnTime = ontime;
+	m_blinkOffTime = offtime;
+}
+
+/*
+ * start blinking: show cursor for waitingtime then blink
+ */
+void QVimShell::startBlinking()
+{
+	if (m_blinkWaitTime && m_blinkOnTime && m_blinkOffTime && hasFocus())
+	{
+		// wait waitTime before starting the blink
+		timer_cursorBlinkOn->stop();
+		timer_cursorBlinkOff->stop();
+		timer_firstOff->stop();
+		timer_firstOn->stop();
+
+		timer_firstOff->start(m_blinkWaitTime);
+		cursorOn();
+	}
+}
+
+void QVimShell::startBlinkOnTimer()
+{
+	if (blinkState == BLINK_OFF) // if blinkstate == NONE do nothing
+	{
+		timer_cursorBlinkOn->start(m_blinkOnTime+m_blinkOffTime);
+		cursorOn();
+	}
+}
+
+void QVimShell::startBlinkOffTimer()
+{
+	if (blinkState == BLINK_ON) // if blinkstate == NONE do nothing
+	{
+		timer_firstOn->start(m_blinkOffTime);
+		timer_cursorBlinkOff->start(m_blinkOnTime+m_blinkOffTime);
+		cursorOff();
+	}
+}
+
+
+/*
+ * Stop cursor blinking
+ */
+void QVimShell::stopBlinking()
+{
+	blinkState = BLINK_NONE;
+	timer_cursorBlinkOn->stop();
+	timer_cursorBlinkOff->stop();
+	timer_firstOn->stop();
+	timer_firstOff->stop();
+}
+
+void QVimShell::cursorOff()
+{
+	blinkState = BLINK_OFF;
+	undrawCursor();
+}
+
+void QVimShell::cursorOn()
+{
+	blinkState = BLINK_ON;
+	updateCursor(true, false);
+}
diff -urN vim-src/src/qt/qvimshell.h vim-qt-src/src/qt/qvimshell.h
--- vim-src/src/qt/qvimshell.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/qvimshell.h	2014-03-25 19:44:30.529844485 +0100
@@ -0,0 +1,184 @@
+#ifndef __QVIMSHELL__
+#define __QVIMSHELL__
+
+#include <QWidget>
+#include <QQueue>
+#include <QLabel>
+#include <QTime>
+#include "vimwrapper.h"
+
+
+class QVimShell: public QWidget, public VimWrapper
+{
+	Q_OBJECT
+	Q_ENUMS(PaintOperationType)
+public:
+	enum PaintOperationType { CLEARALL=0, FILLRECT, DRAWSTRING, DRAWRECT, INVERTRECT, SCROLLRECT, DRAWSIGN};
+	class PaintOperation {
+	public:
+		enum QVimShell::PaintOperationType type;
+		QRect rect;
+		QColor color;
+		// DRAWSTRING
+		QFont font;
+		QString str;
+		bool undercurl;
+		QColor curlcolor;
+		// SIGN
+		QPixmap sign;
+		// SCROLL
+		QPoint pos;
+	};
+
+	QVimShell(QWidget *parent=0);
+
+	bool hasInput();
+	static QColor color(const QString&);
+
+	void queuePaintOp(PaintOperation);
+
+	QColor background();
+	int charWidth();
+
+	void setEncodingUtf8(bool);
+	virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;
+	void setSlowStringDrawing(bool slow) {m_slowStringDrawing = slow;}
+
+	void setBlinkTime(const long waittime, const long ontime, const long offtime);
+
+	void stopBlinking();
+	void startBlinking();
+
+
+public slots:
+	void setBackground(const QColor);
+	void setCharWidth(int);
+
+	void close();
+	virtual void closeEvent(QCloseEvent *event);
+
+	void switchTab(int idx);
+	void closeTab(int idx);
+
+signals:
+	void backgroundColorChanged(const QColor&);
+
+protected:
+	void resizeEvent(QResizeEvent *);
+	void keyPressEvent ( QKeyEvent *);
+	virtual void mouseMoveEvent(QMouseEvent *event);
+	virtual void mousePressEvent(QMouseEvent *event);
+	virtual void mouseReleaseEvent(QMouseEvent *event);
+	virtual void wheelEvent(QWheelEvent *event );
+	virtual void inputMethodEvent(QInputMethodEvent *event);
+	virtual void focusInEvent(QFocusEvent *);
+	virtual void focusOutEvent(QFocusEvent *);
+
+	virtual void paintEvent( QPaintEvent *);
+
+	QFont fixPainterFont(const QFont &);
+	void drawString(const PaintOperation&, QPainter& );
+	void drawStringSlow( const PaintOperation&, QPainter &painter );
+
+
+	int_u vimKeyboardModifiers(Qt::KeyboardModifiers);
+	int_u vimMouseModifiers(Qt::KeyboardModifiers);
+
+	void dragEnterEvent(QDragEnterEvent *);
+	void dropEvent(QDropEvent *);
+
+	void tooltip(const QString& );
+	void restoreCursor();
+
+	virtual void leaveEvent(QEvent *ev);
+	virtual void enterEvent(QEvent *ev);
+	bool focusNextPrevChild(bool next);
+
+private slots:
+	void cursorOff();
+	void cursorOn();
+	void startBlinkOffTimer();
+	void startBlinkOnTimer();
+
+private:
+	QColor m_background;
+	int m_charWidth;
+	QFont m_font;
+
+	QTimer * timer_cursorBlinkOn ;
+	QTimer * timer_cursorBlinkOff ;
+	QTimer * timer_firstOff;
+	QTimer * timer_firstOn;
+
+
+	long m_blinkWaitTime, m_blinkOnTime, m_blinkOffTime;
+
+	enum blink_state{BLINK_NONE, BLINK_ON, BLINK_OFF};
+	blink_state blinkState;
+	bool m_encoding_utf8;
+
+	QQueue<PaintOperation> paintOps;
+
+	QTime m_lastClick;
+	int m_lastClickEvent;
+	QLabel *m_tooltip;
+
+	bool m_slowStringDrawing;
+	bool m_mouseHidden;
+};
+
+struct special_key
+{
+	int key_sym;
+	char_u code0;
+	char_u code1;
+};
+
+static const struct special_key special_keys[] =
+{
+	{Qt::Key_Up,		'k', 'u'},
+	{Qt::Key_Down,		'k', 'd'},
+	{Qt::Key_Left,		'k', 'l'},
+    	{Qt::Key_Right,		'k', 'r'},
+
+	{Qt::Key_F1,		'k', '1'},
+	{Qt::Key_F2,		'k', '2'},
+	{Qt::Key_F3,		'k', '3'},
+	{Qt::Key_F4,		'k', '4'},
+	{Qt::Key_F5,		'k', '5'},
+	{Qt::Key_F6,		'k', '6'},
+	{Qt::Key_F7,		'k', '7'},
+	{Qt::Key_F8,		'k', '8'},
+	{Qt::Key_F9,		'k', '9'},
+	{Qt::Key_F10,		'k', ';'},
+	{Qt::Key_F11,		'F', '1'},
+	{Qt::Key_F12,		'F', '2'},
+	{Qt::Key_F13,		'F', '3'},
+	{Qt::Key_F14,		'F', '4'},
+	{Qt::Key_Backspace,	'k', 'b'},
+
+	{Qt::Key_Delete,	'k', 'D'},
+	{Qt::Key_Insert,	'k', 'I'},
+	{Qt::Key_Home,		'k', 'h'},
+	{Qt::Key_End,		'@', '7'},
+	{Qt::Key_PageUp,	'k', 'P'},
+	{Qt::Key_PageDown,	'k', 'N'},
+
+	{Qt::Key_Print,		'%', '9'},
+
+	// The following are not really **special** but this
+	// allows to use these keys with any keyboard modifier while
+	// bypassing some of Qt's unwanted behaviour in the text()
+	//
+	{Qt::Key_Tab,		TAB, NUL},
+	{Qt::Key_Backtab,	TAB, NUL},
+	{Qt::Key_Escape,	ESC, NUL},
+	{Qt::Key_Return,	CAR, NUL},
+	{Qt::Key_Enter,		CAR, NUL},
+	{Qt::Key_Space,		' ', NUL},
+
+	/* End of list marker: */
+	{0, 0, 0}
+};
+
+#endif
diff -urN vim-src/src/qt/scrollarea.cpp vim-qt-src/src/qt/scrollarea.cpp
--- vim-src/src/qt/scrollarea.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/scrollarea.cpp	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,32 @@
+#include "scrollarea.moc"
+
+#include <QWidget>
+#include <QGridLayout>
+
+ScrollArea::ScrollArea(QWidget *parent)
+:QWidget(parent), m_widget(NULL)
+{
+	setAutoFillBackground(true);
+	m_layout = new QGridLayout(this);
+	m_layout->setSpacing(0);
+	m_layout->setContentsMargins(0,0,0,0);
+	m_layout->setAlignment(Qt::AlignTop | Qt::AlignHCenter);
+}
+
+void ScrollArea::setWidget(QWidget *w)
+{
+	if ( w == m_widget || !w ) {
+		return;
+	}
+
+	m_widget = w;
+	m_layout->addWidget(m_widget, 0, 1);
+}
+
+void ScrollArea::setBackgroundColor(const QColor& c)
+{
+	QPalette p = palette();
+	p.setColor(QPalette::Window, c);
+	setPalette(p);
+}
+
diff -urN vim-src/src/qt/scrollarea.h vim-qt-src/src/qt/scrollarea.h
--- vim-src/src/qt/scrollarea.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/scrollarea.h	2012-08-08 18:39:06.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef VIM_GUI_QT_SCROLLAREA
+#define VIM_GUI_QT_SCROLLAREA
+
+#include <QWidget>
+#include <QGridLayout>
+
+class ScrollArea: public QWidget
+{
+	Q_OBJECT
+public:
+	ScrollArea(QWidget *parent=0);
+	void setWidget(QWidget *widget);
+
+public slots:
+	void setBackgroundColor(const QColor&);
+
+private:
+	QWidget *m_widget;
+	QGridLayout *m_layout;
+
+};
+
+#endif
diff -urN vim-src/src/qt/tabbar.cpp vim-qt-src/src/qt/tabbar.cpp
--- vim-src/src/qt/tabbar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/tabbar.cpp	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,23 @@
+#include "tabbar.moc"
+
+#include <QMouseEvent>
+
+TabBar::TabBar(QWidget *parent)
+:QTabBar(parent)
+{
+}
+
+
+void TabBar::mouseReleaseEvent(QMouseEvent *ev)
+{
+	if (ev->button() != Qt::MiddleButton) {
+		QTabBar::mouseReleaseEvent(ev);
+		return;
+	}
+
+	int tab = tabAt(ev->pos());
+	if ( tab != -1 ) {
+		emit QTabBar::tabCloseRequested(tab);
+	}
+}
+
diff -urN vim-src/src/qt/tabbar.h vim-qt-src/src/qt/tabbar.h
--- vim-src/src/qt/tabbar.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/tabbar.h	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,17 @@
+#ifndef __GUI_QT_TABBAR__
+#define __GUI_QT_TABBAR__
+
+#include <QTabBar>
+
+class TabBar: public QTabBar
+{
+	Q_OBJECT
+public:
+	TabBar(QWidget *parent=0);
+
+protected:
+	virtual void mouseReleaseEvent(QMouseEvent *);
+
+};
+
+#endif
diff -urN vim-src/src/qt/vimaction.cpp vim-qt-src/src/qt/vimaction.cpp
--- vim-src/src/qt/vimaction.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimaction.cpp	2012-07-06 18:19:22.000000000 +0200
@@ -0,0 +1,60 @@
+#include "vimaction.moc"
+
+/**
+ * :help builtin-tools
+ */
+QStringList VimAction::iconNames = QStringList() 
+	<< "document-new"	// 00  New		open new window
+	<< "document-open"	// 01  Open		browse for file to open in current window
+	<< "document-save"	// 02  Save		write buffer to file
+	<< "edit-undo"		// 03  Undo		undo last change
+	<< "edit-redo"		// 04  Redo		redo last undone change
+	<< "edit-cut"		// 05  Cut		delete selected text to clipboard
+	<< "edit-copy"		// 06  Copy		copy selected text to clipboard
+	<< "edit-paste"		// 07  Paste		paste text from clipboard
+	<< "document-print"	// 08  Print		print current buffer
+	<< "help-contents"	// 09  Help		open a buffer on Vim's builtin help
+	<< "edit-find"		// 10  Find		start a search command
+	<< "document-save-all"	// 11  SaveAll		write all modified buffers to file
+	<< "document-save-as"	// 12  SaveSesn		write session file for current situation
+	<< "folder-new"		// 13  NewSesn		write new session file
+	<< "folder-open"	// 14  LoadSesn		load session file // FIXME
+	<< "system-run"		// 15  RunScript	browse for file to run as a Vim script
+	<< "edit-find-replace"	// 16  Replace		prompt for substitute command
+	<< "window-close"	// 17  WinClose		close current window
+	<< ""			// 18  WinMax		make current window use many lines // FIXME
+	<< ""			// 19  WinMin		make current window use few lines // FIXME
+<< "view-split-left-right"	// 20  WinSplit		split current window
+	<< "utilities-terminal"	// 21  Shell		start a shell
+	<< "go-previous"	// 22  FindPrev		search again, backward
+	<< "go-next"		// 23  FindNext		search again, forward
+	<< "help-faq"		// 24  FindHelp		prompt for word to search help for
+	<< "run-build"		// 25  Make		run make and jump to first error
+	<< "go-jump"		// 26  TagJump		jump to tag under the cursor
+	<< "table"		// 27  RunCtags		build tags for files in current directory
+<< "view-split-top-bottom"	// 28  WinVSplit	split current window vertically
+	<< "zoom-fit-height"	// 29  WinMaxWidth	make current window use many columns
+	<< "zoom-fit-width"	// 30  WinMinWidth	make current window use few columns
+	;
+
+VimAction::VimAction(vimmenu_T* menu, QObject *parent)
+:QAction(parent), m_menu(menu)
+{
+	if ( menu_is_toolbar(menu->parent->name) ) {
+		// FIXME: add support for iconfile
+		if ( menu->iconidx >= 0 && menu->iconidx <iconNames.size() ) {
+			setIcon( VimWrapper::icon(iconNames.at(menu->iconidx)) );
+		}
+
+		setToolTip(VimWrapper::convertFrom(menu->strings[MENU_INDEX_TIP]));
+	} else {
+		setText( VimWrapper::convertFrom(menu->name) );
+	}
+	connect(this, SIGNAL(triggered()),
+			this, SLOT(actionTriggered()));
+}
+
+void VimAction::actionTriggered()
+{
+	gui_menu_cb(m_menu);
+}
diff -urN vim-src/src/qt/vimaction.h vim-qt-src/src/qt/vimaction.h
--- vim-src/src/qt/vimaction.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimaction.h	2012-08-15 19:39:10.000000000 +0200
@@ -0,0 +1,21 @@
+#ifndef __GUI_QT_VIMACTION__
+#define __GUI_QT_VIMACTION__
+
+#include <QAction>
+#include "qvimshell.h"
+
+class VimAction: public QAction
+{
+	Q_OBJECT
+public:
+	VimAction(vimmenu_T *, QObject* );
+
+protected slots:
+	void actionTriggered();
+
+private:
+	vimmenu_T *m_menu;
+	static QStringList iconNames;
+};
+
+#endif
diff -urN vim-src/src/qt/vimevents.cpp vim-qt-src/src/qt/vimevents.cpp
--- vim-src/src/qt/vimevents.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimevents.cpp	2013-04-04 20:11:26.000000000 +0200
@@ -0,0 +1,38 @@
+#include "vimevents.h"
+#include "vimwrapper.h"
+
+VimEvent::VimEvent(VimWrapper &vim, EvType t)
+:vim(vim), m_type(t)
+{
+}
+
+ResizeEvent::ResizeEvent(VimWrapper &vim, int w, int h)
+:VimEvent(vim, Resize), width(w), height(h)
+{
+}
+
+void ResizeEvent::handle()
+{
+	vim.guiResizeShell(width, height);
+}
+
+CloseEvent::CloseEvent(VimWrapper& vim)
+:VimEvent(vim, Close)
+{
+}
+
+void CloseEvent::handle()
+{
+	vim.guiShellClosed();
+}
+
+DropEvent::DropEvent(VimWrapper& vim, const QPoint& pos, unsigned int mod, QList<QUrl> urls)
+:VimEvent(vim, Drop), pos(pos), mod(mod), urls(urls)
+{
+}
+
+void DropEvent::handle()
+{
+	vim.guiHandleDrop(pos, mod, urls);
+}
+
diff -urN vim-src/src/qt/vimevents.h vim-qt-src/src/qt/vimevents.h
--- vim-src/src/qt/vimevents.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimevents.h	2013-04-04 20:11:26.000000000 +0200
@@ -0,0 +1,51 @@
+#ifndef VIM_QT_VIMEVENT
+#define VIM_QT_VIMEVENT
+
+#include <QPoint>
+#include <QList>
+#include <QUrl>
+
+struct VimWrapper;
+// Base class
+class VimEvent {
+public:
+	enum EvType {Resize, Close, Drop};
+
+	VimEvent(VimWrapper& vim, EvType t);
+	virtual void handle()=0;
+	EvType type() { return m_type; }
+protected:
+	VimWrapper& vim;
+	EvType m_type;
+};
+
+
+class ResizeEvent: public VimEvent
+{
+public:
+	ResizeEvent(VimWrapper& vim, int w, int h);
+	void handle();
+private:
+	int width, height;
+
+};
+
+class CloseEvent: public VimEvent
+{
+public:
+	CloseEvent(VimWrapper& vim);
+	void handle();
+};
+
+class DropEvent: public VimEvent
+{
+public:
+	DropEvent(VimWrapper& vim, const QPoint& pos, unsigned int mod, QList<QUrl> urls);
+	void handle();
+private:
+	QPoint pos;
+	unsigned int mod;
+	QList<QUrl> urls;
+};
+
+#endif
diff -urN vim-src/src/qt/vimscrollbar.cpp vim-qt-src/src/qt/vimscrollbar.cpp
--- vim-src/src/qt/vimscrollbar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimscrollbar.cpp	2011-09-30 17:24:26.000000000 +0200
@@ -0,0 +1,63 @@
+#include "vimscrollbar.moc"
+
+VimScrollBar::VimScrollBar(scrollbar_T *sbar, Qt::Orientation o, QWidget *parent)
+:QScrollBar(o, parent), sb(sbar), m_index(-1), m_length(0)
+{
+	connect(this, SIGNAL(valueChanged(int)),
+			this, SLOT(draggingFinished()));
+}
+
+void VimScrollBar::dragging()
+{
+	if (sb == NULL) {
+		return;
+	}
+
+	gui_drag_scrollbar(sb, this->value(), 1);
+}
+
+void VimScrollBar::draggingFinished()
+{
+	if (sb == NULL) {
+		return;
+	}
+
+	gui_drag_scrollbar(sb, this->value(), 0);
+}
+
+void VimScrollBar::setIndex(int idx)
+{
+	if ( idx != m_index ) {
+		m_index = idx;
+		emit indexChanged(m_index);
+	}
+}
+
+void VimScrollBar::setLength(int len)
+{
+	if ( len != m_length ) {
+		m_length = len;
+		emit indexChanged(m_index); // FIXME
+	}
+}
+
+int VimScrollBar::length()
+{
+	return m_length;
+}
+
+int VimScrollBar::index() const
+{
+	return m_index;
+}
+
+void VimScrollBar::setVisible(bool show)
+{
+	bool visible = isVisible();
+	QScrollBar::setVisible(show);
+
+	if ( visible != show ) {
+		emit visibilityChanged(show);
+	}
+}
+
diff -urN vim-src/src/qt/vimscrollbar.h vim-qt-src/src/qt/vimscrollbar.h
--- vim-src/src/qt/vimscrollbar.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimscrollbar.h	2012-01-26 19:03:27.000000000 +0100
@@ -0,0 +1,35 @@
+#ifndef __GUI_QT_VIMSCROLLBAR__
+#define __GUI_QT_VIMSCROLLBAR__
+
+#include "qvimshell.h"
+
+#include <QScrollBar>
+
+class VimScrollBar: public QScrollBar
+{
+	Q_OBJECT
+public:
+	VimScrollBar(scrollbar_T *, Qt::Orientation, QWidget *parent=0);
+	void setIndex(int);
+	int index() const;
+	int length();
+
+	bool operator<(const VimScrollBar& other) { return ( m_index < other.m_index ); }
+
+	void setVisible(bool);
+	void setLength(int);
+signals:
+	void indexChanged(int);
+	void visibilityChanged(bool);
+
+protected slots:
+	void dragging();
+	void draggingFinished();
+
+private:
+	scrollbar_T *sb;
+	int m_index;
+	int m_length;
+};
+
+#endif
diff -urN vim-src/src/qt/vimwrapper.cpp vim-qt-src/src/qt/vimwrapper.cpp
--- vim-src/src/qt/vimwrapper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimwrapper.cpp	2014-01-11 00:34:30.624264228 +0100
@@ -0,0 +1,432 @@
+#include <QApplication>
+#include <QStyle>
+#include <QMetaType>
+#include <QTime>
+#include "vimwrapper.h"
+
+extern "C" {
+#include "vim.h"
+}
+
+Q_DECLARE_METATYPE( QList<QUrl> );
+
+VimWrapper::VimWrapper()
+:m_processInputOnly(false)
+{
+	qRegisterMetaType<QList<QUrl> >("URLList");
+
+}
+
+/*
+ * Post a vim resize event to be handled later
+ *
+ */
+void VimWrapper::postGuiResizeShell(int w, int h)
+{
+	ResizeEvent *new_ev = new ResizeEvent( *this, w, h);
+	foreach(VimEvent *ev, pendingEvents) {
+		if (ev->type() == VimEvent::Resize) {
+			pendingEvents.removeOne(ev);
+			delete ev;
+		}
+	}
+	pendingEvents.append(new_ev);
+}
+
+/*
+ * Notify Vim of a GUI resize
+ *
+ * If m_processInputOnly is true the handling of this event WILL
+ * be delayed
+ */
+void VimWrapper::guiResizeShell(int w, int h)
+{
+	if ( m_processInputOnly ) {
+		postGuiResizeShell(w, h);
+	} else {
+		gui_resize_shell(w, h);
+	}
+}
+
+void VimWrapper::guiShellClosed()
+{
+	if ( m_processInputOnly ) {
+		pendingEvents.append(new CloseEvent(*this));
+	} else {
+		gui_shell_closed();
+	}
+}
+
+void VimWrapper::guiSendMouseEvent(int button, int x, int y, int repeated_click, unsigned int modifiers)
+{
+	// This is safe
+	gui_send_mouse_event(button, x, y, repeated_click, modifiers);
+}
+
+void VimWrapper::guiMouseMoved(int x, int y)
+{
+	gui_mouse_moved(x, y);
+}
+
+void VimWrapper::guiFocusChanged(int focus)
+{
+	gui_focus_change(focus);
+}
+
+void VimWrapper::sendTablineEvent(int ev)
+{
+	// This just writes to the input buf
+	send_tabline_event(ev);
+}
+
+void VimWrapper::updateCursor(bool force, bool clearsel)
+{
+	gui_update_cursor( force ? TRUE: FALSE,
+				clearsel ? TRUE: FALSE);
+}
+
+void VimWrapper::undrawCursor()
+{
+	gui_undraw_cursor();
+}
+
+void VimWrapper::sendTablineMenuEvent(int idx, int ev)
+{
+	// This just writes to the input buf
+	send_tabline_menu_event(idx, ev);
+}
+
+/**
+ * Place text into the '~' register and push
+ * drop event into the input buffer
+ */
+void VimWrapper::guiHandleDropText(const QString& s)
+{
+	QByteArray text = convertTo(s);
+	dnd_yank_drag_data( (char_u*)text.data(), text.size());
+
+	char_u buf[3] = {CSI, KS_EXTRA, (char_u)KE_DROP};
+	add_to_input_buf(buf, 3);
+}
+
+void VimWrapper::guiHandleDrop(const QPoint& pos, unsigned int mod, const QList<QUrl> urls)
+{
+	if ( urls.size() == 0 ) {
+		return;
+	}
+
+	if ( m_processInputOnly ) {
+		DropEvent *ev = new DropEvent( *this, pos, mod, urls);
+		pendingEvents.append(ev);
+	} else {
+	
+		char_u **fnames = (char_u**)alloc( urls.size() * sizeof(char_u*));
+		int i;
+		for (i=0; i<urls.size(); i++) {
+			QByteArray encoded;
+			if ( urls.at(i).scheme() == "file" ) {
+				encoded = convertTo(urls.at(i).toLocalFile());
+			} else {
+				encoded = convertTo(urls.at(i).toString());
+			}
+	
+			char *s = (char*)alloc(encoded.size()*sizeof(char)+1);
+			int j;
+			for (j=0; j<encoded.size(); j++) {
+				s[j] = encoded.at(j);
+			}
+			s[j]='\0';
+			fnames[i] = (char_u *) s;
+		}
+		gui_handle_drop(pos.x(), pos.y(), mod, fnames, urls.size());
+	}
+}
+
+/**
+ * Map row/column into absolute pixel coordinates
+ *
+ * The returned point is the top left corner of the cell
+ *
+ */
+QPoint VimWrapper::mapText(int row, int col) 
+{ 
+	return QPoint( gui.char_width*col, gui.char_height*row );
+}
+
+QPoint VimWrapper::cursorPosition() 
+{ 
+	return mapText(gui.cursor_row, gui.cursor_col);
+}
+
+/**
+ * Return a rect from row1/col1 to row2/col2 (inclusive)
+ *
+ * The rect coordinates are in pixels
+ */
+QRect VimWrapper::mapBlock(int row1, int col1, int row2, int col2)
+{
+	QPoint tl = mapText( row1, col1 );
+	QPoint br = mapText( row2+1, col2+1);
+	br.setX( br.x()-1 );
+	br.setY( br.y()-1 );
+
+	return QRect(tl, br);
+}
+
+QColor VimWrapper::backgroundColor()
+{
+	return fromColor(gui.back_pixel);
+}
+
+QColor VimWrapper::normalColor()
+{
+	return fromColor(gui.norm_pixel);
+}
+
+int VimWrapper::charWidth()
+{
+	return gui.char_width;
+}
+
+int VimWrapper::charHeight()
+{
+	return gui.char_height;
+}
+
+QFont VimWrapper::normalFont()
+{
+	if ( gui.norm_font ) {
+		return *(gui.norm_font);
+	}
+
+	return QFont();
+}
+
+int VimWrapper::charCellWidth(const QChar& c)
+{
+	int len = utf_char2cells(c.unicode());
+	if ( len <= 2 ) {
+		return len;
+	}
+
+	return 0;
+}
+
+int VimWrapper::stringCellWidth(const QString& s)
+{
+	/*
+	 * Vim kindly provides us with utf_char2cells,
+	 * unfortunately Qt does not have a way measure
+	 * wide char length.
+	 */
+	int len=0;
+	foreach ( QChar c, s ) {
+		len += charCellWidth(c);
+	}
+	return len;
+}
+
+bool VimWrapper::isFakeMonospace(QFont f)
+{
+
+	QFont fi(f);
+	fi.setItalic(true);
+	QFont fb(f);
+	fb.setBold(true);
+	QFont fbi(fb);
+	fbi.setItalic(false);
+
+	QFontMetrics fm_normal(f);
+	QFontMetrics fm_italic(fi);
+	QFontMetrics fm_boldit(fbi);
+	QFontMetrics fm_bold(fb);
+
+	// Regular
+	if ( fm_normal.averageCharWidth() != fm_normal.maxWidth() ) {
+		QFontInfo info(f);
+		qDebug() << __func__ << f.family() 
+			<< "Average and Maximum font width mismatch for Regular font; QFont::exactMatch() is" << f.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Italic
+	if ( fm_italic.averageCharWidth() != fm_italic.maxWidth() ||
+			fm_italic.maxWidth()*2 != fm_italic.width("MM") ) {
+		QFontInfo info(fi);
+		qDebug() << __func__ << fi.family() << "Average and Maximum font width mismatch for Italic font; QFont::exactMatch() is" << fi.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Bold
+	if ( fm_bold.averageCharWidth() != fm_bold.maxWidth() ||
+			fm_bold.maxWidth()*2 != fm_bold.width("MM") ) {
+		QFontInfo info(fb);
+		qDebug() << __func__ << fb.family() << "Average and Maximum font width mismatch for Bold font; QFont::exactMatch() is" << fb.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	// Bold+Italic
+	if ( fm_boldit.averageCharWidth() != fm_boldit.maxWidth() ||
+			fm_boldit.maxWidth()*2 != fm_boldit.width("MM") ) {
+		QFontInfo info(fbi);
+		qDebug() << __func__ << fbi.family() << "Average and Maximum font width mismatch for Bold+Italic font; QFont::exactMatch() is" << fbi.exactMatch()
+			<< "Real font is " << info.family() << info.pointSize();
+		return true;
+	}
+
+	if ( fm_normal.maxWidth() != fm_italic.maxWidth() || 
+		fm_normal.maxWidth() != fm_boldit.maxWidth() || 
+		fm_normal.maxWidth() != fm_bold.maxWidth()) {
+		qDebug() << __func__ << f.family() << "Average and Maximum font width mismatch between font types";
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * Get an icon for a given name
+ *
+ * Icons are loaded in the following order:
+ * 1. If the name is a Vim icon name - map it into a theme name
+ * 2. If the system theme has the icon - use it
+ * 3. If not - load the icon from icons.qrc
+ * 4. As last resort - use a Qt standard icon
+ */
+QIcon VimWrapper::icon(const QString& name)
+{
+
+	QIcon icon;
+
+	icon = QIcon::fromTheme(name.toLower(), QIcon(":/icons/" + name + ".png"));
+	if ( icon.isNull() ) {
+		return QApplication::style()->standardIcon(QStyle::SP_FileLinkIcon);
+	}
+
+	return icon;
+}
+
+QColor
+VimWrapper::fromColor(long color)
+{
+	if ( color == INVALCOLOR ) {
+		return QColor();
+	}
+
+	int red = ((color & 0x00FF0000) >> 16);
+	int green = ((color & 0x0000FF00) >>  8);
+	int blue = ((color & 0x000000FF) >>  0);
+
+	return QColor(red, green, blue);
+}
+
+long
+VimWrapper::toColor(const QColor& c)
+{
+	return ((long)c.red() << 16) + ((long)c.green() << 8) + ((long)c.blue());
+}
+
+void
+VimWrapper::newTab(int idx)
+{
+	send_tabline_menu_event(idx, TABLINE_MENU_NEW);
+}
+
+QByteArray VimWrapper::convertTo(const QString& s)
+{
+	bool m_encoding_utf8 = true; // FIXME: check encoding
+
+	if ( m_encoding_utf8 ) {
+		return s.toUtf8();
+	} else {
+		return s.toLatin1();
+	}
+}
+
+QString VimWrapper::convertFrom(const char *s, int size)
+{
+	bool m_encoding_utf8 = true; // FIXME: check encoding
+
+	if ( m_encoding_utf8 ) {
+		return QString::fromUtf8(s, size);
+	} else {
+		return QString::fromLatin1(s, size);
+	}
+}
+
+QString VimWrapper::convertFrom(const QByteArray& arr)
+{
+	return convertFrom( arr.data(), arr.size());
+}
+
+QString VimWrapper::convertFrom(const char_u *s, int size)
+{
+	return convertFrom( (char*)s, size);
+}
+
+void VimWrapper::setFullscreen(bool on)
+{
+	if (on) {
+		p_fullscreen = TRUE;
+	} else {
+		p_fullscreen = FALSE;
+	}
+}
+
+/**
+ *
+ *  wtime == -1	    Wait forever.
+ *  wtime == 0	    Process what you have and exit
+ *  wtime > 0	    Wait wtime milliseconds for a character.
+ *
+ *  Just like gui_mch_wait_for_chars we return OK if there is
+ *  input or FAIL otherwise
+ */
+bool VimWrapper::processEvents(long wtime, bool inputOnly)
+{
+	bool prev = m_processInputOnly;
+	m_processInputOnly = inputOnly;
+
+	// Process pending events
+	if (!inputOnly) {
+		while(pendingEvents.size() > 0) {
+			VimEvent *ev = pendingEvents.takeFirst();
+			ev->handle();
+			delete ev;
+		}
+	}
+
+	int ret = FAIL;
+	if ( wtime == -1 ) {
+		QApplication::processEvents( QEventLoop::WaitForMoreEvents);
+	} else if ( wtime == 0 ) {
+		QApplication::processEvents();
+	} else {
+		QTime t;
+		t.start();
+		do {
+
+			QApplication::processEvents( QEventLoop::WaitForMoreEvents);
+			if ( hasPendingEvents() || !vim_is_input_buf_empty() ) {
+				goto out;
+			}
+		} while( t.elapsed() < wtime );
+	}
+
+out:
+	m_processInputOnly = prev;
+	if ( hasPendingEvents() || !vim_is_input_buf_empty() ) {
+		return OK;
+	} else {
+		return FAIL;
+	}
+}
+
+bool VimWrapper::hasPendingEvents()
+{
+	return pendingEvents.size() != 0;
+}
+
diff -urN vim-src/src/qt/vimwrapper.h vim-qt-src/src/qt/vimwrapper.h
--- vim-src/src/qt/vimwrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ vim-qt-src/src/qt/vimwrapper.h	2012-09-05 18:29:40.000000000 +0200
@@ -0,0 +1,114 @@
+#ifndef __VIM_QT_VIM__
+#define __VIM_QT_VIM__
+
+#include <QObject>
+#include <QIcon>
+#include <QUrl>
+#include <QWidget>
+#include <QDebug>
+
+extern "C" {
+#include "vim.h"
+}
+
+#include "vimevents.h"
+
+/**
+ * VimWrapper is wrapper around Vim, it handles conversion between Qt types
+ * and vim function's argument types
+ *
+ */
+class VimWrapper
+{
+public:
+	VimWrapper();
+	
+	/**
+	 * Map a row/col coordinate to a point in widget coordinates
+	 */
+	static QPoint mapText(int row, int col);
+
+	/**
+	 * Returns the current cursor coordinates(top left corner)
+	 */
+	static QPoint cursorPosition();
+
+	/**
+	 * Map an area in row/col(inclusive) coordinates into
+	 * widget coordinates
+	 */
+	static QRect mapBlock(int row1, int col1, int row2, int col2);
+
+	/**
+	 * The current background pixel color
+	 */
+	static QColor backgroundColor();
+
+	/**
+	 * Normal text color
+	 */
+	static QColor normalColor();
+
+	static int charWidth();
+	static int charHeight();
+
+	/**
+	 * Gui normal font
+	 */
+	static QFont normalFont();
+
+	static int stringCellWidth(const QString&);
+	static int charCellWidth(const QChar&);
+	static bool isFakeMonospace(QFont );
+
+	/**
+	 * Load icons
+	 */
+	static QIcon icon(const QString&);
+
+	static QColor fromColor(long);
+	static long toColor(const QColor&);
+
+	/**
+	 * New tab
+	 */
+	static void newTab(int idx=1);
+
+	static QByteArray convertTo(const QString& s);
+	static QString convertFrom(const char_u *, int size=-1);
+	static QString convertFrom(const QByteArray&);
+
+
+	/**
+	 * Vim methods
+	 */
+	void postGuiResizeShell(int w, int h);
+	void guiResizeShell(int w, int h);
+	void guiShellClosed();
+	void guiSendMouseEvent(int , int , int , int , unsigned int );
+	void guiMouseMoved(int, int);
+	void guiFocusChanged(int);
+
+	void guiHandleDropText(const QString&);
+	void guiHandleDrop(const QPoint& , unsigned int, const QList<QUrl>);
+
+	void sendTablineEvent(int);
+	void sendTablineMenuEvent(int, int);
+
+	void updateCursor(bool force, bool clearsel);
+	void undrawCursor();
+
+	static void setFullscreen(bool on);
+	void setProcessInputOnly(bool input_only);
+	bool processEvents(long wtime=0, bool inputOnly=false);
+
+protected:
+	static QString convertFrom(const char *, int size=-1);
+	bool hasPendingEvents();
+
+private:
+	bool m_processInputOnly;
+	QList<VimEvent *> pendingEvents;
+};
+
+#endif
diff -urN vim-src/src/structs.h vim-qt-src/src/structs.h
--- vim-src/src/structs.h	2014-09-24 20:45:28.094431022 +0200
+++ vim-qt-src/src/structs.h	2014-09-24 20:43:02.899346378 +0200
@@ -2464,6 +2464,10 @@
 
 typedef struct VimMenu vimmenu_T;
 
+#ifdef FEAT_GUI_QT
+struct QMenu;
+#endif
+
 struct VimMenu
 {
     int		modes;		    /* Which modes is this menu visible for? */
@@ -2536,6 +2540,10 @@
     PtWidget_t	*id;
     PtWidget_t	*submenu_id;
 #endif
+#ifdef FEAT_GUI_QT
+    struct QWidget	*qmenu;
+    struct QAction	*qaction;
+#endif
 };
 #else
 /* For generating prototypes when FEAT_MENU isn't defined. */
diff -urN vim-src/src/term.c vim-qt-src/src/term.c
--- vim-src/src/term.c	2014-09-24 20:45:28.313429577 +0200
+++ vim-qt-src/src/term.c	2014-09-24 20:43:02.903346354 +0200
@@ -6013,7 +6013,7 @@
 }
 #endif
 
-#if (defined(WIN3264) && !defined(FEAT_GUI)) || defined(PROTO)
+#if (defined(WIN3264) && !defined(FEAT_GUI)) || defined(PROTO) || (defined(WIN3264) && defined(FEAT_GUI_QT))
 static char ksme_str[20];
 static char ksmr_str[20];
 static char ksmd_str[20];
diff -urN vim-src/src/ui.c vim-qt-src/src/ui.c
--- vim-src/src/ui.c	2014-09-24 20:45:28.865425935 +0200
+++ vim-qt-src/src/ui.c	2014-09-24 20:43:03.161344806 +0200
@@ -3155,7 +3155,7 @@
 
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
 	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
-	|| defined(FEAT_GUI_PHOTON) || defined(PROTO)
+	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_QT) || defined(PROTO)
 /*
  * Translate window coordinates to buffer position without any side effects
  */
diff -urN vim-src/src/vim.h vim-qt-src/src/vim.h
--- vim-src/src/vim.h	2014-09-24 20:45:28.873425882 +0200
+++ vim-qt-src/src/vim.h	2014-09-24 20:43:03.162344800 +0200
@@ -121,6 +121,11 @@
 # define FEAT_GUI_MAC
 #endif
 
+#if defined(FEAT_GUI_QT)
+# define FEAT_GUI
+#endif
+
+
 #if defined(FEAT_GUI_MOTIF) \
     || defined(FEAT_GUI_GTK) \
     || defined(FEAT_GUI_ATHENA) \
@@ -1946,6 +1951,10 @@
     GdkAtom     gtk_sel_atom;	/* PRIMARY/CLIPBOARD selection ID */
 # endif
 
+# ifdef FEAT_GUI_QT
+    int		clipboardMode;
+# endif
+
 # if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
     int_u	format;		/* Vim's own special clipboard format */
     int_u	format_raw;	/* Vim's raw text clipboard format */
diff -urN vim-src/src/winclip.c vim-qt-src/src/winclip.c
--- vim-src/src/winclip.c	2014-09-24 20:45:28.873425882 +0200
+++ vim-qt-src/src/winclip.c	2014-09-24 20:43:03.163344794 +0200
@@ -190,7 +190,7 @@
 
 #endif /* FEAT_MBYTE */
 
-#ifdef FEAT_CLIPBOARD
+#if defined(FEAT_CLIPBOARD) && !defined(FEAT_GUI_QT)
 /*
  * Clipboard stuff, for cutting and pasting text to other windows.
  */
@@ -643,7 +643,7 @@
 	GlobalFree(hMemVim);
 }
 
-#endif /* FEAT_CLIPBOARD */
+#endif /* FEAT_CLIPBOARD && !FEAT_GUI_QT */
 
 #if defined(FEAT_MBYTE) || defined(PROTO)
 /*
